"use strict";
(self["webpackChunkits_not_fair"] = self["webpackChunkits_not_fair"] || []).push([["commons-node_modules_parse-uri_index_js-node_modules_pixi_js_lib_pixi_es_js"],{

/***/ "./node_modules/@pixi/accessibility/lib/accessibility.es.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/accessibility.es.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessibilityManager": () => (/* binding */ AccessibilityManager),
/* harmony export */   "accessibleTarget": () => (/* binding */ accessibleTarget)
/* harmony export */ });
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/*!
 * @pixi/accessibility - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



/**
 * Default property values of accessible objects
 * used by {@link PIXI.accessibility.AccessibilityManager}.
 *
 * @private
 * @function accessibleTarget
 * @memberof PIXI.accessibility
 * @type {Object}
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.accessibility.accessibleTarget
 *      );
 */
var accessibleTarget = {
    /**
     *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
     *   shadow div with attributes set
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    accessible: false,

    /**
     * Sets the title attribute of the shadow div
     * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
     *
     * @member {?string}
     * @memberof PIXI.DisplayObject#
     */
    accessibleTitle: null,

    /**
     * Sets the aria-label attribute of the shadow div
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     */
    accessibleHint: null,

    /**
     * @member {number}
     * @memberof PIXI.DisplayObject#
     * @private
     * @todo Needs docs.
     */
    tabIndex: 0,

    /**
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @todo Needs docs.
     */
    _accessibleActive: false,

    /**
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @todo Needs docs.
     */
    _accessibleDiv: false,
};

// add some extra variables to the container..
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.mixin(accessibleTarget);

var KEY_CODE_TAB = 9;

var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;

var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1000;
var DIV_HOOK_POS_Y = -1000;
var DIV_HOOK_ZINDEX = 2;

/**
 * The Accessibility manager recreates the ability to tab and have content read by screen readers.
 * This is very important as it can possibly help people with disabilities access PixiJS content.
 *
 * A DisplayObject can be made accessible just like it can be made interactive. This manager will map the
 * events as if the mouse was being used, minimizing the effort required to implement.
 *
 * An instance of this class is automatically created by default, and can be found at `renderer.plugins.accessibility`
 *
 * @class
 * @memberof PIXI.accessibility
 */
var AccessibilityManager = function AccessibilityManager(renderer)
{
    /**
     * @type {?HTMLElement}
     * @private
     */
    this._hookDiv = null;
    if (_pixi_utils__WEBPACK_IMPORTED_MODULE_0__.isMobile.tablet || _pixi_utils__WEBPACK_IMPORTED_MODULE_0__.isMobile.phone)
    {
        this.createTouchHook();
    }

    // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
    var div = document.createElement('div');

    div.style.width = DIV_TOUCH_SIZE + "px";
    div.style.height = DIV_TOUCH_SIZE + "px";
    div.style.position = 'absolute';
    div.style.top = DIV_TOUCH_POS_X + "px";
    div.style.left = DIV_TOUCH_POS_Y + "px";
    div.style.zIndex = DIV_TOUCH_ZINDEX;

    /**
     * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
     *
     * @type {HTMLElement}
     * @private
     */
    this.div = div;

    /**
     * A simple pool for storing divs.
     *
     * @type {*}
     * @private
     */
    this.pool = [];

    /**
     * This is a tick used to check if an object is no longer being rendered.
     *
     * @type {Number}
     * @private
     */
    this.renderId = 0;

    /**
     * Setting this to true will visually show the divs.
     *
     * @type {boolean}
     */
    this.debug = false;

    /**
     * The renderer this accessibility manager works for.
     *
     * @member {PIXI.AbstractRenderer}
     */
    this.renderer = renderer;

    /**
     * The array of currently active accessible items.
     *
     * @member {Array<*>}
     * @private
     */
    this.children = [];

    /**
     * pre-bind the functions
     *
     * @type {Function}
     * @private
     */
    this._onKeyDown = this._onKeyDown.bind(this);

    /**
     * pre-bind the functions
     *
     * @type {Function}
     * @private
     */
    this._onMouseMove = this._onMouseMove.bind(this);

    /**
     * A flag
     * @type {boolean}
     * @readonly
     */
    this.isActive = false;

    /**
     * A flag
     * @type {boolean}
     * @readonly
     */
    this.isMobileAccessibility = false;

    // let listen for tab.. once pressed we can fire up and show the accessibility layer
    window.addEventListener('keydown', this._onKeyDown, false);
};

/**
 * Creates the touch hooks.
 *
 * @private
 */
AccessibilityManager.prototype.createTouchHook = function createTouchHook ()
{
        var this$1 = this;

    var hookDiv = document.createElement('button');

    hookDiv.style.width = DIV_HOOK_SIZE + "px";
    hookDiv.style.height = DIV_HOOK_SIZE + "px";
    hookDiv.style.position = 'absolute';
    hookDiv.style.top = DIV_HOOK_POS_X + "px";
    hookDiv.style.left = DIV_HOOK_POS_Y + "px";
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX;
    hookDiv.style.backgroundColor = '#FF0000';
    hookDiv.title = 'HOOK DIV';

    hookDiv.addEventListener('focus', function () {
        this$1.isMobileAccessibility = true;
        this$1.activate();
        this$1.destroyTouchHook();
    });

    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
};

/**
 * Destroys the touch hooks.
 *
 * @private
 */
AccessibilityManager.prototype.destroyTouchHook = function destroyTouchHook ()
{
    if (!this._hookDiv)
    {
        return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
};

/**
 * Activating will cause the Accessibility layer to be shown.
 * This is called when a user presses the tab key.
 *
 * @private
 */
AccessibilityManager.prototype.activate = function activate ()
{
    if (this.isActive)
    {
        return;
    }

    this.isActive = true;

    window.document.addEventListener('mousemove', this._onMouseMove, true);
    window.removeEventListener('keydown', this._onKeyDown, false);

    this.renderer.on('postrender', this.update, this);

    if (this.renderer.view.parentNode)
    {
        this.renderer.view.parentNode.appendChild(this.div);
    }
};

/**
 * Deactivating will cause the Accessibility layer to be hidden.
 * This is called when a user moves the mouse.
 *
 * @private
 */
AccessibilityManager.prototype.deactivate = function deactivate ()
{
    if (!this.isActive || this.isMobileAccessibility)
    {
        return;
    }

    this.isActive = false;

    window.document.removeEventListener('mousemove', this._onMouseMove, true);
    window.addEventListener('keydown', this._onKeyDown, false);

    this.renderer.off('postrender', this.update);

    if (this.div.parentNode)
    {
        this.div.parentNode.removeChild(this.div);
    }
};

/**
 * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
 *
 * @private
 * @param {PIXI.Container} displayObject - The DisplayObject to check.
 */
AccessibilityManager.prototype.updateAccessibleObjects = function updateAccessibleObjects (displayObject)
{
    if (!displayObject.visible)
    {
        return;
    }

    if (displayObject.accessible && displayObject.interactive)
    {
        if (!displayObject._accessibleActive)
        {
            this.addChild(displayObject);
        }

        displayObject.renderId = this.renderId;
    }

    var children = displayObject.children;

    for (var i = 0; i < children.length; i++)
    {
        this.updateAccessibleObjects(children[i]);
    }
};

/**
 * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
 *
 * @private
 */
AccessibilityManager.prototype.update = function update ()
{
    if (!this.renderer.renderingToScreen)
    {
        return;
    }

    // update children...
    this.updateAccessibleObjects(this.renderer._lastObjectRendered);

    var rect = this.renderer.view.getBoundingClientRect();
    var sx = rect.width / this.renderer.width;
    var sy = rect.height / this.renderer.height;

    var div = this.div;

    div.style.left = (rect.left) + "px";
    div.style.top = (rect.top) + "px";
    div.style.width = (this.renderer.width) + "px";
    div.style.height = (this.renderer.height) + "px";

    for (var i = 0; i < this.children.length; i++)
    {
        var child = this.children[i];

        if (child.renderId !== this.renderId)
        {
            child._accessibleActive = false;

            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_0__.removeItems)(this.children, i, 1);
            this.div.removeChild(child._accessibleDiv);
            this.pool.push(child._accessibleDiv);
            child._accessibleDiv = null;

            i--;

            if (this.children.length === 0)
            {
                this.deactivate();
            }
        }
        else
        {
            // map div to display..
            div = child._accessibleDiv;
            var hitArea = child.hitArea;
            var wt = child.worldTransform;

            if (child.hitArea)
            {
                div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + "px";
                div.style.top = ((wt.ty + (hitArea.y * wt.d)) * sy) + "px";

                div.style.width = (hitArea.width * wt.a * sx) + "px";
                div.style.height = (hitArea.height * wt.d * sy) + "px";
            }
            else
            {
                hitArea = child.getBounds();

                this.capHitArea(hitArea);

                div.style.left = (hitArea.x * sx) + "px";
                div.style.top = (hitArea.y * sy) + "px";

                div.style.width = (hitArea.width * sx) + "px";
                div.style.height = (hitArea.height * sy) + "px";

                // update button titles and hints if they exist and they've changed
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null)
                {
                    div.title = child.accessibleTitle;
                }
                if (div.getAttribute('aria-label') !== child.accessibleHint
                    && child.accessibleHint !== null)
                {
                    div.setAttribute('aria-label', child.accessibleHint);
                }
            }
        }
    }

    // increment the render id..
    this.renderId++;
};

/**
 * Adjust the hit area based on the bounds of a display object
 *
 * @param {PIXI.Rectangle} hitArea - Bounds of the child
 */
AccessibilityManager.prototype.capHitArea = function capHitArea (hitArea)
{
    if (hitArea.x < 0)
    {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
    }

    if (hitArea.y < 0)
    {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
    }

    if (hitArea.x + hitArea.width > this.renderer.width)
    {
        hitArea.width = this.renderer.width - hitArea.x;
    }

    if (hitArea.y + hitArea.height > this.renderer.height)
    {
        hitArea.height = this.renderer.height - hitArea.y;
    }
};

/**
 * Adds a DisplayObject to the accessibility manager
 *
 * @private
 * @param {PIXI.DisplayObject} displayObject - The child to make accessible.
 */
AccessibilityManager.prototype.addChild = function addChild (displayObject)
{
    //this.activate();

    var div = this.pool.pop();

    if (!div)
    {
        div = document.createElement('button');

        div.style.width = DIV_TOUCH_SIZE + "px";
        div.style.height = DIV_TOUCH_SIZE + "px";
        div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
        div.style.position = 'absolute';
        div.style.zIndex = DIV_TOUCH_ZINDEX;
        div.style.borderStyle = 'none';

        // ARIA attributes ensure that button title and hint updates are announced properly
        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
        {
            // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
            div.setAttribute('aria-live', 'off');
        }
        else
        {
            div.setAttribute('aria-live', 'polite');
        }

        if (navigator.userAgent.match(/rv:.*Gecko\//))
        {
            // FireFox needs this to announce only the new button name
            div.setAttribute('aria-relevant', 'additions');
        }
        else
        {
            // required by IE, other browsers don't much care
            div.setAttribute('aria-relevant', 'text');
        }

        div.addEventListener('click', this._onClick.bind(this));
        div.addEventListener('focus', this._onFocus.bind(this));
        div.addEventListener('focusout', this._onFocusOut.bind(this));
    }

    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null)
    {
        div.title = displayObject.accessibleTitle;
    }
    else if (!displayObject.accessibleHint
             || displayObject.accessibleHint === null)
    {
        div.title = "displayObject " + (displayObject.tabIndex);
    }

    if (displayObject.accessibleHint
        && displayObject.accessibleHint !== null)
    {
        div.setAttribute('aria-label', displayObject.accessibleHint);
    }

    //

    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;

    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
};

/**
 * Maps the div button press to pixi's InteractionManager (click)
 *
 * @private
 * @param {MouseEvent} e - The click event.
 */
AccessibilityManager.prototype._onClick = function _onClick (e)
{
    var interactionManager = this.renderer.plugins.interaction;

    interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    interactionManager.dispatchEvent(e.target.displayObject, 'pointertap', interactionManager.eventData);
    interactionManager.dispatchEvent(e.target.displayObject, 'tap', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixi's InteractionManager (mouseover)
 *
 * @private
 * @param {FocusEvent} e - The focus event.
 */
AccessibilityManager.prototype._onFocus = function _onFocus (e)
{
    if (!e.target.getAttribute('aria-live', 'off'))
    {
        e.target.setAttribute('aria-live', 'assertive');
    }
    var interactionManager = this.renderer.plugins.interaction;

    interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
};

/**
 * Maps the div focus events to pixi's InteractionManager (mouseout)
 *
 * @private
 * @param {FocusEvent} e - The focusout event.
 */
AccessibilityManager.prototype._onFocusOut = function _onFocusOut (e)
{
    if (!e.target.getAttribute('aria-live', 'off'))
    {
        e.target.setAttribute('aria-live', 'polite');
    }
    var interactionManager = this.renderer.plugins.interaction;

    interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
};

/**
 * Is called when a key is pressed
 *
 * @private
 * @param {KeyboardEvent} e - The keydown event.
 */
AccessibilityManager.prototype._onKeyDown = function _onKeyDown (e)
{
    if (e.keyCode !== KEY_CODE_TAB)
    {
        return;
    }

    this.activate();
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @private
 * @param {MouseEvent} e - The mouse event.
 */
AccessibilityManager.prototype._onMouseMove = function _onMouseMove (e)
{
    if (e.movementX === 0 && e.movementY === 0)
    {
        return;
    }

    this.deactivate();
};

/**
 * Destroys the accessibility manager
 *
 */
AccessibilityManager.prototype.destroy = function destroy ()
{
    this.destroyTouchHook();
    this.div = null;

    for (var i = 0; i < this.children.length; i++)
    {
        this.children[i].div = null;
    }

    window.document.removeEventListener('mousemove', this._onMouseMove, true);
    window.removeEventListener('keydown', this._onKeyDown);

    this.pool = null;
    this.children = null;
    this.renderer = null;
};

/**
 * This namespace contains an accessibility plugin for allowing interaction via the keyboard.
 *
 * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.
 * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.
 * @namespace PIXI.accessibility
 */


//# sourceMappingURL=accessibility.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/app.es.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/app/lib/app.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/app - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



/**
 * Convenience class to create a new PIXI application.
 *
 * This class automatically creates the renderer, ticker and root container.
 *
 * @example
 * // Create the application
 * const app = new PIXI.Application();
 *
 * // Add the view to the DOM
 * document.body.appendChild(app.view);
 *
 * // ex, add display objects
 * app.stage.addChild(PIXI.Sprite.from('something.png'));
 *
 * @class
 * @memberof PIXI
 */
var Application = function Application(options)
{
    var this$1 = this;

    // The default options
    options = Object.assign({
        forceCanvas: false,
    }, options);

    /**
     * WebGL renderer if available, otherwise CanvasRenderer.
     * @member {PIXI.Renderer|PIXI.CanvasRenderer}
     */
    this.renderer = (0,_pixi_core__WEBPACK_IMPORTED_MODULE_1__.autoDetectRenderer)(options);

    /**
     * The root display container that's rendered.
     * @member {PIXI.Container}
     */
    this.stage = new _pixi_display__WEBPACK_IMPORTED_MODULE_0__.Container();

    // install plugins here
    Application._plugins.forEach(function (plugin) {
        plugin.init.call(this$1, options);
    });
};

var prototypeAccessors = { view: { configurable: true },screen: { configurable: true } };

/**
 * Register a middleware plugin for the application
 * @static
 * @param {PIXI.Application.Plugin} plugin - Plugin being installed
 */
Application.registerPlugin = function registerPlugin (plugin)
{
    Application._plugins.push(plugin);
};

/**
 * Render the current stage.
 */
Application.prototype.render = function render ()
{
    this.renderer.render(this.stage);
};

/**
 * Reference to the renderer's canvas element.
 * @member {HTMLCanvasElement}
 * @readonly
 */
prototypeAccessors.view.get = function ()
{
    return this.renderer.view;
};

/**
 * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
 * @member {PIXI.Rectangle}
 * @readonly
 */
prototypeAccessors.screen.get = function ()
{
    return this.renderer.screen;
};

/**
 * Destroy and don't use after this.
 * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
 * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
 *  have been set to that value
 * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
 *  method called as well. 'stageOptions' will be passed on to those calls.
 * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
 *  to true. Should it destroy the texture of the child sprite
 * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
 *  to true. Should it destroy the base texture of the child sprite
 */
Application.prototype.destroy = function destroy (removeView, stageOptions)
{
        var this$1 = this;

    // Destroy plugins in the opposite order
    // which they were constructed
    var plugins = Application._plugins.slice(0);

    plugins.reverse();
    plugins.forEach(function (plugin) {
        plugin.destroy.call(this$1);
    });

    this.stage.destroy(stageOptions);
    this.stage = null;

    this.renderer.destroy(removeView);
    this.renderer = null;

    this._options = null;
};

Object.defineProperties( Application.prototype, prototypeAccessors );

/**
 * @memberof PIXI.Application
 * @typedef {object} Plugin
 * @property {function} init - Called when Application is constructed, scoped to Application instance.
 *  Passes in `options` as the only argument, which are Application constructor options.
 * @property {function} destroy - Called when destroying Application, scoped to Application instance
 */

/**
 * Collection of installed plugins.
 * @static
 * @private
 * @type {PIXI.Application.Plugin[]}
 */
Application._plugins = [];

/**
 * Middleware for for Application's resize functionality
 * @private
 * @class
 */
var ResizePlugin = function ResizePlugin () {};

ResizePlugin.init = function init (options)
{
        var this$1 = this;

    /**
     * The element or window to resize the application to.
     * @type {Window|HTMLElement}
     * @name resizeTo
     * @memberof PIXI.Application#
     */
    Object.defineProperty(this, 'resizeTo',
        {
            set: function set(dom)
            {
                window.removeEventListener('resize', this.resize);
                this._resizeTo = dom;
                if (dom)
                {
                    window.addEventListener('resize', this.resize);
                    this.resize();
                }
            },
            get: function get()
            {
                return this._resizeTo;
            },
        });

    /**
     * If `resizeTo` is set, calling this function
     * will resize to the width and height of that element.
     * @method PIXI.Application#resize
     */
    this.resize = function () {
        if (this$1._resizeTo)
        {
            // Resize to the window
            if (this$1._resizeTo === window)
            {
                this$1.renderer.resize(
                    window.innerWidth,
                    window.innerHeight
                );
            }
            // Resize to other HTML entities
            else
            {
                this$1.renderer.resize(
                    this$1._resizeTo.clientWidth,
                    this$1._resizeTo.clientHeight
                );
            }
        }
    };

    // On resize
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
};

/**
 * Clean up the ticker, scoped to application
 * @static
 * @private
 */
ResizePlugin.destroy = function destroy ()
{
    this.resizeTo = null;
    this.resize = null;
};

Application.registerPlugin(ResizePlugin);


//# sourceMappingURL=app.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/constants/lib/constants.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/constants/lib/constants.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BLEND_MODES": () => (/* binding */ BLEND_MODES),
/* harmony export */   "DRAW_MODES": () => (/* binding */ DRAW_MODES),
/* harmony export */   "ENV": () => (/* binding */ ENV),
/* harmony export */   "FORMATS": () => (/* binding */ FORMATS),
/* harmony export */   "GC_MODES": () => (/* binding */ GC_MODES),
/* harmony export */   "MIPMAP_MODES": () => (/* binding */ MIPMAP_MODES),
/* harmony export */   "PRECISION": () => (/* binding */ PRECISION),
/* harmony export */   "RENDERER_TYPE": () => (/* binding */ RENDERER_TYPE),
/* harmony export */   "SCALE_MODES": () => (/* binding */ SCALE_MODES),
/* harmony export */   "TARGETS": () => (/* binding */ TARGETS),
/* harmony export */   "TYPES": () => (/* binding */ TYPES),
/* harmony export */   "WRAP_MODES": () => (/* binding */ WRAP_MODES)
/* harmony export */ });
/*!
 * @pixi/constants - v5.1.0
 * Compiled Fri, 19 Jul 2019 21:54:36 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/**
 * Different types of environments for WebGL.
 *
 * @static
 * @memberof PIXI
 * @name ENV
 * @enum {number}
 * @property {number} WEBGL_LEGACY - Used for older v1 WebGL devices. PixiJS will aim to ensure compatibility
 *  with older / less advanced devices. If you experience unexplained flickering prefer this environment.
 * @property {number} WEBGL - Version 1 of WebGL
 * @property {number} WEBGL2 - Version 2 of WebGL
 */
var ENV = {
    WEBGL_LEGACY: 0,
    WEBGL: 1,
    WEBGL2: 2,
};

/**
 * Constant to identify the Renderer Type.
 *
 * @static
 * @memberof PIXI
 * @name RENDERER_TYPE
 * @enum {number}
 * @property {number} UNKNOWN - Unknown render type.
 * @property {number} WEBGL - WebGL render type.
 * @property {number} CANVAS - Canvas render type.
 */
var RENDERER_TYPE = {
    UNKNOWN:    0,
    WEBGL:      1,
    CANVAS:     2,
};

/**
 * Various blend modes supported by PIXI.
 *
 * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
 * Anything else will silently act like NORMAL.
 *
 * @memberof PIXI
 * @name BLEND_MODES
 * @enum {number}
 * @property {number} NORMAL
 * @property {number} ADD
 * @property {number} MULTIPLY
 * @property {number} SCREEN
 * @property {number} OVERLAY
 * @property {number} DARKEN
 * @property {number} LIGHTEN
 * @property {number} COLOR_DODGE
 * @property {number} COLOR_BURN
 * @property {number} HARD_LIGHT
 * @property {number} SOFT_LIGHT
 * @property {number} DIFFERENCE
 * @property {number} EXCLUSION
 * @property {number} HUE
 * @property {number} SATURATION
 * @property {number} COLOR
 * @property {number} LUMINOSITY
 * @property {number} NORMAL_NPM
 * @property {number} ADD_NPM
 * @property {number} SCREEN_NPM
 * @property {number} NONE
 * @property {number} SRC_IN
 * @property {number} SRC_OUT
 * @property {number} SRC_ATOP
 * @property {number} DST_OVER
 * @property {number} DST_IN
 * @property {number} DST_OUT
 * @property {number} DST_ATOP
 * @property {number} SUBTRACT
 * @property {number} SRC_OVER
 * @property {number} ERASE
 */
var BLEND_MODES = {
    NORMAL:         0,
    ADD:            1,
    MULTIPLY:       2,
    SCREEN:         3,
    OVERLAY:        4,
    DARKEN:         5,
    LIGHTEN:        6,
    COLOR_DODGE:    7,
    COLOR_BURN:     8,
    HARD_LIGHT:     9,
    SOFT_LIGHT:     10,
    DIFFERENCE:     11,
    EXCLUSION:      12,
    HUE:            13,
    SATURATION:     14,
    COLOR:          15,
    LUMINOSITY:     16,
    NORMAL_NPM:     17,
    ADD_NPM:        18,
    SCREEN_NPM:     19,
    NONE:           20,

    SRC_OVER:       0,
    SRC_IN:         21,
    SRC_OUT:        22,
    SRC_ATOP:       23,
    DST_OVER:       24,
    DST_IN:         25,
    DST_OUT:        26,
    DST_ATOP:       27,
    ERASE:          26,
    SUBTRACT:       28,
};

/**
 * Various webgl draw modes. These can be used to specify which GL drawMode to use
 * under certain situations and renderers.
 *
 * @memberof PIXI
 * @static
 * @name DRAW_MODES
 * @enum {number}
 * @property {number} POINTS
 * @property {number} LINES
 * @property {number} LINE_LOOP
 * @property {number} LINE_STRIP
 * @property {number} TRIANGLES
 * @property {number} TRIANGLE_STRIP
 * @property {number} TRIANGLE_FAN
 */
var DRAW_MODES = {
    POINTS:         0,
    LINES:          1,
    LINE_LOOP:      2,
    LINE_STRIP:     3,
    TRIANGLES:      4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN:   6,
};

/**
 * Various GL texture/resources formats.
 *
 * @memberof PIXI
 * @static
 * @name FORMATS
 * @enum {number}
 * @property {number} RGBA=6408
 * @property {number} RGB=6407
 * @property {number} ALPHA=6406
 * @property {number} LUMINANCE=6409
 * @property {number} LUMINANCE_ALPHA=6410
 * @property {number} DEPTH_COMPONENT=6402
 * @property {number} DEPTH_STENCIL=34041
 */
var FORMATS = {
    RGBA:             6408,
    RGB:              6407,
    ALPHA:            6406,
    LUMINANCE:        6409,
    LUMINANCE_ALPHA:  6410,
    DEPTH_COMPONENT:  6402,
    DEPTH_STENCIL:    34041,
};

/**
 * Various GL target types.
 *
 * @memberof PIXI
 * @static
 * @name TARGETS
 * @enum {number}
 * @property {number} TEXTURE_2D=3553
 * @property {number} TEXTURE_CUBE_MAP=34067
 * @property {number} TEXTURE_2D_ARRAY=35866
 * @property {number} TEXTURE_CUBE_MAP_POSITIVE_X=34069
 * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_X=34070
 * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Y=34071
 * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Y=34072
 * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Z=34073
 * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Z=34074
 */
var TARGETS = {
    TEXTURE_2D: 3553,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
};

/**
 * Various GL data format types.
 *
 * @memberof PIXI
 * @static
 * @name TYPES
 * @enum {number}
 * @property {number} UNSIGNED_BYTE=5121
 * @property {number} UNSIGNED_SHORT=5123
 * @property {number} UNSIGNED_SHORT_5_6_5=33635
 * @property {number} UNSIGNED_SHORT_4_4_4_4=32819
 * @property {number} UNSIGNED_SHORT_5_5_5_1=32820
 * @property {number} FLOAT=5126
 * @property {number} HALF_FLOAT=36193
 */
var TYPES = {
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_SHORT_5_6_5: 33635,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    FLOAT: 5126,
    HALF_FLOAT: 36193,
};

/**
 * The scale modes that are supported by pixi.
 *
 * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
 * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
 *
 * @memberof PIXI
 * @static
 * @name SCALE_MODES
 * @enum {number}
 * @property {number} LINEAR Smooth scaling
 * @property {number} NEAREST Pixelating scaling
 */
var SCALE_MODES = {
    LINEAR:     1,
    NEAREST:    0,
};

/**
 * The wrap modes that are supported by pixi.
 *
 * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.
 * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
 * If the texture is non power of two then clamp will be used regardless as WebGL can
 * only use REPEAT if the texture is po2.
 *
 * This property only affects WebGL.
 *
 * @name WRAP_MODES
 * @memberof PIXI
 * @static
 * @enum {number}
 * @property {number} CLAMP - The textures uvs are clamped
 * @property {number} REPEAT - The texture uvs tile and repeat
 * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
 */
var WRAP_MODES = {
    CLAMP:           33071,
    REPEAT:          10497,
    MIRRORED_REPEAT: 33648,
};

/**
 * Mipmap filtering modes that are supported by pixi.
 *
 * The {@link PIXI.settings.MIPMAP_TEXTURES} affects default texture filtering.
 * Mipmaps are generated for a baseTexture if its `mipmap` field is `ON`,
 * or its `POW2` and texture dimensions are powers of 2.
 * Due to platform restriction, `ON` option will work like `POW2` for webgl-1.
 *
 * This property only affects WebGL.
 *
 * @name MIPMAP_MODES
 * @memberof PIXI
 * @static
 * @enum {number}
 * @property {number} OFF - No mipmaps
 * @property {number} POW2 - Generate mipmaps if texture dimensions are pow2
 * @property {number} ON - Always generate mipmaps
 */
var MIPMAP_MODES = {
    OFF: 0,
    POW2: 1,
    ON: 2,
};

/**
 * The gc modes that are supported by pixi.
 *
 * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
 * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
 * used for a specified period of time they will be removed from the GPU. They will of course
 * be uploaded again when they are required. This is a silent behind the scenes process that
 * should ensure that the GPU does not  get filled up.
 *
 * Handy for mobile devices!
 * This property only affects WebGL.
 *
 * @name GC_MODES
 * @enum {number}
 * @static
 * @memberof PIXI
 * @property {number} AUTO - Garbage collection will happen periodically automatically
 * @property {number} MANUAL - Garbage collection will need to be called manually
 */
var GC_MODES = {
    AUTO:           0,
    MANUAL:         1,
};

/**
 * Constants that specify float precision in shaders.
 *
 * @name PRECISION
 * @memberof PIXI
 * @static
 * @enum {string}
 * @constant
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
var PRECISION = {
    LOW: 'lowp',
    MEDIUM: 'mediump',
    HIGH: 'highp',
};


//# sourceMappingURL=constants.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/core.es.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/core/lib/core.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractBatchRenderer": () => (/* binding */ AbstractBatchRenderer),
/* harmony export */   "AbstractRenderer": () => (/* binding */ AbstractRenderer),
/* harmony export */   "Attribute": () => (/* binding */ Attribute),
/* harmony export */   "BaseRenderTexture": () => (/* binding */ BaseRenderTexture),
/* harmony export */   "BaseTexture": () => (/* binding */ BaseTexture),
/* harmony export */   "BatchDrawCall": () => (/* binding */ BatchDrawCall),
/* harmony export */   "BatchGeometry": () => (/* binding */ BatchGeometry),
/* harmony export */   "BatchPluginFactory": () => (/* binding */ BatchPluginFactory),
/* harmony export */   "BatchRenderer": () => (/* binding */ BatchRenderer),
/* harmony export */   "BatchShaderGenerator": () => (/* binding */ BatchShaderGenerator),
/* harmony export */   "Buffer": () => (/* binding */ Buffer),
/* harmony export */   "CubeTexture": () => (/* binding */ CubeTexture),
/* harmony export */   "Filter": () => (/* binding */ Filter),
/* harmony export */   "Framebuffer": () => (/* binding */ Framebuffer),
/* harmony export */   "GLProgram": () => (/* binding */ GLProgram),
/* harmony export */   "GLTexture": () => (/* binding */ BaseTexture),
/* harmony export */   "Geometry": () => (/* binding */ Geometry),
/* harmony export */   "ObjectRenderer": () => (/* binding */ ObjectRenderer),
/* harmony export */   "Program": () => (/* binding */ Program),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "QuadUv": () => (/* binding */ QuadUv),
/* harmony export */   "RenderTexture": () => (/* binding */ RenderTexture),
/* harmony export */   "RenderTexturePool": () => (/* binding */ RenderTexturePool),
/* harmony export */   "Renderer": () => (/* binding */ Renderer),
/* harmony export */   "Shader": () => (/* binding */ Shader),
/* harmony export */   "SpriteMaskFilter": () => (/* binding */ SpriteMaskFilter),
/* harmony export */   "State": () => (/* binding */ State),
/* harmony export */   "System": () => (/* binding */ System),
/* harmony export */   "Texture": () => (/* binding */ Texture),
/* harmony export */   "TextureMatrix": () => (/* binding */ TextureMatrix),
/* harmony export */   "TextureUvs": () => (/* binding */ TextureUvs),
/* harmony export */   "UniformGroup": () => (/* binding */ UniformGroup),
/* harmony export */   "ViewableBuffer": () => (/* binding */ ViewableBuffer),
/* harmony export */   "autoDetectRenderer": () => (/* binding */ autoDetectRenderer),
/* harmony export */   "checkMaxIfStatementsInShader": () => (/* binding */ checkMaxIfStatementsInShader),
/* harmony export */   "defaultFilterVertex": () => (/* binding */ defaultFilter),
/* harmony export */   "defaultVertex": () => (/* binding */ _default),
/* harmony export */   "resources": () => (/* binding */ index),
/* harmony export */   "systems": () => (/* binding */ systems)
/* harmony export */ });
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/runner.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/constants.es.js");
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/ticker.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/*!
 * @pixi/core - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */








/**
 * Base resource class for textures that manages validation and uploading, depending on its type.
 *
 * Uploading of a base texture to the GPU is required.
 *
 * @class
 * @memberof PIXI.resources
 */
var Resource = function Resource(width, height)
{
    if ( width === void 0 ) width = 0;
    if ( height === void 0 ) height = 0;

    /**
     * Internal width of the resource
     * @member {number}
     * @protected
     */
    this._width = width;

    /**
     * Internal height of the resource
     * @member {number}
     * @protected
     */
    this._height = height;

    /**
     * If resource has been destroyed
     * @member {boolean}
     * @readonly
     * @default false
     */
    this.destroyed = false;

    /**
     * `true` if resource is created by BaseTexture
     * useful for doing cleanup with BaseTexture destroy
     * and not cleaning up resources that were created
     * externally.
     * @member {boolean}
     * @protected
     */
    this.internal = false;

    /**
     * Mini-runner for handling resize events
     *
     * @member {Runner}
     * @private
     */
    this.onResize = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('setRealSize', 2);

    /**
     * Mini-runner for handling update events
     *
     * @member {Runner}
     * @private
     */
    this.onUpdate = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('update');

    /**
     * Handle internal errors, such as loading errors
     *
     * @member {Runner}
     * @private
     */
    this.onError = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('onError', 1);
};

var prototypeAccessors = { valid: { configurable: true },width: { configurable: true },height: { configurable: true } };

/**
 * Bind to a parent BaseTexture
 *
 * @param {PIXI.BaseTexture} baseTexture - Parent texture
 */
Resource.prototype.bind = function bind (baseTexture)
{
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);

    // Call a resize immediate if we already
    // have the width and height of the resource
    if (this._width || this._height)
    {
        this.onResize.run(this._width, this._height);
    }
};

/**
 * Unbind to a parent BaseTexture
 *
 * @param {PIXI.BaseTexture} baseTexture - Parent texture
 */
Resource.prototype.unbind = function unbind (baseTexture)
{
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
};

/**
 * Trigger a resize event
 */
Resource.prototype.resize = function resize (width, height)
{
    if (width !== this._width || height !== this._height)
    {
        this._width = width;
        this._height = height;
        this.onResize.run(width, height);
    }
};

/**
 * Has been validated
 * @readonly
 * @member {boolean}
 */
prototypeAccessors.valid.get = function ()
{
    return !!this._width && !!this._height;
};

/**
 * Has been updated trigger event
 */
Resource.prototype.update = function update ()
{
    if (!this.destroyed)
    {
        this.onUpdate.run();
    }
};

/**
 * This can be overridden to start preloading a resource
 * or do any other prepare step.
 * @protected
 * @return {Promise<void>} Handle the validate event
 */
Resource.prototype.load = function load ()
{
    return Promise.resolve();
};

/**
 * The width of the resource.
 *
 * @member {number}
 * @readonly
 */
prototypeAccessors.width.get = function ()
{
    return this._width;
};

/**
 * The height of the resource.
 *
 * @member {number}
 * @readonly
 */
prototypeAccessors.height.get = function ()
{
    return this._height;
};

/**
 * Uploads the texture or returns false if it cant for some reason. Override this.
 *
 * @param {PIXI.Renderer} renderer - yeah, renderer!
 * @param {PIXI.BaseTexture} baseTexture - the texture
 * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
 * @returns {boolean} true is success
 */
Resource.prototype.upload = function upload (renderer, baseTexture, glTexture) // eslint-disable-line no-unused-vars
{
    return false;
};

/**
 * Set the style, optional to override
 *
 * @param {PIXI.Renderer} renderer - yeah, renderer!
 * @param {PIXI.BaseTexture} baseTexture - the texture
 * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
 * @returns {boolean} `true` is success
 */
Resource.prototype.style = function style (renderer, baseTexture, glTexture) // eslint-disable-line no-unused-vars
{
    return false;
};

/**
 * Clean up anything, this happens when destroying is ready.
 *
 * @protected
 */
Resource.prototype.dispose = function dispose ()
{
    // override
};

/**
 * Call when destroying resource, unbind any BaseTexture object
 * before calling this method, as reference counts are maintained
 * internally.
 */
Resource.prototype.destroy = function destroy ()
{
    if (!this.destroyed)
    {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
    }
};

Object.defineProperties( Resource.prototype, prototypeAccessors );

/**
 * Base for all the image/canvas resources
 * @class
 * @extends PIXI.resources.Resource
 * @memberof PIXI.resources
 */
var BaseImageResource = /*@__PURE__*/(function (Resource) {
    function BaseImageResource(source)
    {
        var width = source.naturalWidth || source.videoWidth || source.width;
        var height = source.naturalHeight || source.videoHeight || source.height;

        Resource.call(this, width, height);

        /**
         * The source element
         * @member {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement}
         * @readonly
         */
        this.source = source;
    }

    if ( Resource ) BaseImageResource.__proto__ = Resource;
    BaseImageResource.prototype = Object.create( Resource && Resource.prototype );
    BaseImageResource.prototype.constructor = BaseImageResource;

    /**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */
    BaseImageResource.crossOrigin = function crossOrigin (element, url, crossorigin)
    {
        if (crossorigin === undefined && url.indexOf('data:') !== 0)
        {
            element.crossOrigin = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.determineCrossOrigin)(url);
        }
        else if (crossorigin !== false)
        {
            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }
    };

    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */
    BaseImageResource.prototype.upload = function upload (renderer, baseTexture, glTexture, source)
    {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;

        source = source || this.source;

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);

        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height)
        {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else
        {
            glTexture.width = width;
            glTexture.height = height;

            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }

        return true;
    };

    /**
     * Checks if source width/height was changed, resize can cause extra baseTexture update.
     * Triggers one update in any case.
     */
    BaseImageResource.prototype.update = function update ()
    {
        if (this.destroyed)
        {
            return;
        }

        var width = this.source.naturalWidth || this.source.videoWidth || this.source.width;
        var height = this.source.naturalHeight || this.source.videoHeight || this.source.height;

        this.resize(width, height);

        Resource.prototype.update.call(this);
    };

    /**
     * Destroy this BaseImageResource
     * @override
     * @param {PIXI.BaseTexture} [fromTexture] Optional base texture
     * @return {boolean} Destroy was successful
     */
    BaseImageResource.prototype.dispose = function dispose ()
    {
        this.source = null;
    };

    return BaseImageResource;
}(Resource));

/**
 * Resource type for HTMLImageElement.
 * @class
 * @extends PIXI.resources.BaseImageResource
 * @memberof PIXI.resources
 */
var ImageResource = /*@__PURE__*/(function (BaseImageResource) {
    function ImageResource(source, options)
    {
        options = options || {};

        if (!(source instanceof HTMLImageElement))
        {
            var imageElement = new Image();

            BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);

            imageElement.src = source;
            source = imageElement;
        }

        BaseImageResource.call(this, source);

        // FireFox 68, and possibly other versions, seems like setting the HTMLImageElement#width and #height
        // to non-zero values before its loading completes if images are in a cache.
        // Because of this, need to set the `_width` and the `_height` to zero to avoid uploading incomplete images.
        // Please refer to the issue #5968 (https://github.com/pixijs/pixi.js/issues/5968).
        if (!source.complete && !!this._width && !!this._height)
        {
            this._width = 0;
            this._height = 0;
        }

        /**
         * URL of the image source
         * @member {string}
         */
        this.url = source.src;

        /**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */
        this._process = null;

        /**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */
        this.preserveBitmap = false;

        /**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */
        this.createBitmap = (options.createBitmap !== undefined
            ? options.createBitmap : _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap;

        /**
         * Controls texture premultiplyAlpha field
         * Copies from options
         * @member {boolean|null}
         * @readonly
         */
        this.premultiplyAlpha = options.premultiplyAlpha !== false;

        /**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */
        this.bitmap = null;

        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;

        if (options.autoLoad !== false)
        {
            this.load();
        }
    }

    if ( BaseImageResource ) ImageResource.__proto__ = BaseImageResource;
    ImageResource.prototype = Object.create( BaseImageResource && BaseImageResource.prototype );
    ImageResource.prototype.constructor = ImageResource;

    /**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap=true] whether process image into bitmap
     * @returns {Promise<void>}
     */
    ImageResource.prototype.load = function load (createBitmap)
    {
        var this$1 = this;

        if (createBitmap !== undefined)
        {
            this.createBitmap = createBitmap;
        }

        if (this._load)
        {
            return this._load;
        }

        this._load = new Promise(function (resolve) {
            this$1.url = this$1.source.src;
            var ref = this$1;
            var source = ref.source;

            var completed = function () {
                if (this$1.destroyed)
                {
                    return;
                }
                source.onload = null;
                source.onerror = null;

                this$1.resize(source.width, source.height);
                this$1._load = null;

                if (this$1.createBitmap)
                {
                    resolve(this$1.process());
                }
                else
                {
                    resolve(this$1);
                }
            };

            if (source.complete && source.src)
            {
                completed();
            }
            else
            {
                source.onload = completed;
                source.onerror = function (event) { return this$1.onError.run(event); };
            }
        });

        return this._load;
    };

    /**
     * Called when we need to convert image into BitmapImage.
     * Can be called multiple times, real promise is cached inside.
     *
     * @returns {Promise<void>} cached promise to fill that bitmap
     */
    ImageResource.prototype.process = function process ()
    {
        var this$1 = this;

        if (this._process !== null)
        {
            return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap)
        {
            return Promise.resolve(this);
        }

        this._process = window.createImageBitmap(this.source,
            0, 0, this.source.width, this.source.height,
            {
                premultiplyAlpha: this.premultiplyAlpha ? 'premultiply' : 'none',
            })
            .then(function (bitmap) {
                if (this$1.destroyed)
                {
                    return Promise.reject();
                }
                this$1.bitmap = bitmap;
                this$1.update();
                this$1._process = null;

                return Promise.resolve(this$1);
            });

        return this._process;
    };

    /**
     * Upload the image resource to GPU.
     *
     * @param {PIXI.Renderer} renderer - Renderer to upload to
     * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
     * @param {PIXI.GLTexture} glTexture - GLTexture to use
     * @returns {boolean} true is success
     */
    ImageResource.prototype.upload = function upload (renderer, baseTexture, glTexture)
    {
        baseTexture.premultiplyAlpha = this.premultiplyAlpha;

        if (!this.createBitmap)
        {
            return BaseImageResource.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap)
        {
            // yeah, ignore the output
            this.process();
            if (!this.bitmap)
            {
                return false;
            }
        }

        BaseImageResource.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);

        if (!this.preserveBitmap)
        {
            // checks if there are other renderers that possibly need this bitmap

            var flag = true;

            for (var key in baseTexture._glTextures)
            {
                var otherTex = baseTexture._glTextures[key];

                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId)
                {
                    flag = false;
                    break;
                }
            }

            if (flag)
            {
                if (this.bitmap.close)
                {
                    this.bitmap.close();
                }

                this.bitmap = null;
            }
        }

        return true;
    };

    /**
     * Destroys this texture
     * @override
     */
    ImageResource.prototype.dispose = function dispose ()
    {
        this.source.onload = null;
        this.source.onerror = null;

        BaseImageResource.prototype.dispose.call(this);

        if (this.bitmap)
        {
            this.bitmap.close();
            this.bitmap = null;
        }
        this._process = null;
        this._load = null;
    };

    return ImageResource;
}(BaseImageResource));

/**
 * Collection of installed resource types, class must extend {@link PIXI.resources.Resource}.
 * @example
 * class CustomResource extends PIXI.resources.Resource {
 *   // MUST have source, options constructor signature
 *   // for auto-detected resources to be created.
 *   constructor(source, options) {
 *     super();
 *   }
 *   upload(renderer, baseTexture, glTexture) {
 *     // upload with GL
 *     return true;
 *   }
 *   // used to auto-detect resource
 *   static test(source, extension) {
 *     return extension === 'xyz'|| source instanceof SomeClass;
 *   }
 * }
 * // Install the new resource type
 * PIXI.resources.INSTALLED.push(CustomResource);
 *
 * @name PIXI.resources.INSTALLED
 * @type {Array<*>}
 * @static
 * @readonly
 */
var INSTALLED = [];

/**
 * Create a resource element from a single source element. This
 * auto-detects which type of resource to create. All resources that
 * are auto-detectable must have a static `test` method and a constructor
 * with the arguments `(source, options?)`. Currently, the supported
 * resources for auto-detection include:
 *  - {@link PIXI.resources.ImageResource}
 *  - {@link PIXI.resources.CanvasResource}
 *  - {@link PIXI.resources.VideoResource}
 *  - {@link PIXI.resources.SVGResource}
 *  - {@link PIXI.resources.BufferResource}
 * @static
 * @function PIXI.resources.autoDetectResource
 * @param {string|*} source - Resource source, this can be the URL to the resource,
 *        a typed-array (for BufferResource), HTMLVideoElement, SVG data-uri
 *        or any other resource that can be auto-detected. If not resource is
 *        detected, it's assumed to be an ImageResource.
 * @param {object} [options] - Pass-through options to use for Resource
 * @param {number} [options.width] - Width of BufferResource or SVG rasterization
 * @param {number} [options.height] - Height of BufferResource or SVG rasterization
 * @param {boolean} [options.autoLoad=true] - Image, SVG and Video flag to start loading
 * @param {number} [options.scale=1] - SVG source scale. Overridden by width, height
 * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - Image option to create Bitmap object
 * @param {boolean} [options.crossorigin=true] - Image and Video option to set crossOrigin
 * @param {boolean} [options.autoPlay=true] - Video option to start playing video immediately
 * @param {number} [options.updateFPS=0] - Video option to update how many times a second the
 *        texture should be updated from the video. Leave at 0 to update at every render
 * @return {PIXI.resources.Resource} The created resource.
 */
function autoDetectResource(source, options)
{
    if (!source)
    {
        return null;
    }

    var extension = '';

    if (typeof source === 'string')
    {
        // search for file extension: period, 3-4 chars, then ?, # or EOL
        var result = (/\.(\w{3,4})(?:$|\?|#)/i).exec(source);

        if (result)
        {
            extension = result[1].toLowerCase();
        }
    }

    for (var i = INSTALLED.length - 1; i >= 0; --i)
    {
        var ResourcePlugin = INSTALLED[i];

        if (ResourcePlugin.test && ResourcePlugin.test(source, extension))
        {
            return new ResourcePlugin(source, options);
        }
    }

    // When in doubt: probably an image
    // might be appropriate to throw an error or return null
    return new ImageResource(source, options);
}

/**
 * @interface SharedArrayBuffer
 */

/**
 * Buffer resource with data of typed array.
 * @class
 * @extends PIXI.resources.Resource
 * @memberof PIXI.resources
 */
var BufferResource = /*@__PURE__*/(function (Resource) {
    function BufferResource(source, options)
    {
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;

        if (!width || !height)
        {
            throw new Error('BufferResource width or height invalid');
        }

        Resource.call(this, width, height);

        /**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */
        this.data = source;
    }

    if ( Resource ) BufferResource.__proto__ = Resource;
    BufferResource.prototype = Object.create( Resource && Resource.prototype );
    BufferResource.prototype.constructor = BufferResource;

    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture glTexture
     * @returns {boolean} true is success
     */
    BufferResource.prototype.upload = function upload (renderer, baseTexture, glTexture)
    {
        var gl = renderer.gl;

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);

        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height)
        {
            gl.texSubImage2D(
                baseTexture.target,
                0,
                0,
                0,
                baseTexture.width,
                baseTexture.height,
                baseTexture.format,
                baseTexture.type,
                this.data
            );
        }
        else
        {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;

            gl.texImage2D(
                baseTexture.target,
                0,
                glTexture.internalFormat,
                baseTexture.width,
                baseTexture.height,
                0,
                baseTexture.format,
                glTexture.type,
                this.data
            );
        }

        return true;
    };

    /**
     * Destroy and don't use after this
     * @override
     */
    BufferResource.prototype.dispose = function dispose ()
    {
        this.data = null;
    };

    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */
    BufferResource.test = function test (source)
    {
        return source instanceof Float32Array
            || source instanceof Uint8Array
            || source instanceof Uint32Array;
    };

    return BufferResource;
}(Resource));

var defaultBufferOptions = {
    scaleMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.SCALE_MODES.NEAREST,
    format: _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.FORMATS.RGBA,
    premultiplyAlpha: false,
};

/**
 * A Texture stores the information that represents an image.
 * All textures have a base texture, which contains information about the source.
 * Therefore you can have many textures all using a single BaseTexture
 *
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI
 * @param {PIXI.resources.Resource|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} [resource=null]
 *        The current resource to use, for things that aren't Resource objects, will be converted
 *        into a Resource.
 * @param {Object} [options] - Collection of options
 * @param {PIXI.MIPMAP_MODES} [options.mipmap=PIXI.settings.MIPMAP_TEXTURES] - If mipmapping is enabled for texture
 * @param {number} [options.anisotropicLevel=PIXI.settings.ANISOTROPIC_LEVEL] - Anisotropic filtering level of texture
 * @param {PIXI.WRAP_MODES} [options.wrapMode=PIXI.settings.WRAP_MODE] - Wrap mode for textures
 * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - Default scale mode, linear, nearest
 * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type
 * @param {PIXI.TYPES} [options.type=PIXI.TYPES.UNSIGNED_BYTE] - GL data type
 * @param {PIXI.TARGETS} [options.target=PIXI.TARGETS.TEXTURE_2D] - GL texture target
 * @param {boolean} [options.premultiplyAlpha=true] - Pre multiply the image alpha
 * @param {number} [options.width=0] - Width of the texture
 * @param {number} [options.height=0] - Height of the texture
 * @param {number} [options.resolution] - Resolution of the base texture
 * @param {object} [options.resourceOptions] - Optional resource options,
 *        see {@link PIXI.resources.autoDetectResource autoDetectResource}
 */
var BaseTexture = /*@__PURE__*/(function (EventEmitter) {
    function BaseTexture(resource, options)
    {
        if ( resource === void 0 ) resource = null;
        if ( options === void 0 ) options = null;

        EventEmitter.call(this);

        options = options || {};

        var premultiplyAlpha = options.premultiplyAlpha;
        var mipmap = options.mipmap;
        var anisotropicLevel = options.anisotropicLevel;
        var scaleMode = options.scaleMode;
        var width = options.width;
        var height = options.height;
        var wrapMode = options.wrapMode;
        var format = options.format;
        var type = options.type;
        var target = options.target;
        var resolution = options.resolution;
        var resourceOptions = options.resourceOptions;

        // Convert the resource to a Resource object
        if (resource && !(resource instanceof Resource))
        {
            resource = autoDetectResource(resource, resourceOptions);
            resource.internal = true;
        }

        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.width = width || 0;

        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.height = height || 0;

        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */
        this.resolution = resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.RESOLUTION;

        /**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        this.mipmap = mipmap !== undefined ? mipmap : _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.MIPMAP_TEXTURES;

        /**
         * Anisotropic filtering level of texture
         *
         * @member {number}
         * @default PIXI.settings.ANISOTROPIC_LEVEL
         */
        this.anisotropicLevel = anisotropicLevel !== undefined ? anisotropicLevel : _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.ANISOTROPIC_LEVEL;

        /**
         * How the texture wraps
         * @member {number}
         */
        this.wrapMode = wrapMode || _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.WRAP_MODE;

        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.SCALE_MODE;

        /**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */
        this.format = format || _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.FORMATS.RGBA;

        /**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */
        this.type = type || _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.UNSIGNED_BYTE;

        /**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */
        this.target = target || _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TARGETS.TEXTURE_2D;

        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {boolean}
         * @default true
         */
        this.premultiplyAlpha = premultiplyAlpha !== false;

        /**
         * Global unique identifier for this BaseTexture
         *
         * @member {string}
         * @protected
         */
        this.uid = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.uid)();

        /**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */
        this.touched = 0;

        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */
        this.isPowerOfTwo = false;
        this._refreshPOT();

        /**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */
        this._glTextures = {};

        /**
         * Used by TextureSystem to only update texture to the GPU when needed.
         * Please call `update()` to increment it.
         *
         * @readonly
         * @member {number}
         */
        this.dirtyId = 0;

        /**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyStyleId = 0;

        /**
         * Currently default cache ID.
         *
         * @member {string}
         */
        this.cacheId = null;

        /**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */
        this.valid = width > 0 && height > 0;

        /**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */
        this.textureCacheIds = [];

        /**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */
        this.destroyed = false;

        /**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */
        this.resource = null;

        /**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */
        this._batchEnabled = 0;

        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */

        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         * @param {ErrorEvent} event - Load error event.
         */

        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */

        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */

        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */

        // Set the resource
        this.setResource(resource);
    }

    if ( EventEmitter ) BaseTexture.__proto__ = EventEmitter;
    BaseTexture.prototype = Object.create( EventEmitter && EventEmitter.prototype );
    BaseTexture.prototype.constructor = BaseTexture;

    var prototypeAccessors = { realWidth: { configurable: true },realHeight: { configurable: true } };

    /**
     * Pixel width of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    prototypeAccessors.realWidth.get = function ()
    {
        return Math.ceil((this.width * this.resolution) - 1e-4);
    };

    /**
     * Pixel height of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    prototypeAccessors.realHeight.get = function ()
    {
        return Math.ceil((this.height * this.resolution) - 1e-4);
    };

    /**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {PIXI.BaseTexture} this
     */
    BaseTexture.prototype.setStyle = function setStyle (scaleMode, mipmap)
    {
        var dirty;

        if (scaleMode !== undefined && scaleMode !== this.scaleMode)
        {
            this.scaleMode = scaleMode;
            dirty = true;
        }

        if (mipmap !== undefined && mipmap !== this.mipmap)
        {
            this.mipmap = mipmap;
            dirty = true;
        }

        if (dirty)
        {
            this.dirtyStyleId++;
        }

        return this;
    };

    /**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width Visual width
     * @param {number} height Visual height
     * @param {number} [resolution] Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */
    BaseTexture.prototype.setSize = function setSize (width, height, resolution)
    {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();

        return this;
    };

    /**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth Full rendered width
     * @param {number} realHeight Full rendered height
     * @param {number} [resolution] Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */
    BaseTexture.prototype.setRealSize = function setRealSize (realWidth, realHeight, resolution)
    {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();

        return this;
    };

    /**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */
    BaseTexture.prototype._refreshPOT = function _refreshPOT ()
    {
        this.isPowerOfTwo = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.isPow2)(this.realWidth) && (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.isPow2)(this.realHeight);
    };

    /**
     * Changes resolution
     *
     * @param {number} [resolution] res
     * @returns {PIXI.BaseTexture} this
     */
    BaseTexture.prototype.setResolution = function setResolution (resolution)
    {
        var oldResolution = this.resolution;

        if (oldResolution === resolution)
        {
            return this;
        }

        this.resolution = resolution;

        if (this.valid)
        {
            this.width = this.width * oldResolution / resolution;
            this.height = this.height * oldResolution / resolution;
            this.emit('update', this);
        }

        this._refreshPOT();

        return this;
    };

    /**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {PIXI.BaseTexture} this
     */
    BaseTexture.prototype.setResource = function setResource (resource)
    {
        if (this.resource === resource)
        {
            return this;
        }

        if (this.resource)
        {
            throw new Error('Resource can be set only once');
        }

        resource.bind(this);

        this.resource = resource;

        return this;
    };

    /**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */
    BaseTexture.prototype.update = function update ()
    {
        if (!this.valid)
        {
            if (this.width > 0 && this.height > 0)
            {
                this.valid = true;
                this.emit('loaded', this);
                this.emit('update', this);
            }
        }
        else
        {
            this.dirtyId++;
            this.dirtyStyleId++;
            this.emit('update', this);
        }
    };

    /**
     * Handle errors with resources.
     * @private
     * @param {ErrorEvent} event - Error event emitted.
     */
    BaseTexture.prototype.onError = function onError (event)
    {
        this.emit('error', this, event);
    };

    /**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */
    BaseTexture.prototype.destroy = function destroy ()
    {
        // remove and destroy the resource
        if (this.resource)
        {
            this.resource.unbind(this);
            // only destroy resourced created internally
            if (this.resource.internal)
            {
                this.resource.destroy();
            }
            this.resource = null;
        }

        if (this.cacheId)
        {
            delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[this.cacheId];
            delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[this.cacheId];

            this.cacheId = null;
        }

        // finally let the WebGL renderer know..
        this.dispose();

        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;

        this.destroyed = true;
    };

    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    BaseTexture.prototype.dispose = function dispose ()
    {
        this.emit('dispose', this);
    };

    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @returns {PIXI.BaseTexture} The new base texture.
     */
    BaseTexture.from = function from (source, options)
    {
        var cacheId = null;

        if (typeof source === 'string')
        {
            cacheId = source;
        }
        else
        {
            if (!source._pixiId)
            {
                source._pixiId = "pixiid_" + ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.uid)());
            }

            cacheId = source._pixiId;
        }

        var baseTexture = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[cacheId];

        if (!baseTexture)
        {
            baseTexture = new BaseTexture(source, options);
            baseTexture.cacheId = cacheId;
            BaseTexture.addToCache(baseTexture, cacheId);
        }

        return baseTexture;
    };

    /**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */
    BaseTexture.fromBuffer = function fromBuffer (buffer, width, height, options)
    {
        buffer = buffer || new Float32Array(width * height * 4);

        var resource = new BufferResource(buffer, { width: width, height: height });
        var type = buffer instanceof Float32Array ? _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.FLOAT : _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.UNSIGNED_BYTE;

        return new BaseTexture(resource, Object.assign(defaultBufferOptions, options || { width: width, height: height, type: type }));
    };

    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */
    BaseTexture.addToCache = function addToCache (baseTexture, id)
    {
        if (id)
        {
            if (baseTexture.textureCacheIds.indexOf(id) === -1)
            {
                baseTexture.textureCacheIds.push(id);
            }

            if (_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[id])
            {
                // eslint-disable-next-line no-console
                console.warn(("BaseTexture added to the cache with an id [" + id + "] that already had an entry"));
            }

            _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[id] = baseTexture;
        }
    };

    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */
    BaseTexture.removeFromCache = function removeFromCache (baseTexture)
    {
        if (typeof baseTexture === 'string')
        {
            var baseTextureFromCache = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[baseTexture];

            if (baseTextureFromCache)
            {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);

                if (index > -1)
                {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }

                delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[baseTexture];

                return baseTextureFromCache;
            }
        }
        else if (baseTexture && baseTexture.textureCacheIds)
        {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i)
            {
                delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }

            baseTexture.textureCacheIds.length = 0;

            return baseTexture;
        }

        return null;
    };

    Object.defineProperties( BaseTexture.prototype, prototypeAccessors );

    return BaseTexture;
}(_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter));

/**
 * Global number of the texture batch, used by multi-texture renderers
 *
 * @static
 * @member {number}
 */
BaseTexture._globalBatch = 0;

/**
 * A resource that contains a number of sources.
 *
 * @class
 * @extends PIXI.resources.Resource
 * @memberof PIXI.resources
 * @param {number|Array<*>} source - Number of items in array or the collection
 *        of image URLs to use. Can also be resources, image elements, canvas, etc.
 * @param {object} [options] Options to apply to {@link PIXI.resources.autoDetectResource}
 * @param {number} [options.width] - Width of the resource
 * @param {number} [options.height] - Height of the resource
 */
var ArrayResource = /*@__PURE__*/(function (Resource) {
    function ArrayResource(source, options)
    {
        options = options || {};

        var urls;
        var length = source;

        if (Array.isArray(source))
        {
            urls = source;
            length = source.length;
        }

        Resource.call(this, options.width, options.height);

        /**
         * Collection of resources.
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */
        this.items = [];

        /**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */
        this.itemDirtyIds = [];

        for (var i = 0; i < length; i++)
        {
            var partTexture = new BaseTexture();

            this.items.push(partTexture);
            this.itemDirtyIds.push(-1);
        }

        /**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */
        this.length = length;

        /**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */
        this._load = null;

        if (urls)
        {
            for (var i$1 = 0; i$1 < length; i$1++)
            {
                this.addResourceAt(autoDetectResource(urls[i$1], options), i$1);
            }
        }
    }

    if ( Resource ) ArrayResource.__proto__ = Resource;
    ArrayResource.prototype = Object.create( Resource && Resource.prototype );
    ArrayResource.prototype.constructor = ArrayResource;

    /**
     * Destroy this BaseImageResource
     * @override
     */
    ArrayResource.prototype.dispose = function dispose ()
    {
        for (var i = 0, len = this.length; i < len; i++)
        {
            this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
    };

    /**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */
    ArrayResource.prototype.addResourceAt = function addResourceAt (resource, index)
    {
        var baseTexture = this.items[index];

        if (!baseTexture)
        {
            throw new Error(("Index " + index + " is out of bounds"));
        }

        // Inherit the first resource dimensions
        if (resource.valid && !this.valid)
        {
            this.resize(resource.width, resource.height);
        }

        this.items[index].setResource(resource);

        return this;
    };

    /**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    ArrayResource.prototype.bind = function bind (baseTexture)
    {
        Resource.prototype.bind.call(this, baseTexture);

        baseTexture.target = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TARGETS.TEXTURE_2D_ARRAY;

        for (var i = 0; i < this.length; i++)
        {
            this.items[i].on('update', baseTexture.update, baseTexture);
        }
    };

    /**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    ArrayResource.prototype.unbind = function unbind (baseTexture)
    {
        Resource.prototype.unbind.call(this, baseTexture);

        for (var i = 0; i < this.length; i++)
        {
            this.items[i].off('update', baseTexture.update, baseTexture);
        }
    };

    /**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */
    ArrayResource.prototype.load = function load ()
    {
        var this$1 = this;

        if (this._load)
        {
            return this._load;
        }

        var resources = this.items.map(function (item) { return item.resource; });

        // TODO: also implement load part-by-part strategy
        var promises = resources.map(function (item) { return item.load(); });

        this._load = Promise.all(promises)
            .then(function () {
                var ref = resources[0];
                var width = ref.width;
                var height = ref.height;

                this$1.resize(width, height);

                return Promise.resolve(this$1);
            }
            );

        return this._load;
    };

    /**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */
    ArrayResource.prototype.upload = function upload (renderer, texture, glTexture)
    {
        var ref = this;
        var length = ref.length;
        var itemDirtyIds = ref.itemDirtyIds;
        var items = ref.items;
        var gl = renderer.gl;

        if (glTexture.dirtyId < 0)
        {
            gl.texImage3D(
                gl.TEXTURE_2D_ARRAY,
                0,
                texture.format,
                this._width,
                this._height,
                length,
                0,
                texture.format,
                texture.type,
                null
            );
        }

        for (var i = 0; i < length; i++)
        {
            var item = items[i];

            if (itemDirtyIds[i] < item.dirtyId)
            {
                itemDirtyIds[i] = item.dirtyId;
                if (item.valid)
                {
                    gl.texSubImage3D(
                        gl.TEXTURE_2D_ARRAY,
                        0,
                        0, // xoffset
                        0, // yoffset
                        i, // zoffset
                        item.resource.width,
                        item.resource.height,
                        1,
                        texture.format,
                        texture.type,
                        item.resource.source
                    );
                }
            }
        }

        return true;
    };

    return ArrayResource;
}(Resource));

/**
 * @interface OffscreenCanvas
 */

/**
 * Resource type for HTMLCanvasElement.
 * @class
 * @extends PIXI.resources.BaseImageResource
 * @memberof PIXI.resources
 * @param {HTMLCanvasElement} source - Canvas element to use
 */
var CanvasResource = /*@__PURE__*/(function (BaseImageResource) {
    function CanvasResource () {
        BaseImageResource.apply(this, arguments);
    }

    if ( BaseImageResource ) CanvasResource.__proto__ = BaseImageResource;
    CanvasResource.prototype = Object.create( BaseImageResource && BaseImageResource.prototype );
    CanvasResource.prototype.constructor = CanvasResource;

    CanvasResource.test = function test (source)
    {
        var OffscreenCanvas = window.OffscreenCanvas;

        // Check for browsers that don't yet support OffscreenCanvas
        if (OffscreenCanvas && source instanceof OffscreenCanvas)
        {
            return true;
        }

        return source instanceof HTMLCanvasElement;
    };

    return CanvasResource;
}(BaseImageResource));

/**
 * Resource for a CubeTexture which contains six resources.
 *
 * @class
 * @extends PIXI.resources.ArrayResource
 * @memberof PIXI.resources
 * @param {Array<string|PIXI.resources.Resource>} [source] Collection of URLs or resources
 *        to use as the sides of the cube.
 * @param {object} [options] - ImageResource options
 * @param {number} [options.width] - Width of resource
 * @param {number} [options.height] - Height of resource
 */
var CubeResource = /*@__PURE__*/(function (ArrayResource) {
    function CubeResource(source, options)
    {
        options = options || {};

        ArrayResource.call(this, source, options);

        if (this.length !== CubeResource.SIDES)
        {
            throw new Error(("Invalid length. Got " + (this.length) + ", expected 6"));
        }

        for (var i = 0; i < CubeResource.SIDES; i++)
        {
            this.items[i].target = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }

        if (options.autoLoad !== false)
        {
            this.load();
        }
    }

    if ( ArrayResource ) CubeResource.__proto__ = ArrayResource;
    CubeResource.prototype = Object.create( ArrayResource && ArrayResource.prototype );
    CubeResource.prototype.constructor = CubeResource;

    /**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */
    CubeResource.prototype.bind = function bind (baseTexture)
    {
        ArrayResource.prototype.bind.call(this, baseTexture);

        baseTexture.target = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TARGETS.TEXTURE_CUBE_MAP;
    };

    /**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */
    CubeResource.prototype.upload = function upload (renderer, baseTexture, glTexture)
    {
        var dirty = this.itemDirtyIds;

        for (var i = 0; i < CubeResource.SIDES; i++)
        {
            var side = this.items[i];

            if (dirty[i] < side.dirtyId)
            {
                dirty[i] = side.dirtyId;
                if (side.valid)
                {
                    side.resource.upload(renderer, side, glTexture);
                }
            }
        }

        return true;
    };

    return CubeResource;
}(ArrayResource));

/**
 * Number of texture sides to store for CubeResources
 *
 * @name PIXI.resources.CubeResource.SIDES
 * @static
 * @member {number}
 * @default 6
 */
CubeResource.SIDES = 6;

/**
 * Resource type for SVG elements and graphics.
 * @class
 * @extends PIXI.resources.BaseImageResource
 * @memberof PIXI.resources
 * @param {string} source - Base64 encoded SVG element or URL for SVG file.
 * @param {object} [options] - Options to use
 * @param {number} [options.scale=1] Scale to apply to SVG. Overridden by...
 * @param {number} [options.width] Rasterize SVG this wide. Aspect ratio preserved if height not specified.
 * @param {number} [options.height] Rasterize SVG this high. Aspect ratio preserved if width not specified.
 * @param {boolean} [options.autoLoad=true] Start loading right away.
 */
var SVGResource = /*@__PURE__*/(function (BaseImageResource) {
    function SVGResource(source, options)
    {
        options = options || {};

        BaseImageResource.call(this, document.createElement('canvas'));
        this._width = 0;
        this._height = 0;

        /**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */
        this.svg = source;

        /**
         * The source scale to apply when rasterizing on load
         * @readonly
         * @member {number}
         */
        this.scale = options.scale || 1;

        /**
         * A width override for rasterization on load
         * @readonly
         * @member {number}
         */
        this._overrideWidth = options.width;

        /**
         * A height override for rasterization on load
         * @readonly
         * @member {number}
         */
        this._overrideHeight = options.height;

        /**
         * Call when completely loaded
         * @private
         * @member {function}
         */
        this._resolve = null;

        /**
         * Cross origin value to use
         * @private
         * @member {boolean|string}
         */
        this._crossorigin = options.crossorigin;

        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;

        if (options.autoLoad !== false)
        {
            this.load();
        }
    }

    if ( BaseImageResource ) SVGResource.__proto__ = BaseImageResource;
    SVGResource.prototype = Object.create( BaseImageResource && BaseImageResource.prototype );
    SVGResource.prototype.constructor = SVGResource;

    SVGResource.prototype.load = function load ()
    {
        var this$1 = this;

        if (this._load)
        {
            return this._load;
        }

        this._load = new Promise(function (resolve) {
            // Save this until after load is finished
            this$1._resolve = function () {
                this$1.resize(this$1.source.width, this$1.source.height);
                resolve(this$1);
            };

            // Convert SVG inline string to data-uri
            if ((/^\<svg/).test(this$1.svg.trim()))
            {
                if (!btoa)
                {
                    throw new Error('Your browser doesn\'t support base64 conversions.');
                }
                this$1.svg = "data:image/svg+xml;base64," + (btoa(unescape(encodeURIComponent(this$1.svg))));
            }

            this$1._loadSvg();
        });

        return this._load;
    };

    /**
     * Loads an SVG image from `imageUrl` or `data URL`.
     *
     * @private
     */
    SVGResource.prototype._loadSvg = function _loadSvg ()
    {
        var this$1 = this;

        var tempImage = new Image();

        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;

        tempImage.onerror = function (event) {
            tempImage.onerror = null;
            this$1.onError.run(event);
        };

        tempImage.onload = function () {
            var svgWidth = tempImage.width;
            var svgHeight = tempImage.height;

            if (!svgWidth || !svgHeight)
            {
                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
            }

            // Set render size
            var width = svgWidth * this$1.scale;
            var height = svgHeight * this$1.scale;

            if (this$1._overrideWidth || this$1._overrideHeight)
            {
                width = this$1._overrideWidth || this$1._overrideHeight / svgHeight * svgWidth;
                height = this$1._overrideHeight || this$1._overrideWidth / svgWidth * svgHeight;
            }
            width = Math.round(width);
            height = Math.round(height);

            // Create a canvas element
            var canvas = this$1.source;

            canvas.width = width;
            canvas.height = height;
            canvas._pixiId = "canvas_" + ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.uid)());

            // Draw the Svg to the canvas
            canvas
                .getContext('2d')
                .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);

            this$1._resolve();
            this$1._resolve = null;
        };
    };

    /**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.ISize} image extension
     */
    SVGResource.getSize = function getSize (svgString)
    {
        var sizeMatch = SVGResource.SVG_SIZE.exec(svgString);
        var size = {};

        if (sizeMatch)
        {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }

        return size;
    };

    /**
     * Destroys this texture
     * @override
     */
    SVGResource.prototype.dispose = function dispose ()
    {
        BaseImageResource.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
    };

    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */
    SVGResource.test = function test (source, extension)
    {
        // url file extension is SVG
        return extension === 'svg'
            // source is SVG data-uri
            || (typeof source === 'string' && source.indexOf('data:image/svg+xml;base64') === 0)
            // source is SVG inline
            || (typeof source === 'string' && source.indexOf('<svg') === 0);
    };

    return SVGResource;
}(BaseImageResource));

/**
 * RegExp for SVG size.
 *
 * @static
 * @constant {RegExp|string} SVG_SIZE
 * @memberof PIXI.resources.SVGResource
 * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
 */
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len

/**
 * Resource type for HTMLVideoElement.
 * @class
 * @extends PIXI.resources.BaseImageResource
 * @memberof PIXI.resources
 * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.
 * @param {object} [options] - Options to use
 * @param {boolean} [options.autoLoad=true] - Start loading the video immediately
 * @param {boolean} [options.autoPlay=true] - Start playing video immediately
 * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.
 * Leave at 0 to update at every render.
 * @param {boolean} [options.crossorigin=true] - Load image using cross origin
 */
var VideoResource = /*@__PURE__*/(function (BaseImageResource) {
    function VideoResource(source, options)
    {
        options = options || {};

        if (!(source instanceof HTMLVideoElement))
        {
            var videoElement = document.createElement('video');

            // workaround for https://github.com/pixijs/pixi.js/issues/5996
            videoElement.setAttribute('preload', 'auto');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('playsinline', '');

            if (typeof source === 'string')
            {
                source = [source];
            }

            BaseImageResource.crossOrigin(videoElement, (source[0].src || source[0]), options.crossorigin);

            // array of objects or strings
            for (var i = 0; i < source.length; ++i)
            {
                var sourceElement = document.createElement('source');

                var ref = source[i];
                var src = ref.src;
                var mime = ref.mime;

                src = src || source[i];

                var baseSrc = src.split('?').shift().toLowerCase();
                var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1);

                mime = mime || ("video/" + ext);

                sourceElement.src = src;
                sourceElement.type = mime;

                videoElement.appendChild(sourceElement);
            }

            // Override the source
            source = videoElement;
        }

        BaseImageResource.call(this, source);

        this._autoUpdate = true;
        this._isAutoUpdating = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;

        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPlay = options.autoPlay !== false;

        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;

        /**
         * Callback when completed with load.
         * @member {function}
         * @private
         */
        this._resolve = null;

        // Bind for listeners
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onError = this._onError.bind(this);

        if (options.autoLoad !== false)
        {
            this.load();
        }
    }

    if ( BaseImageResource ) VideoResource.__proto__ = BaseImageResource;
    VideoResource.prototype = Object.create( BaseImageResource && BaseImageResource.prototype );
    VideoResource.prototype.constructor = VideoResource;

    var prototypeAccessors = { autoUpdate: { configurable: true },updateFPS: { configurable: true } };

    /**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */
    VideoResource.prototype.update = function update (deltaTime)
    {
        if ( deltaTime === void 0 ) deltaTime = 0;

        if (!this.destroyed)
        {
            // account for if video has had its playbackRate changed
            var elapsedMS = _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.elapsedMS * this.source.playbackRate;

            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            if (!this._updateFPS || this._msToNextUpdate <= 0)
            {
                BaseImageResource.prototype.update.call(this, deltaTime);
                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
            }
        }
    };

    /**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    VideoResource.prototype.load = function load ()
    {
        var this$1 = this;

        if (this._load)
        {
            return this._load;
        }

        var source = this.source;

        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)
            && source.width && source.height)
        {
            source.complete = true;
        }

        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));

        if (!this._isSourceReady())
        {
            source.addEventListener('canplay', this._onCanPlay);
            source.addEventListener('canplaythrough', this._onCanPlay);
            source.addEventListener('error', this._onError, true);
        }
        else
        {
            this._onCanPlay();
        }

        this._load = new Promise(function (resolve) {
            if (this$1.valid)
            {
                resolve(this$1);
            }
            else
            {
                this$1._resolve = resolve;

                source.load();
            }
        });

        return this._load;
    };

    /**
     * Handle video error events.
     *
     * @private
     */
    VideoResource.prototype._onError = function _onError ()
    {
        this.source.removeEventListener('error', this._onError, true);
        this.onError.run(event);
    };

    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */
    VideoResource.prototype._isSourcePlaying = function _isSourcePlaying ()
    {
        var source = this.source;

        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);
    };

    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */
    VideoResource.prototype._isSourceReady = function _isSourceReady ()
    {
        return this.source.readyState === 3 || this.source.readyState === 4;
    };

    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */
    VideoResource.prototype._onPlayStart = function _onPlayStart ()
    {
        // Just in case the video has not received its can play even yet..
        if (!this.valid)
        {
            this._onCanPlay();
        }

        if (!this._isAutoUpdating && this.autoUpdate)
        {
            _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    };

    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */
    VideoResource.prototype._onPlayStop = function _onPlayStop ()
    {
        if (this._isAutoUpdating)
        {
            _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    };

    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */
    VideoResource.prototype._onCanPlay = function _onCanPlay ()
    {
        var ref = this;
        var source = ref.source;

        source.removeEventListener('canplay', this._onCanPlay);
        source.removeEventListener('canplaythrough', this._onCanPlay);

        var valid = this.valid;

        this.resize(source.videoWidth, source.videoHeight);

        // prevent multiple loaded dispatches..
        if (!valid && this._resolve)
        {
            this._resolve(this);
            this._resolve = null;
        }

        if (this._isSourcePlaying())
        {
            this._onPlayStart();
        }
        else if (this.autoPlay)
        {
            source.play();
        }
    };

    /**
     * Destroys this texture
     * @override
     */
    VideoResource.prototype.dispose = function dispose ()
    {
        if (this._isAutoUpdating)
        {
            _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.remove(this.update, this);
        }

        if (this.source)
        {
            this.source.removeEventListener('error', this._onError, true);
            this.source.pause();
            this.source.src = '';
            this.source.load();
        }
        BaseImageResource.prototype.dispose.call(this);
    };

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */
    prototypeAccessors.autoUpdate.get = function ()
    {
        return this._autoUpdate;
    };

    prototypeAccessors.autoUpdate.set = function (value) // eslint-disable-line require-jsdoc
    {
        if (value !== this._autoUpdate)
        {
            this._autoUpdate = value;

            if (!this._autoUpdate && this._isAutoUpdating)
            {
                _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
            else if (this._autoUpdate && !this._isAutoUpdating)
            {
                _pixi_ticker__WEBPACK_IMPORTED_MODULE_4__.Ticker.shared.add(this.update, this);
                this._isAutoUpdating = true;
            }
        }
    };

    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     *
     * @member {number}
     */
    prototypeAccessors.updateFPS.get = function ()
    {
        return this._updateFPS;
    };

    prototypeAccessors.updateFPS.set = function (value) // eslint-disable-line require-jsdoc
    {
        if (value !== this._updateFPS)
        {
            this._updateFPS = value;
        }
    };

    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */
    VideoResource.test = function test (source, extension)
    {
        return (source instanceof HTMLVideoElement)
            || VideoResource.TYPES.indexOf(extension) > -1;
    };

    Object.defineProperties( VideoResource.prototype, prototypeAccessors );

    return VideoResource;
}(BaseImageResource));

/**
 * List of common video file extensions supported by VideoResource.
 * @constant
 * @member {Array<string>}
 * @static
 * @readonly
 */
VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];

/**
 * Resource type for ImageBitmap.
 * @class
 * @extends PIXI.resources.BaseImageResource
 * @memberof PIXI.resources
 * @param {ImageBitmap} source - Image element to use
 */
var ImageBitmapResource = /*@__PURE__*/(function (BaseImageResource) {
    function ImageBitmapResource () {
        BaseImageResource.apply(this, arguments);
    }

    if ( BaseImageResource ) ImageBitmapResource.__proto__ = BaseImageResource;
    ImageBitmapResource.prototype = Object.create( BaseImageResource && BaseImageResource.prototype );
    ImageBitmapResource.prototype.constructor = ImageBitmapResource;

    ImageBitmapResource.test = function test (source)
    {
        return !!window.createImageBitmap && source instanceof ImageBitmap;
    };

    return ImageBitmapResource;
}(BaseImageResource));

INSTALLED.push(
    ImageResource,
    ImageBitmapResource,
    CanvasResource,
    VideoResource,
    SVGResource,
    BufferResource,
    CubeResource,
    ArrayResource
);

var index = ({
    INSTALLED: INSTALLED,
    autoDetectResource: autoDetectResource,
    ArrayResource: ArrayResource,
    BufferResource: BufferResource,
    CanvasResource: CanvasResource,
    CubeResource: CubeResource,
    ImageResource: ImageResource,
    ImageBitmapResource: ImageBitmapResource,
    SVGResource: SVGResource,
    VideoResource: VideoResource,
    Resource: Resource,
    BaseImageResource: BaseImageResource
});

/**
 * System is a base class used for extending systems used by the {@link PIXI.Renderer}
 *
 * @see PIXI.Renderer#addSystem
 * @class
 * @memberof PIXI
 */
var System = function System(renderer)
{
    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.Renderer}
     */
    this.renderer = renderer;
};

/**
 * Generic destroy methods to be overridden by the subclass
 */
System.prototype.destroy = function destroy ()
{
    this.renderer = null;
};

/**
 * Resource type for DepthTexture.
 * @class
 * @extends PIXI.resources.BufferResource
 * @memberof PIXI.resources
 */
var DepthResource = /*@__PURE__*/(function (BufferResource) {
    function DepthResource () {
        BufferResource.apply(this, arguments);
    }

    if ( BufferResource ) DepthResource.__proto__ = BufferResource;
    DepthResource.prototype = Object.create( BufferResource && BufferResource.prototype );
    DepthResource.prototype.constructor = DepthResource;

    DepthResource.prototype.upload = function upload (renderer, baseTexture, glTexture)
    {
        var gl = renderer.gl;

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);

        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height)
        {
            gl.texSubImage2D(
                baseTexture.target,
                0,
                0,
                0,
                baseTexture.width,
                baseTexture.height,
                baseTexture.format,
                baseTexture.type,
                this.data
            );
        }
        else
        {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;

            gl.texImage2D(
                baseTexture.target,
                0,
                gl.DEPTH_COMPONENT16, // Needed for depth to render properly in webgl2.0
                baseTexture.width,
                baseTexture.height,
                0,
                baseTexture.format,
                baseTexture.type,
                this.data
            );
        }

        return true;
    };

    return DepthResource;
}(BufferResource));

/**
 * Frame buffer used by the BaseRenderTexture
 *
 * @class
 * @memberof PIXI
 */
var Framebuffer = function Framebuffer(width, height)
{
    this.width = Math.ceil(width || 100);
    this.height = Math.ceil(height || 100);

    this.stencil = false;
    this.depth = false;

    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;

    this.depthTexture = null;
    this.colorTextures = [];

    this.glFramebuffers = {};

    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('disposeFramebuffer', 2);
};

var prototypeAccessors$1 = { colorTexture: { configurable: true } };

/**
 * Reference to the colorTexture.
 *
 * @member {PIXI.Texture[]}
 * @readonly
 */
prototypeAccessors$1.colorTexture.get = function ()
{
    return this.colorTextures[0];
};

/**
 * Add texture to the colorTexture array
 *
 * @param {number} [index=0] - Index of the array to add the texture to
 * @param {PIXI.Texture} [texture] - Texture to add to the array
 */
Framebuffer.prototype.addColorTexture = function addColorTexture (index, texture)
{
        if ( index === void 0 ) index = 0;

    // TODO add some validation to the texture - same width / height etc?
    this.colorTextures[index] = texture || new BaseTexture(null, { scaleMode: 0,
        resolution: 1,
        mipmap: false,
        width: this.width,
        height: this.height });// || new Texture();

    this.dirtyId++;
    this.dirtyFormat++;

    return this;
};

/**
 * Add a depth texture to the frame buffer
 *
 * @param {PIXI.Texture} [texture] - Texture to add
 */
Framebuffer.prototype.addDepthTexture = function addDepthTexture (texture)
{
    /* eslint-disable max-len */
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: false,
        format: _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.FORMATS.DEPTH_COMPONENT,
        type: _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.UNSIGNED_SHORT });// UNSIGNED_SHORT;
    /* eslint-disable max-len */
    this.dirtyId++;
    this.dirtyFormat++;

    return this;
};

/**
 * Enable depth on the frame buffer
 */
Framebuffer.prototype.enableDepth = function enableDepth ()
{
    this.depth = true;

    this.dirtyId++;
    this.dirtyFormat++;

    return this;
};

/**
 * Enable stencil on the frame buffer
 */
Framebuffer.prototype.enableStencil = function enableStencil ()
{
    this.stencil = true;

    this.dirtyId++;
    this.dirtyFormat++;

    return this;
};

/**
 * Resize the frame buffer
 *
 * @param {number} width - Width of the frame buffer to resize to
 * @param {number} height - Height of the frame buffer to resize to
 */
Framebuffer.prototype.resize = function resize (width, height)
{
    width = Math.ceil(width);
    height = Math.ceil(height);

    if (width === this.width && height === this.height) { return; }

    this.width = width;
    this.height = height;

    this.dirtyId++;
    this.dirtySize++;

    for (var i = 0; i < this.colorTextures.length; i++)
    {
        var texture = this.colorTextures[i];
        var resolution = texture.resolution;

        // take into acount the fact the texture may have a different resolution..
        texture.setSize(width / resolution, height / resolution);
    }

    if (this.depthTexture)
    {
        var resolution$1 = this.depthTexture.resolution;

        this.depthTexture.setSize(width / resolution$1, height / resolution$1);
    }
};

/**
 * disposes WebGL resources that are connected to this geometry
 */
Framebuffer.prototype.dispose = function dispose ()
{
    this.disposeRunner.run(this, false);
};

Object.defineProperties( Framebuffer.prototype, prototypeAccessors$1 );

/**
 * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer();
 * let baseRenderTexture = new PIXI.BaseRenderTexture({ width: 800, height: 600 });
 * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
 * let sprite = PIXI.Sprite.from("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let baseRenderTexture = new PIXI.BaseRenderTexture({ width: 100, height: 100 });
 * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var BaseRenderTexture = /*@__PURE__*/(function (BaseTexture) {
    function BaseRenderTexture(options)
    {
        if (typeof options === 'number')
        {
            /* eslint-disable prefer-rest-params */
            // Backward compatibility of signature
            var width$1 = arguments[0];
            var height$1 = arguments[1];
            var scaleMode = arguments[2];
            var resolution = arguments[3];

            options = { width: width$1, height: height$1, scaleMode: scaleMode, resolution: resolution };
            /* eslint-enable prefer-rest-params */
        }

        BaseTexture.call(this, null, options);

        var ref = options || {};
        var width = ref.width;
        var height = ref.height;

        // Set defaults
        this.mipmap = false;
        this.width = Math.ceil(width) || 100;
        this.height = Math.ceil(height) || 100;
        this.valid = true;

        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @protected
         * @member {object}
         */
        this._canvasRenderTarget = null;

        this.clearColor = [0, 0, 0, 0];

        this.framebuffer = new Framebuffer(this.width * this.resolution, this.height * this.resolution)
            .addColorTexture(0, this)
            .enableStencil();

        // TODO - could this be added the systems?

        /**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];

        /**
         * The data structure for the filters.
         *
         * @member {PIXI.Graphics[]}
         */
        this.filterStack = [{}];
    }

    if ( BaseTexture ) BaseRenderTexture.__proto__ = BaseTexture;
    BaseRenderTexture.prototype = Object.create( BaseTexture && BaseTexture.prototype );
    BaseRenderTexture.prototype.constructor = BaseRenderTexture;

    /**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */
    BaseRenderTexture.prototype.resize = function resize (width, height)
    {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
    };

    /**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    BaseRenderTexture.prototype.dispose = function dispose ()
    {
        this.framebuffer.dispose();

        BaseTexture.prototype.dispose.call(this);
    };

    /**
     * Destroys this texture.
     *
     */
    BaseRenderTexture.prototype.destroy = function destroy ()
    {
        BaseTexture.prototype.destroy.call(this, true);

        this.framebuffer = null;
    };

    return BaseRenderTexture;
}(BaseTexture));

/**
 * Stores a texture's frame in UV coordinates, in
 * which everything lies in the rectangle `[(0,0), (1,0),
 * (1,1), (0,1)]`.
 *
 * | Corner       | Coordinates |
 * |--------------|-------------|
 * | Top-Left     | `(x0,y0)`   |
 * | Top-Right    | `(x1,y1)`   |
 * | Bottom-Right | `(x2,y2)`   |
 * | Bottom-Left  | `(x3,y3)`   |
 *
 * @class
 * @protected
 * @memberof PIXI
 */
var TextureUvs = function TextureUvs()
{
    /**
     * X-component of top-left corner `(x0,y0)`.
     *
     * @member {number}
     */
    this.x0 = 0;

    /**
     * Y-component of top-left corner `(x0,y0)`.
     *
     * @member {number}
     */
    this.y0 = 0;

    /**
     * X-component of top-right corner `(x1,y1)`.
     *
     * @member {number}
     */
    this.x1 = 1;

    /**
     * Y-component of top-right corner `(x1,y1)`.
     *
     * @member {number}
     */
    this.y1 = 0;

    /**
     * X-component of bottom-right corner `(x2,y2)`.
     *
     * @member {number}
     */
    this.x2 = 1;

    /**
     * Y-component of bottom-right corner `(x2,y2)`.
     *
     * @member {number}
     */
    this.y2 = 1;

    /**
     * X-component of bottom-left corner `(x3,y3)`.
     *
     * @member {number}
     */
    this.x3 = 0;

    /**
     * Y-component of bottom-right corner `(x3,y3)`.
     *
     * @member {number}
     */
    this.y3 = 1;

    this.uvsFloat32 = new Float32Array(8);
};

/**
 * Sets the texture Uvs based on the given frame information.
 *
 * @protected
 * @param {PIXI.Rectangle} frame - The frame of the texture
 * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
 * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
 */
TextureUvs.prototype.set = function set (frame, baseFrame, rotate)
{
    var tw = baseFrame.width;
    var th = baseFrame.height;

    if (rotate)
    {
        // width and height div 2 div baseFrame size
        var w2 = frame.width / 2 / tw;
        var h2 = frame.height / 2 / th;

        // coordinates of center
        var cX = (frame.x / tw) + w2;
        var cY = (frame.y / th) + h2;

        rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.add(rotate, _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.NW); // NW is top-left corner
        this.x0 = cX + (w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uX(rotate));
        this.y0 = cY + (h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uY(rotate));

        rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.add(rotate, 2); // rotate 90 degrees clockwise
        this.x1 = cX + (w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uX(rotate));
        this.y1 = cY + (h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uY(rotate));

        rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.add(rotate, 2);
        this.x2 = cX + (w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uX(rotate));
        this.y2 = cY + (h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uY(rotate));

        rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.add(rotate, 2);
        this.x3 = cX + (w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uX(rotate));
        this.y3 = cY + (h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_5__.GroupD8.uY(rotate));
    }
    else
    {
        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;

        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;

        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
    }

    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
};

var DEFAULT_UVS = new TextureUvs();

/**
 * A texture stores the information that represents an image or part of an image.
 *
 * It cannot be added to the display list directly; instead use it as the texture for a Sprite.
 * If no frame is provided for a texture, then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * let texture = PIXI.Texture.from('assets/image.png');
 * let sprite1 = new PIXI.Sprite(texture);
 * let sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * If you didnt pass the texture frame to constructor, it enables `noFrame` mode:
 * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.
 *
 * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
 * You can check for this by checking the sprite's _textureID property.
 * ```js
 * var texture = PIXI.Texture.from('assets/image.svg');
 * var sprite1 = new PIXI.Sprite(texture);
 * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
 * ```
 * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
 *
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI
 */
var Texture = /*@__PURE__*/(function (EventEmitter) {
    function Texture(baseTexture, frame, orig, trim, rotate, anchor)
    {
        EventEmitter.call(this);

        /**
         * Does this Texture have any frame data assigned to it?
         *
         * This mode is enabled automatically if no frame was passed inside constructor.
         *
         * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.
         *
         * Beware, after loading or resize of baseTexture event can fired two times!
         * If you want more control, subscribe on baseTexture itself.
         *
         * ```js
         * texture.on('update', () => {});
         * ```
         *
         * Any assignment of `frame` switches off `noFrame` mode.
         *
         * @member {boolean}
         */
        this.noFrame = false;

        if (!frame)
        {
            this.noFrame = true;
            frame = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle(0, 0, 1, 1);
        }

        if (baseTexture instanceof Texture)
        {
            baseTexture = baseTexture.baseTexture;
        }

        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;

        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        this._frame = frame;

        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        this.trim = trim;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = false;

        /**
         * This will let a renderer know that a texture has been updated (used mainly for WebGL uv updates)
         *
         * @member {boolean}
         */
        this.requiresUpdate = false;

        /**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */
        this._uvs = DEFAULT_UVS;

        /**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = null;

        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        this.orig = orig || frame;// new Rectangle(0, 0, 1, 1);

        this._rotate = Number(rotate || 0);

        if (rotate === true)
        {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            this._rotate = 2;
        }
        else if (this._rotate % 2 !== 0)
        {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }

        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        this.defaultAnchor = anchor ? new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Point(anchor.x, anchor.y) : new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Point(0, 0);

        /**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */

        this._updateID = 0;

        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        this.textureCacheIds = [];

        if (!baseTexture.valid)
        {
            baseTexture.once('loaded', this.onBaseTextureUpdated, this);
        }
        else if (this.noFrame)
        {
            // if there is no frame we should monitor for any base texture changes..
            if (baseTexture.valid)
            {
                this.onBaseTextureUpdated(baseTexture);
            }
        }
        else
        {
            this.frame = frame;
        }

        if (this.noFrame)
        {
            baseTexture.on('update', this.onBaseTextureUpdated, this);
        }
    }

    if ( EventEmitter ) Texture.__proto__ = EventEmitter;
    Texture.prototype = Object.create( EventEmitter && EventEmitter.prototype );
    Texture.prototype.constructor = Texture;

    var prototypeAccessors = { resolution: { configurable: true },frame: { configurable: true },rotate: { configurable: true },width: { configurable: true },height: { configurable: true } };

    /**
     * Updates this texture on the gpu.
     *
     * Calls the TextureResource update.
     *
     * If you adjusted `frame` manually, please call `updateUvs()` instead.
     *
     */
    Texture.prototype.update = function update ()
    {
        if (this.baseTexture.resource)
        {
            this.baseTexture.resource.update();
        }
    };

    /**
     * Called when the base texture is updated
     *
     * @protected
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */
    Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated (baseTexture)
    {
        if (this.noFrame)
        {
            if (!this.baseTexture.valid)
            {
                return;
            }

            this._frame.width = baseTexture.width;
            this._frame.height = baseTexture.height;
            this.valid = true;
            this.updateUvs();
        }
        else
        {
            // TODO this code looks confusing.. boo to abusing getters and setters!
            // if user gave us frame that has bigger size than resized texture it can be a problem
            this.frame = this._frame;
        }

        this.emit('update', this);
    };

    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    Texture.prototype.destroy = function destroy (destroyBase)
    {
        if (this.baseTexture)
        {
            if (destroyBase)
            {
                var ref = this.baseTexture;
                var resource = ref.resource;

                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (resource && _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[resource.url])
                {
                    Texture.removeFromCache(resource.url);
                }

                this.baseTexture.destroy();
            }

            this.baseTexture.off('update', this.onBaseTextureUpdated, this);

            this.baseTexture = null;
        }

        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;

        this.valid = false;

        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    };

    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */
    Texture.prototype.clone = function clone ()
    {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    };

    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */
    Texture.prototype.updateUvs = function updateUvs ()
    {
        if (this._uvs === DEFAULT_UVS)
        {
            this._uvs = new TextureUvs();
        }

        this._uvs.set(this._frame, this.baseTexture, this.rotate);

        this._updateID++;
    };

    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The newly created texture
     */
    Texture.from = function from (source, options)
    {
        if ( options === void 0 ) options = {};

        var cacheId = null;

        if (typeof source === 'string')
        {
            cacheId = source;
        }
        else
        {
            if (!source._pixiId)
            {
                source._pixiId = "pixiid_" + ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.uid)());
            }

            cacheId = source._pixiId;
        }

        var texture = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[cacheId];

        if (!texture)
        {
            if (!options.resolution)
            {
                options.resolution = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.getResolutionOfUrl)(source);
            }

            texture = new Texture(new BaseTexture(source, options));
            texture.baseTexture.cacheId = cacheId;

            BaseTexture.addToCache(texture.baseTexture, cacheId);
            Texture.addToCache(texture, cacheId);
        }

        // lets assume its a base texture!
        return texture;
    };

    /**
     * Create a new Texture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The resulting new BaseTexture
     */
    Texture.fromBuffer = function fromBuffer (buffer, width, height, options)
    {
        return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
    };

    /**
     * Create a texture from a source and add to the cache.
     *
     * @static
     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
     * @param {String} [name] - Human readable name for the texture cache. If no name is
     *        specified, only `imageUrl` will be used as the cache ID.
     * @return {PIXI.Texture} Output texture
     */
    Texture.fromLoader = function fromLoader (source, imageUrl, name)
    {
        var resource = new ImageResource(source);

        resource.url = imageUrl;

        var baseTexture = new BaseTexture(resource, {
            scaleMode: _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.SCALE_MODE,
            resolution: (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.getResolutionOfUrl)(imageUrl),
        });

        var texture = new Texture(baseTexture);

        // No name, use imageUrl instead
        if (!name)
        {
            name = imageUrl;
        }

        // lets also add the frame to pixi's global cache for 'fromLoader' function
        BaseTexture.addToCache(texture.baseTexture, name);
        Texture.addToCache(texture, name);

        // also add references by url if they are different.
        if (name !== imageUrl)
        {
            BaseTexture.addToCache(texture.baseTexture, imageUrl);
            Texture.addToCache(texture, imageUrl);
        }

        return texture;
    };

    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */
    Texture.addToCache = function addToCache (texture, id)
    {
        if (id)
        {
            if (texture.textureCacheIds.indexOf(id) === -1)
            {
                texture.textureCacheIds.push(id);
            }

            if (_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[id])
            {
                // eslint-disable-next-line no-console
                console.warn(("Texture added to the cache with an id [" + id + "] that already had an entry"));
            }

            _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[id] = texture;
        }
    };

    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */
    Texture.removeFromCache = function removeFromCache (texture)
    {
        if (typeof texture === 'string')
        {
            var textureFromCache = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[texture];

            if (textureFromCache)
            {
                var index = textureFromCache.textureCacheIds.indexOf(texture);

                if (index > -1)
                {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }

                delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[texture];

                return textureFromCache;
            }
        }
        else if (texture && texture.textureCacheIds)
        {
            for (var i = 0; i < texture.textureCacheIds.length; ++i)
            {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[texture.textureCacheIds[i]] === texture)
                {
                    delete _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.TextureCache[texture.textureCacheIds[i]];
                }
            }

            texture.textureCacheIds.length = 0;

            return texture;
        }

        return null;
    };

    /**
     * Returns resolution of baseTexture
     *
     * @member {number}
     * @readonly
     */
    prototypeAccessors.resolution.get = function ()
    {
        return this.baseTexture.resolution;
    };

    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `updateUvs()` after you change coordinates of `frame` manually.
     *
     * @member {PIXI.Rectangle}
     */
    prototypeAccessors.frame.get = function ()
    {
        return this._frame;
    };

    prototypeAccessors.frame.set = function (frame) // eslint-disable-line require-jsdoc
    {
        this._frame = frame;

        this.noFrame = false;

        var x = frame.x;
        var y = frame.y;
        var width = frame.width;
        var height = frame.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;

        if (xNotFit || yNotFit)
        {
            var relationship = xNotFit && yNotFit ? 'and' : 'or';
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + (this.baseTexture.width);
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + (this.baseTexture.height);

            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '
                + errorX + " " + relationship + " " + errorY);
        }

        this.valid = width && height && this.baseTexture.valid;

        if (!this.trim && !this.rotate)
        {
            this.orig = frame;
        }

        if (this.valid)
        {
            this.updateUvs();
        }
    };

    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    prototypeAccessors.rotate.get = function ()
    {
        return this._rotate;
    };

    prototypeAccessors.rotate.set = function (rotate) // eslint-disable-line require-jsdoc
    {
        this._rotate = rotate;
        if (this.valid)
        {
            this.updateUvs();
        }
    };

    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    prototypeAccessors.width.get = function ()
    {
        return this.orig.width;
    };

    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    prototypeAccessors.height.get = function ()
    {
        return this.orig.height;
    };

    Object.defineProperties( Texture.prototype, prototypeAccessors );

    return Texture;
}(_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter));

function createWhiteTexture()
{
    var canvas = document.createElement('canvas');

    canvas.width = 16;
    canvas.height = 16;

    var context = canvas.getContext('2d');

    context.fillStyle = 'white';
    context.fillRect(0, 0, 16, 16);

    return new Texture(new BaseTexture(new CanvasResource(canvas)));
}

function removeAllHandlers(tex)
{
    tex.destroy = function _emptyDestroy() { /* empty */ };
    tex.on = function _emptyOn() { /* empty */ };
    tex.once = function _emptyOnce() { /* empty */ };
    tex.emit = function _emptyEmit() { /* empty */ };
}

/**
 * An empty texture, used often to not have to create multiple empty textures.
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
Texture.EMPTY = new Texture(new BaseTexture());
removeAllHandlers(Texture.EMPTY);
removeAllHandlers(Texture.EMPTY.baseTexture);

/**
 * A white texture of 16x16 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
removeAllHandlers(Texture.WHITE.baseTexture);

/**
 * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * __Hint-2__: The actual memory allocation will happen on first render.
 * You shouldn't create renderTextures each frame just to delete them after, try to reuse them.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer();
 * let renderTexture = PIXI.RenderTexture.create(800, 600);
 * let sprite = PIXI.Sprite.from("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let renderTexture = new PIXI.RenderTexture.create(100, 100);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 */
var RenderTexture = /*@__PURE__*/(function (Texture) {
    function RenderTexture(baseRenderTexture, frame)
    {
        // support for legacy..
        var _legacyRenderer = null;

        if (!(baseRenderTexture instanceof BaseRenderTexture))
        {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];

            // we have an old render texture..
            console.warn(("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly."));
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */

            frame = null;
            baseRenderTexture = new BaseRenderTexture({
                width: width,
                height: height,
                scaleMode: scaleMode,
                resolution: resolution,
            });
        }

        /**
         * The base texture object that this texture uses
         *
         * @member {PIXI.BaseTexture}
         */
        Texture.call(this, baseRenderTexture, frame);

        this.legacyRenderer = _legacyRenderer;

        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = true;

        /**
         * Stores `sourceFrame` when this texture is inside current filter stack.
         * You can read it inside filters.
         *
         * @readonly
         * @member {PIXI.Rectangle}
         */
        this.filterFrame = null;

        /**
         * The key for pooled texture of FilterSystem
         * @protected
         * @member {string}
         */
        this.filterPoolKey = null;

        this.updateUvs();
    }

    if ( Texture ) RenderTexture.__proto__ = Texture;
    RenderTexture.prototype = Object.create( Texture && Texture.prototype );
    RenderTexture.prototype.constructor = RenderTexture;

    /**
     * Resizes the RenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
     */
    RenderTexture.prototype.resize = function resize (width, height, resizeBaseTexture)
    {
        if ( resizeBaseTexture === void 0 ) resizeBaseTexture = true;

        width = Math.ceil(width);
        height = Math.ceil(height);

        // TODO - could be not required..
        this.valid = (width > 0 && height > 0);

        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;

        if (resizeBaseTexture)
        {
            this.baseTexture.resize(width, height);
        }

        this.updateUvs();
    };

    /**
     * Changes the resolution of baseTexture, but does not change framebuffer size.
     *
     * @param {number} resolution - The new resolution to apply to RenderTexture
     */
    RenderTexture.prototype.setResolution = function setResolution (resolution)
    {
        var ref = this;
        var baseTexture = ref.baseTexture;

        if (baseTexture.resolution === resolution)
        {
            return;
        }

        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
    };

    /**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */
    RenderTexture.create = function create (options)
    {
        // fallback, old-style: create(width, height, scaleMode, resolution)
        if (typeof options === 'number')
        {
            /* eslint-disable prefer-rest-params */
            options = {
                width: options,
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3],
            };
            /* eslint-enable prefer-rest-params */
        }

        return new RenderTexture(new BaseRenderTexture(options));
    };

    return RenderTexture;
}(Texture));

/**
 * Experimental!
 *
 * Texture pool, used by FilterSystem and plugins
 * Stores collection of temporary pow2 or screen-sized renderTextures
 *
 * If you use custom RenderTexturePool for your filters, you can use methods
 * `getFilterTexture` and `returnFilterTexture` same as in
 *
 * @class
 * @memberof PIXI
 */
var RenderTexturePool = function RenderTexturePool(textureOptions)
{
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    /**
     * Allow renderTextures of the same size as screen, not just pow2
     *
     * Automatically sets to true after `setScreenSize`
     *
     * @member {boolean}
     * @default false
     */
    this.enableFullScreen = false;

    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
};

/**
 * creates of texture with params that were specified in pool constructor
 *
 * @param {number} realWidth width of texture in pixels
 * @param {number} realHeight height of texture in pixels
 * @returns {RenderTexture}
 */
RenderTexturePool.prototype.createTexture = function createTexture (realWidth, realHeight)
{
    var baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1,
    }, this.textureOptions));

    return new RenderTexture(baseRenderTexture);
};

/**
 * Gets a Power-of-Two render texture or fullScreen texture
 *
 * @protected
 * @param {number} minWidth - The minimum width of the render texture in real pixels.
 * @param {number} minHeight - The minimum height of the render texture in real pixels.
 * @param {number} [resolution=1] - The resolution of the render texture.
 * @return {PIXI.RenderTexture} The new render texture.
 */
RenderTexturePool.prototype.getOptimalTexture = function getOptimalTexture (minWidth, minHeight, resolution)
{
        if ( resolution === void 0 ) resolution = 1;

    var key = RenderTexturePool.SCREEN_KEY;

    minWidth *= resolution;
    minHeight *= resolution;

    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight)
    {
        minWidth = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minWidth);
        minHeight = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minHeight);
        key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);
    }

    if (!this.texturePool[key])
    {
        this.texturePool[key] = [];
    }

    var renderTexture = this.texturePool[key].pop();

    if (!renderTexture)
    {
        renderTexture = this.createTexture(minWidth, minHeight);
    }

    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);

    return renderTexture;
};

/**
 * Gets extra texture of the same size as input renderTexture
 *
 * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
 *
 * @param {PIXI.RenderTexture} input renderTexture from which size and resolution will be copied
 * @param {number} [resolution] override resolution of the renderTexture
 *  It overrides, it does not multiply
 * @returns {PIXI.RenderTexture}
 */
RenderTexturePool.prototype.getFilterTexture = function getFilterTexture (input, resolution)
{
    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);

    filterTexture.filterFrame = input.filterFrame;

    return filterTexture;
};

/**
 * Place a render texture back into the pool.
 * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
 */
RenderTexturePool.prototype.returnTexture = function returnTexture (renderTexture)
{
    var key = renderTexture.filterPoolKey;

    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
};

/**
 * Alias for returnTexture, to be compliant with FilterSystem interface
 * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
 */
RenderTexturePool.prototype.returnFilterTexture = function returnFilterTexture (renderTexture)
{
    this.returnTexture(renderTexture);
};

/**
 * Clears the pool
 *
 * @param {boolean} [destroyTextures=true] destroy all stored textures
 */
RenderTexturePool.prototype.clear = function clear (destroyTextures)
{
    destroyTextures = destroyTextures !== false;
    if (destroyTextures)
    {
        for (var i in this.texturePool)
        {
            var textures = this.texturePool[i];

            if (textures)
            {
                for (var j = 0; j < textures.length; j++)
                {
                    textures[j].destroy(true);
                }
            }
        }
    }

    this.texturePool = {};
};

/**
 * If screen size was changed, drops all screen-sized textures,
 * sets new screen size, sets `enableFullScreen` to true
 *
 * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
 *
 * @param {PIXI.ISize} size - Initial size of screen
 */
RenderTexturePool.prototype.setScreenSize = function setScreenSize (size)
{
    if (size.width === this._pixelsWidth
        && size.height === this._pixelsHeight)
    {
        return;
    }

    var screenKey = RenderTexturePool.SCREEN_KEY;
    var textures = this.texturePool[screenKey];

    this.enableFullScreen = size.width > 0 && size.height > 0;

    if (textures)
    {
        for (var j = 0; j < textures.length; j++)
        {
            textures[j].destroy(true);
        }
    }
    this.texturePool[screenKey] = [];

    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
};

/**
 * Key that is used to store fullscreen renderTextures in a pool
 *
 * @static
 * @const {string}
 */
RenderTexturePool.SCREEN_KEY = 'screen';

/* eslint-disable max-len */

/**
 * Holds the information for a single attribute structure required to render geometry.
 *
 * This does not contain the actual data, but instead has a buffer id that maps to a {@link PIXI.Buffer}
 * This can include anything from positions, uvs, normals, colors etc.
 *
 * @class
 * @memberof PIXI
 */
var Attribute = function Attribute(buffer, size, normalized, type, stride, start, instance)
{
    if ( normalized === void 0 ) normalized = false;
    if ( type === void 0 ) type = 5126;

    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
};

/**
 * Destroys the Attribute.
 */
Attribute.prototype.destroy = function destroy ()
{
    this.buffer = null;
};

/**
 * Helper function that creates an Attribute based on the information provided
 *
 * @static
 * @param {string} buffer  the id of the buffer that this attribute will look for
 * @param {Number} [size=2] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
 * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
 * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
 * @param {Boolean} [normalized=false] should the data be normalized.
 *
 * @returns {PIXI.Attribute} A new {@link PIXI.Attribute} based on the information provided
 */
Attribute.from = function from (buffer, size, normalized, type, stride)
{
    return new Attribute(buffer, size, normalized, type, stride);
};

var UID = 0;
/* eslint-disable max-len */

/**
 * A wrapper for data so that it can be used and uploaded by WebGL
 *
 * @class
 * @memberof PIXI
 */
var Buffer = function Buffer(data, _static, index)
{
    if ( _static === void 0 ) _static = true;
    if ( index === void 0 ) index = false;

    /**
     * The data in the buffer, as a typed array
     *
     * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
     */
    this.data = data || new Float32Array(1);

    /**
     * A map of renderer IDs to webgl buffer
     *
     * @private
     * @member {object<number, GLBuffer>}
     */
    this._glBuffers = {};

    this._updateID = 0;

    this.index = index;

    this.static = _static;

    this.id = UID++;

    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('disposeBuffer', 2);
};

// TODO could explore flagging only a partial upload?
/**
 * flags this buffer as requiring an upload to the GPU
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView} [data] the data to update in the buffer.
 */
Buffer.prototype.update = function update (data)
{
    this.data = data || this.data;
    this._updateID++;
};

/**
 * disposes WebGL resources that are connected to this geometry
 */
Buffer.prototype.dispose = function dispose ()
{
    this.disposeRunner.run(this, false);
};

/**
 * Destroys the buffer
 */
Buffer.prototype.destroy = function destroy ()
{
    this.dispose();

    this.data = null;
};

/**
 * Helper function that creates a buffer based on an array or TypedArray
 *
 * @static
 * @param {ArrayBufferView | number[]} data the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
 * @return {PIXI.Buffer} A new Buffer based on the data provided.
 */
Buffer.from = function from (data)
{
    if (data instanceof Array)
    {
        data = new Float32Array(data);
    }

    return new Buffer(data);
};

function getBufferType(array)
{
    if (array.BYTES_PER_ELEMENT === 4)
    {
        if (array instanceof Float32Array)
        {
            return 'Float32Array';
        }
        else if (array instanceof Uint32Array)
        {
            return 'Uint32Array';
        }

        return 'Int32Array';
    }
    else if (array.BYTES_PER_ELEMENT === 2)
    {
        if (array instanceof Uint16Array)
        {
            return 'Uint16Array';
        }
    }
    else if (array.BYTES_PER_ELEMENT === 1)
    {
        if (array instanceof Uint8Array)
        {
            return 'Uint8Array';
        }
    }

    // TODO map out the rest of the array elements!
    return null;
}

/* eslint-disable object-shorthand */
var map = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
};

function interleaveTypedArrays(arrays, sizes)
{
    var outSize = 0;
    var stride = 0;
    var views = {};

    for (var i = 0; i < arrays.length; i++)
    {
        stride += sizes[i];
        outSize += arrays[i].length;
    }

    var buffer = new ArrayBuffer(outSize * 4);

    var out = null;
    var littleOffset = 0;

    for (var i$1 = 0; i$1 < arrays.length; i$1++)
    {
        var size = sizes[i$1];
        var array = arrays[i$1];

        var type = getBufferType(array);

        if (!views[type])
        {
            views[type] = new map[type](buffer);
        }

        out = views[type];

        for (var j = 0; j < array.length; j++)
        {
            var indexStart = ((j / size | 0) * stride) + littleOffset;
            var index = j % size;

            out[indexStart + index] = array[j];
        }

        littleOffset += size;
    }

    return new Float32Array(buffer);
}

var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var UID$1 = 0;

/* eslint-disable object-shorthand */
var map$1 = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array,
};

/* eslint-disable max-len */

/**
 * The Geometry represents a model. It consists of two components:
 * - GeometryStyle - The structure of the model such as the attributes layout
 * - GeometryData - the data of the model - this consists of buffers.
 * This can include anything from positions, uvs, normals, colors etc.
 *
 * Geometry can be defined without passing in a style or data if required (thats how I prefer!)
 *
 * ```js
 * let geometry = new PIXI.Geometry();
 *
 * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);
 * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1],2)
 * geometry.addIndex([0,1,2,1,3,2])
 *
 * ```
 * @class
 * @memberof PIXI
 */
var Geometry = function Geometry(buffers, attributes)
{
    if ( buffers === void 0 ) buffers = [];
    if ( attributes === void 0 ) attributes = {};

    this.buffers = buffers;

    this.indexBuffer = null;

    this.attributes = attributes;

    /**
     * A map of renderer IDs to webgl VAOs
     *
     * @protected
     * @type {object}
     */
    this.glVertexArrayObjects = {};

    this.id = UID$1++;

    this.instanced = false;

    /**
     * Number of instances in this geometry, pass it to `GeometrySystem.draw()`
     * @member {number}
     * @default 1
     */
    this.instanceCount = 1;

    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('disposeGeometry', 2);

    /**
     * Count of existing (not destroyed) meshes that reference this geometry
     * @member {number}
     */
    this.refCount = 0;
};

/**
*
* Adds an attribute to the geometry
*
* @param {String} id - the name of the attribute (matching up to a shader)
* @param {PIXI.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
* @param {Number} [size=0] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
* @param {Boolean} [normalized=false] should the data be normalized.
* @param {Number} [type=PIXI.TYPES.FLOAT] what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
* @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
* @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
*
* @return {PIXI.Geometry} returns self, useful for chaining.
*/
Geometry.prototype.addAttribute = function addAttribute (id, buffer, size, normalized, type, stride, start, instance)
{
        if ( normalized === void 0 ) normalized = false;
        if ( instance === void 0 ) instance = false;

    if (!buffer)
    {
        throw new Error('You must pass a buffer when creating an attribute');
    }

    // check if this is a buffer!
    if (!buffer.data)
    {
        // its an array!
        if (buffer instanceof Array)
        {
            buffer = new Float32Array(buffer);
        }

        buffer = new Buffer(buffer);
    }

    var ids = id.split('|');

    if (ids.length > 1)
    {
        for (var i = 0; i < ids.length; i++)
        {
            this.addAttribute(ids[i], buffer, size, normalized, type);
        }

        return this;
    }

    var bufferIndex = this.buffers.indexOf(buffer);

    if (bufferIndex === -1)
    {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
    }

    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);

    // assuming that if there is instanced data then this will be drawn with instancing!
    this.instanced = this.instanced || instance;

    return this;
};

/**
 * returns the requested attribute
 *
 * @param {String} id  the name of the attribute required
 * @return {PIXI.Attribute} the attribute requested.
 */
Geometry.prototype.getAttribute = function getAttribute (id)
{
    return this.attributes[id];
};

/**
 * returns the requested buffer
 *
 * @param {String} id  the name of the buffer required
 * @return {PIXI.Buffer} the buffer requested.
 */
Geometry.prototype.getBuffer = function getBuffer (id)
{
    return this.buffers[this.getAttribute(id).buffer];
};

/**
*
* Adds an index buffer to the geometry
* The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
*
* @param {PIXI.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
* @return {PIXI.Geometry} returns self, useful for chaining.
*/
Geometry.prototype.addIndex = function addIndex (buffer)
{
    if (!buffer.data)
    {
        // its an array!
        if (buffer instanceof Array)
        {
            buffer = new Uint16Array(buffer);
        }

        buffer = new Buffer(buffer);
    }

    buffer.index = true;
    this.indexBuffer = buffer;

    if (this.buffers.indexOf(buffer) === -1)
    {
        this.buffers.push(buffer);
    }

    return this;
};

/**
 * returns the index buffer
 *
 * @return {PIXI.Buffer} the index buffer.
 */
Geometry.prototype.getIndex = function getIndex ()
{
    return this.indexBuffer;
};

/**
 * this function modifies the structure so that all current attributes become interleaved into a single buffer
 * This can be useful if your model remains static as it offers a little performance boost
 *
 * @return {PIXI.Geometry} returns self, useful for chaining.
 */
Geometry.prototype.interleave = function interleave ()
{
    // a simple check to see if buffers are already interleaved..
    if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) { return this; }

    // assume already that no buffers are interleaved
    var arrays = [];
    var sizes = [];
    var interleavedBuffer = new Buffer();
    var i;

    for (i in this.attributes)
    {
        var attribute = this.attributes[i];

        var buffer = this.buffers[attribute.buffer];

        arrays.push(buffer.data);

        sizes.push((attribute.size * byteSizeMap[attribute.type]) / 4);

        attribute.buffer = 0;
    }

    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);

    for (i = 0; i < this.buffers.length; i++)
    {
        if (this.buffers[i] !== this.indexBuffer)
        {
            this.buffers[i].destroy();
        }
    }

    this.buffers = [interleavedBuffer];

    if (this.indexBuffer)
    {
        this.buffers.push(this.indexBuffer);
    }

    return this;
};

Geometry.prototype.getSize = function getSize ()
{
    for (var i in this.attributes)
    {
        var attribute = this.attributes[i];
        var buffer = this.buffers[attribute.buffer];

        return buffer.data.length / ((attribute.stride / 4) || attribute.size);
    }

    return 0;
};

/**
 * disposes WebGL resources that are connected to this geometry
 */
Geometry.prototype.dispose = function dispose ()
{
    this.disposeRunner.run(this, false);
};

/**
 * Destroys the geometry.
 */
Geometry.prototype.destroy = function destroy ()
{
    this.dispose();

    this.buffers = null;
    this.indexBuffer.destroy();

    this.attributes = null;
};

/**
 * returns a clone of the geometry
 *
 * @returns {PIXI.Geometry} a new clone of this geometry
 */
Geometry.prototype.clone = function clone ()
{
    var geometry = new Geometry();

    for (var i = 0; i < this.buffers.length; i++)
    {
        geometry.buffers[i] = new Buffer(this.buffers[i].data.slice());
    }

    for (var i$1 in this.attributes)
    {
        var attrib = this.attributes[i$1];

        geometry.attributes[i$1] = new Attribute(
            attrib.buffer,
            attrib.size,
            attrib.normalized,
            attrib.type,
            attrib.stride,
            attrib.start,
            attrib.instance
        );
    }

    if (this.indexBuffer)
    {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.index = true;
    }

    return geometry;
};

/**
 * merges an array of geometries into a new single one
 * geometry attribute styles must match for this operation to work
 *
 * @param {PIXI.Geometry[]} geometries array of geometries to merge
 * @returns {PIXI.Geometry} shiny new geometry!
 */
Geometry.merge = function merge (geometries)
{
    // todo add a geometry check!
    // also a size check.. cant be too big!]

    var geometryOut = new Geometry();

    var arrays = [];
    var sizes = [];
    var offsets = [];

    var geometry;

    // pass one.. get sizes..
    for (var i = 0; i < geometries.length; i++)
    {
        geometry = geometries[i];

        for (var j = 0; j < geometry.buffers.length; j++)
        {
            sizes[j] = sizes[j] || 0;
            sizes[j] += geometry.buffers[j].data.length;
            offsets[j] = 0;
        }
    }

    // build the correct size arrays..
    for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++)
    {
        // TODO types!
        arrays[i$1] = new map$1[getBufferType(geometry.buffers[i$1].data)](sizes[i$1]);
        geometryOut.buffers[i$1] = new Buffer(arrays[i$1]);
    }

    // pass to set data..
    for (var i$2 = 0; i$2 < geometries.length; i$2++)
    {
        geometry = geometries[i$2];

        for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++)
        {
            arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]);
            offsets[j$1] += geometry.buffers[j$1].data.length;
        }
    }

    geometryOut.attributes = geometry.attributes;

    if (geometry.indexBuffer)
    {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.index = true;

        var offset = 0;
        var stride = 0;
        var offset2 = 0;
        var bufferIndexToCount = 0;

        // get a buffer
        for (var i$3 = 0; i$3 < geometry.buffers.length; i$3++)
        {
            if (geometry.buffers[i$3] !== geometry.indexBuffer)
            {
                bufferIndexToCount = i$3;
                break;
            }
        }

        // figure out the stride of one buffer..
        for (var i$4 in geometry.attributes)
        {
            var attribute = geometry.attributes[i$4];

            if ((attribute.buffer | 0) === bufferIndexToCount)
            {
                stride += ((attribute.size * byteSizeMap[attribute.type]) / 4);
            }
        }

        // time to off set all indexes..
        for (var i$5 = 0; i$5 < geometries.length; i$5++)
        {
            var indexBufferData = geometries[i$5].indexBuffer.data;

            for (var j$2 = 0; j$2 < indexBufferData.length; j$2++)
            {
                geometryOut.indexBuffer.data[j$2 + offset2] += offset;
            }

            offset += geometry.buffers[bufferIndexToCount].data.length / (stride);
            offset2 += indexBufferData.length;
        }
    }

    return geometryOut;
};

/**
 * Helper class to create a quad
 *
 * @class
 * @memberof PIXI
 */
var Quad = /*@__PURE__*/(function (Geometry) {
    function Quad()
    {
        Geometry.call(this);

        this.addAttribute('aVertexPosition', [
            0, 0,
            1, 0,
            1, 1,
            0, 1 ])
            .addIndex([0, 1, 3, 2]);
    }

    if ( Geometry ) Quad.__proto__ = Geometry;
    Quad.prototype = Object.create( Geometry && Geometry.prototype );
    Quad.prototype.constructor = Quad;

    return Quad;
}(Geometry));

/**
 * Helper class to create a quad with uvs like in v4
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Geometry
 */
var QuadUv = /*@__PURE__*/(function (Geometry) {
    function QuadUv()
    {
        Geometry.call(this);

        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([
            -1, -1,
            1, -1,
            1, 1,
            -1, 1 ]);

        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1 ]);

        this.vertexBuffer = new Buffer(this.vertices);
        this.uvBuffer = new Buffer(this.uvs);

        this.addAttribute('aVertexPosition', this.vertexBuffer)
            .addAttribute('aTextureCoord', this.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]);
    }

    if ( Geometry ) QuadUv.__proto__ = Geometry;
    QuadUv.prototype = Object.create( Geometry && Geometry.prototype );
    QuadUv.prototype.constructor = QuadUv;

    /**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */
    QuadUv.prototype.map = function map (targetTextureFrame, destinationFrame)
    {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;

        this.uvs[0] = x;
        this.uvs[1] = y;

        this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[3] = y;

        this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[5] = y + (destinationFrame.height / targetTextureFrame.height);

        this.uvs[6] = x;
        this.uvs[7] = y + (destinationFrame.height / targetTextureFrame.height);

        x = destinationFrame.x;
        y = destinationFrame.y;

        this.vertices[0] = x;
        this.vertices[1] = y;

        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;

        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;

        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;

        this.invalidate();

        return this;
    };

    /**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */
    QuadUv.prototype.invalidate = function invalidate ()
    {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;

        return this;
    };

    return QuadUv;
}(Geometry));

var UID$2 = 0;

/**
 * Uniform group holds uniform map and some ID's for work
 *
 * @class
 * @memberof PIXI
 */
var UniformGroup = function UniformGroup(uniforms, _static)
{
    /**
     * uniform values
     * @member {object}
     * @readonly
     */
    this.uniforms = uniforms;

    /**
     * Its a group and not a single uniforms
     * @member {boolean}
     * @readonly
     * @default true
     */
    this.group = true;

    // lets generate this when the shader ?
    this.syncUniforms = {};

    /**
     * dirty version
     * @protected
     * @member {number}
     */
    this.dirtyId = 0;

    /**
     * unique id
     * @protected
     * @member {number}
     */
    this.id = UID$2++;

    /**
     * Uniforms wont be changed after creation
     * @member {boolean}
     */
    this.static = !!_static;
};

UniformGroup.prototype.update = function update ()
{
    this.dirtyId++;
};

UniformGroup.prototype.add = function add (name, uniforms, _static)
{
    this.uniforms[name] = new UniformGroup(uniforms, _static);
};

UniformGroup.from = function from (uniforms, _static)
{
    return new UniformGroup(uniforms, _static);
};

/**
 * System plugin to the renderer to manage filter states.
 *
 * @class
 * @private
 */
var FilterState = function FilterState()
{
    this.renderTexture = null;

    /**
     * Target of the filters
     * We store for case when custom filter wants to know the element it was applied on
     * @member {PIXI.DisplayObject}
     * @private
     */
    this.target = null;

    /**
     * Compatibility with PixiJS v4 filters
     * @member {boolean}
     * @default false
     * @private
     */
    this.legacy = false;

    /**
     * Resolution of filters
     * @member {number}
     * @default 1
     * @private
     */
    this.resolution = 1;

    // next three fields are created only for root
    // re-assigned for everything else

    /**
     * Source frame
     * @member {PIXI.Rectangle}
     * @private
     */
    this.sourceFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();

    /**
     * Destination frame
     * @member {PIXI.Rectangle}
     * @private
     */
    this.destinationFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();

    /**
     * Collection of filters
     * @member {PIXI.Filter[]}
     * @private
     */
    this.filters = [];
};

/**
 * clears the state
 * @private
 */
FilterState.prototype.clear = function clear ()
{
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
};

/**
 * System plugin to the renderer to manage the filters.
 *
 * @class
 * @memberof PIXI.systems
 * @extends PIXI.System
 */
var FilterSystem = /*@__PURE__*/(function (System) {
    function FilterSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */
        this.defaultFilterStack = [{}];

        /**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */
        this.texturePool = new RenderTexturePool();

        this.texturePool.setScreenSize(renderer.view);

        /**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */
        this.statePool = [];

        /**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */
        this.quad = new Quad();

        /**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */
        this.quadUv = new QuadUv();

        /**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */
        this.tempRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();

        /**
         * Active state
         * @member {object}
         */
        this.activeState = {};

        /**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */
        this.globalUniforms = new UniformGroup({
            outputFrame: this.tempRect,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,

            // legacy variables
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
        }, true);

        this._pixelsWidth = renderer.view.width;
        this._pixelsHeight = renderer.view.height;
    }

    if ( System ) FilterSystem.__proto__ = System;
    FilterSystem.prototype = Object.create( System && System.prototype );
    FilterSystem.prototype.constructor = FilterSystem;

    /**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */
    FilterSystem.prototype.push = function push (target, filters)
    {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState();

        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;

        for (var i = 1; i < filters.length; i++)
        {
            var filter =  filters[i];

            // lets use the lowest resolution..
            resolution = Math.min(resolution, filter.resolution);
            // and the largest amount of padding!
            padding = Math.max(padding, filter.padding);
            // only auto fit if all filters are autofit
            autoFit = autoFit || filter.autoFit;

            legacy = legacy || filter.legacy;
        }

        if (filterStack.length === 1)
        {
            this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }

        filterStack.push(state);

        state.resolution = resolution;

        state.legacy = legacy;

        state.target = target;

        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));

        state.sourceFrame.pad(padding);
        if (autoFit)
        {
            state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }

        // round to whole number based on resolution
        state.sourceFrame.ceil(resolution);

        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;

        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;

        state.renderTexture.filterFrame = state.sourceFrame;

        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame);// /, state.destinationFrame);
        renderer.renderTexture.clear();
    };

    /**
     * Pops off the filter and applies it.
     *
     */
    FilterSystem.prototype.pop = function pop ()
    {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;

        this.activeState = state;

        var globalUniforms = this.globalUniforms.uniforms;

        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;

        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;

        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1.0 / inputSize[0];
        inputSize[3] = 1.0 / inputSize[1];

        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1.0 / inputPixel[0];
        inputPixel[3] = 1.0 / inputPixel[1];

        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);
        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);

        // only update the rect if its legacy..
        if (state.legacy)
        {
            var filterArea = globalUniforms.filterArea;

            filterArea[0] = state.destinationFrame.width;
            filterArea[1] = state.destinationFrame.height;
            filterArea[2] = state.sourceFrame.x;
            filterArea[3] = state.sourceFrame.y;

            globalUniforms.filterClamp = globalUniforms.inputClamp;
        }

        this.globalUniforms.update();

        var lastState = filterStack[filterStack.length - 1];

        if (filters.length === 1)
        {
            filters[0].apply(this, state.renderTexture, lastState.renderTexture, false, state);

            this.returnFilterTexture(state.renderTexture);
        }
        else
        {
            var flip = state.renderTexture;
            var flop = this.getOptimalFilterTexture(
                flip.width,
                flip.height,
                state.resolution
            );

            flop.filterFrame = flip.filterFrame;

            var i = 0;

            for (i = 0; i < filters.length - 1; ++i)
            {
                filters[i].apply(this, flip, flop, true, state);

                var t = flip;

                flip = flop;
                flop = t;
            }

            filters[i].apply(this, flip, lastState.renderTexture, false, state);

            this.returnFilterTexture(flip);
            this.returnFilterTexture(flop);
        }

        state.clear();
        this.statePool.push(state);
    };

    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    FilterSystem.prototype.applyFilter = function applyFilter (filter, input, output, clear)
    {
        var renderer = this.renderer;

        renderer.renderTexture.bind(output, output ? output.filterFrame : null);

        if (clear)
        {
            // gl.disable(gl.SCISSOR_TEST);
            renderer.renderTexture.clear();
            // gl.enable(gl.SCISSOR_TEST);
        }

        // set the uniforms..
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;

        // TODO make it so that the order of this does not matter..
        // because it does at the moment cos of global uniforms.
        // they need to get resynced

        renderer.state.set(filter.state);
        renderer.shader.bind(filter);

        if (filter.legacy)
        {
            this.quadUv.map(input._frame, input.filterFrame);

            renderer.geometry.bind(this.quadUv);
            renderer.geometry.draw(_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.DRAW_MODES.TRIANGLES);
        }
        else
        {
            renderer.geometry.bind(this.quad);
            renderer.geometry.draw(_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.DRAW_MODES.TRIANGLE_STRIP);
        }
    };

    /**
     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
     *
     * Use `outputMatrix * vTextureCoord` in the shader.
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    FilterSystem.prototype.calculateSpriteMatrix = function calculateSpriteMatrix (outputMatrix, sprite)
    {
        var ref = this.activeState;
        var sourceFrame = ref.sourceFrame;
        var destinationFrame = ref.destinationFrame;
        var ref$1 = sprite._texture;
        var orig = ref$1.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0,
            destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(_pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix.TEMP_MATRIX);

        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

        return mappedMatrix;
    };

    /**
     * Destroys this Filter System.
     */
    FilterSystem.prototype.destroy = function destroy ()
    {
        // Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem
        this.texturePool.clear(false);
    };

    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */
    FilterSystem.prototype.getOptimalFilterTexture = function getOptimalFilterTexture (minWidth, minHeight, resolution)
    {
        if ( resolution === void 0 ) resolution = 1;

        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
    };

    /**
     * Gets extra render texture to use inside current filter
     * To be compliant with older filters, you can use params in any order
     *
     * @param {PIXI.RenderTexture} [input] renderTexture from which size and resolution will be copied
     * @param {number} [resolution] override resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */
    FilterSystem.prototype.getFilterTexture = function getFilterTexture (input, resolution)
    {
        if (typeof input === 'number')
        {
            var swap = input;

            input = resolution;
            resolution = swap;
        }

        input = input || this.activeState.renderTexture;

        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);

        filterTexture.filterFrame = input.filterFrame;

        return filterTexture;
    };

    /**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */
    FilterSystem.prototype.returnFilterTexture = function returnFilterTexture (renderTexture)
    {
        this.texturePool.returnTexture(renderTexture);
    };

    /**
     * Empties the texture pool.
     */
    FilterSystem.prototype.emptyPool = function emptyPool ()
    {
        this.texturePool.clear(true);
    };

    /**
     * calls `texturePool.resize()`, affects fullScreen renderTextures
     */
    FilterSystem.prototype.resize = function resize ()
    {
        this.texturePool.setScreenSize(this.renderer.view);
    };

    return FilterSystem;
}(System));

/**
 * Base for a common object renderer that can be used as a
 * system renderer plugin.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI
 */
var ObjectRenderer = function ObjectRenderer(renderer)
{
    /**
     * The renderer this manager works for.
     *
     * @member {PIXI.Renderer}
     */
    this.renderer = renderer;
};

/**
 * Stub method that should be used to empty the current
 * batch by rendering objects now.
 */
ObjectRenderer.prototype.flush = function flush ()
{
    // flush!
};

/**
 * Generic destruction method that frees all resources. This
 * should be called by subclasses.
 */
ObjectRenderer.prototype.destroy = function destroy ()
{
    this.renderer = null;
};

/**
 * Stub method that initializes any state required before
 * rendering starts. It is different from the `prerender`
 * signal, which occurs every frame, in that it is called
 * whenever an object requests _this_ renderer specifically.
 */
ObjectRenderer.prototype.start = function start ()
{
    // set the shader..
};

/**
 * Stops the renderer. It should free up any state and
 * become dormant.
 */
ObjectRenderer.prototype.stop = function stop ()
{
    this.flush();
};

/**
 * Keeps the object to render. It doesn't have to be
 * rendered immediately.
 *
 * @param {PIXI.DisplayObject} object - The object to render.
 */
ObjectRenderer.prototype.render = function render (object) // eslint-disable-line no-unused-vars
{
    // render the object
};

/**
 * System plugin to the renderer to manage batching.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var BatchSystem = /*@__PURE__*/(function (System) {
    function BatchSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.emptyRenderer = new ObjectRenderer(renderer);

        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.currentRenderer = this.emptyRenderer;
    }

    if ( System ) BatchSystem.__proto__ = System;
    BatchSystem.prototype = Object.create( System && System.prototype );
    BatchSystem.prototype.constructor = BatchSystem;

    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */
    BatchSystem.prototype.setObjectRenderer = function setObjectRenderer (objectRenderer)
    {
        if (this.currentRenderer === objectRenderer)
        {
            return;
        }

        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;

        this.currentRenderer.start();
    };

    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */
    BatchSystem.prototype.flush = function flush ()
    {
        this.setObjectRenderer(this.emptyRenderer);
    };

    /**
     * Reset the system to an empty renderer
     */
    BatchSystem.prototype.reset = function reset ()
    {
        this.setObjectRenderer(this.emptyRenderer);
    };

    return BatchSystem;
}(System));

/**
 * The maximum support for using WebGL. If a device does not
 * support WebGL version, for instance WebGL 2, it will still
 * attempt to fallback support to WebGL 1. If you want to
 * explicitly remove feature support to target a more stable
 * baseline, prefer a lower environment.
 *
 * Due to {@link https://bugs.chromium.org/p/chromium/issues/detail?id=934823|bug in chromium}
 * we disable webgl2 by default for all non-apple mobile devices.
 *
 * @static
 * @name PREFER_ENV
 * @memberof PIXI.settings
 * @type {number}
 * @default PIXI.ENV.WEBGL2
 */
_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.isMobile.any ? _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL : _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL2;

var CONTEXT_UID = 0;

/**
 * System plugin to the renderer to manage the context.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var ContextSystem = /*@__PURE__*/(function (System) {
    function ContextSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */
        this.webGLVersion = 1;

        /**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension
         */
        this.extensions = {};

        // Bind functions
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);

        renderer.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
    }

    if ( System ) ContextSystem.__proto__ = System;
    ContextSystem.prototype = Object.create( System && System.prototype );
    ContextSystem.prototype.constructor = ContextSystem;

    var prototypeAccessors = { isLost: { configurable: true } };

    /**
     * `true` if the context is lost
     * @member {boolean}
     * @readonly
     */
    prototypeAccessors.isLost.get = function ()
    {
        return (!this.gl || this.gl.isContextLost());
    };

    /**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl new webgl context
     */
    ContextSystem.prototype.contextChange = function contextChange (gl)
    {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID++;

        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context'))
        {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }
    };

    /**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    ContextSystem.prototype.initFromContext = function initFromContext (gl)
    {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID++;
        this.renderer.runners.contextChange.run(gl);
    };

    /**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */
    ContextSystem.prototype.initFromOptions = function initFromOptions (options)
    {
        var gl = this.createContext(this.renderer.view, options);

        this.initFromContext(gl);
    };

    /**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */
    ContextSystem.prototype.createContext = function createContext (canvas, options)
    {
        var gl;

        if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV >= _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL2)
        {
            gl = canvas.getContext('webgl2', options);
        }

        if (gl)
        {
            this.webGLVersion = 2;
        }
        else
        {
            this.webGLVersion = 1;

            gl = canvas.getContext('webgl', options)
            || canvas.getContext('experimental-webgl', options);

            if (!gl)
            {
                // fail, not able to get a context
                throw new Error('This browser does not support WebGL. Try using the canvas renderer');
            }
        }

        this.gl = gl;

        this.getExtensions();

        return gl;
    };

    /**
     * Auto-populate the extensions
     *
     * @protected
     */
    ContextSystem.prototype.getExtensions = function getExtensions ()
    {
        // time to set up default extensions that Pixi uses.
        var ref = this;
        var gl = ref.gl;

        if (this.webGLVersion === 1)
        {
            Object.assign(this.extensions, {
                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),
                depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'),
                loseContext: gl.getExtension('WEBGL_lose_context'),
                vertexArrayObject: gl.getExtension('OES_vertex_array_object')
                    || gl.getExtension('MOZ_OES_vertex_array_object')
                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),
                anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),
                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),
                // Floats and half-floats
                floatTexture: gl.getExtension('OES_texture_float'),
                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),
                textureHalfFloat: gl.getExtension('OES_texture_half_float'),
                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),
            });
        }
        else if (this.webGLVersion === 2)
        {
            Object.assign(this.extensions, {
                anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),
                // Floats and half-floats
                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),
                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),
            });
        }
    };

    /**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */
    ContextSystem.prototype.handleContextLost = function handleContextLost (event)
    {
        event.preventDefault();
    };

    /**
     * Handles a restored webgl context
     *
     * @protected
     */
    ContextSystem.prototype.handleContextRestored = function handleContextRestored ()
    {
        this.renderer.runners.contextChange.run(this.gl);
    };

    ContextSystem.prototype.destroy = function destroy ()
    {
        var view = this.renderer.view;

        // remove listeners
        view.removeEventListener('webglcontextlost', this.handleContextLost);
        view.removeEventListener('webglcontextrestored', this.handleContextRestored);

        this.gl.useProgram(null);

        if (this.extensions.loseContext)
        {
            this.extensions.loseContext.loseContext();
        }
    };

    /**
     * Handle the post-render runner event
     *
     * @protected
     */
    ContextSystem.prototype.postrender = function postrender ()
    {
        this.gl.flush();
    };

    /**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */
    ContextSystem.prototype.validateContext = function validateContext (gl)
    {
        var attributes = gl.getContextAttributes();

        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil)
        {
            /* eslint-disable max-len */

            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */

            /* eslint-enable max-len */
        }
    };

    Object.defineProperties( ContextSystem.prototype, prototypeAccessors );

    return ContextSystem;
}(System));

/**
 * System plugin to the renderer to manage framebuffers.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var FramebufferSystem = /*@__PURE__*/(function (System) {
    function FramebufferSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */
        this.managedFramebuffers = [];

        /**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */
        this.unknownFramebuffer = new Framebuffer(10, 10);
    }

    if ( System ) FramebufferSystem.__proto__ = System;
    FramebufferSystem.prototype = Object.create( System && System.prototype );
    FramebufferSystem.prototype.constructor = FramebufferSystem;

    var prototypeAccessors = { size: { configurable: true } };

    /**
     * Sets up the renderer context and necessary buffers.
     */
    FramebufferSystem.prototype.contextChange = function contextChange ()
    {
        var gl = this.gl = this.renderer.gl;

        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;

        this.disposeAll(true);

        // webgl2
        if (this.renderer.context.webGLVersion === 1)
        {
            // webgl 1!
            var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
            var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;

            if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL_LEGACY)
            {
                nativeDrawBuffersExtension = null;
                nativeDepthTextureExtension = null;
            }

            if (nativeDrawBuffersExtension)
            {
                gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures); };
            }
            else
            {
                this.hasMRT = false;
                gl.drawBuffers = function () {
                    // empty
                };
            }

            if (!nativeDepthTextureExtension)
            {
                this.writeDepthTexture = false;
            }
        }
    };

    /**
     * Bind a framebuffer
     *
     * @param {PIXI.Framebuffer} framebuffer
     * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
     */
    FramebufferSystem.prototype.bind = function bind (framebuffer, frame)
    {
        var ref = this;
        var gl = ref.gl;

        if (framebuffer)
        {
            // TODO caching layer!

            var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);

            if (this.current !== framebuffer)
            {
                this.current = framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            }
            // make sure all textures are unbound..

            // now check for updates...
            if (fbo.dirtyId !== framebuffer.dirtyId)
            {
                fbo.dirtyId = framebuffer.dirtyId;

                if (fbo.dirtyFormat !== framebuffer.dirtyFormat)
                {
                    fbo.dirtyFormat = framebuffer.dirtyFormat;
                    this.updateFramebuffer(framebuffer);
                }
                else if (fbo.dirtySize !== framebuffer.dirtySize)
                {
                    fbo.dirtySize = framebuffer.dirtySize;
                    this.resizeFramebuffer(framebuffer);
                }
            }

            for (var i = 0; i < framebuffer.colorTextures.length; i++)
            {
                if (framebuffer.colorTextures[i].texturePart)
                {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i].texture);
                }
                else
                {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i]);
                }
            }

            if (framebuffer.depthTexture)
            {
                this.renderer.texture.unbind(framebuffer.depthTexture);
            }

            if (frame)
            {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else
            {
                this.setViewport(0, 0, framebuffer.width, framebuffer.height);
            }
        }
        else
        {
            if (this.current)
            {
                this.current = null;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }

            if (frame)
            {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else
            {
                this.setViewport(0, 0, this.renderer.width, this.renderer.height);
            }
        }
    };

    /**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */
    FramebufferSystem.prototype.setViewport = function setViewport (x, y, width, height)
    {
        var v = this.viewport;

        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y)
        {
            v.x = x;
            v.y = y;
            v.width = width;
            v.height = height;

            this.gl.viewport(x, y, width, height);
        }
    };

    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     *
     * @member {object}
     * @readonly
     */
    prototypeAccessors.size.get = function ()
    {
        if (this.current)
        {
            // TODO store temp
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }

        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    };

    /**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     */
    FramebufferSystem.prototype.clear = function clear (r, g, b, a)
    {
        var ref = this;
        var gl = ref.gl;

        // TODO clear color can be set only one right?
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };

    /**
     * Initialize framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    FramebufferSystem.prototype.initFramebuffer = function initFramebuffer (framebuffer)
    {
        var ref = this;
        var gl = ref.gl;

        // TODO - make this a class?
        var fbo = {
            framebuffer: gl.createFramebuffer(),
            stencil: null,
            dirtyId: 0,
            dirtyFormat: 0,
            dirtySize: 0,
        };

        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;

        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);

        return fbo;
    };

    /**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    FramebufferSystem.prototype.resizeFramebuffer = function resizeFramebuffer (framebuffer)
    {
        var ref = this;
        var gl = ref.gl;

        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];

        if (fbo.stencil)
        {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }

        var colorTextures = framebuffer.colorTextures;

        for (var i = 0; i < colorTextures.length; i++)
        {
            this.renderer.texture.bind(colorTextures[i], 0);
        }

        if (framebuffer.depthTexture)
        {
            this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
    };

    /**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    FramebufferSystem.prototype.updateFramebuffer = function updateFramebuffer (framebuffer)
    {
        var ref = this;
        var gl = ref.gl;

        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];

        // bind the color texture
        var colorTextures = framebuffer.colorTextures;

        var count = colorTextures.length;

        if (!gl.drawBuffers)
        {
            count = Math.min(count, 1);
        }

        var activeTextures = [];

        for (var i = 0; i < count; i++)
        {
            var texture = framebuffer.colorTextures[i];

            if (texture.texturePart)
            {
                this.renderer.texture.bind(texture.texture, 0);

                gl.framebufferTexture2D(gl.FRAMEBUFFER,
                    gl.COLOR_ATTACHMENT0 + i,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side,
                    texture.texture._glTextures[this.CONTEXT_UID].texture,
                    0);
            }
            else
            {
                this.renderer.texture.bind(texture, 0);

                gl.framebufferTexture2D(gl.FRAMEBUFFER,
                    gl.COLOR_ATTACHMENT0 + i,
                    gl.TEXTURE_2D,
                    texture._glTextures[this.CONTEXT_UID].texture,
                    0);
            }

            activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }

        if (activeTextures.length > 1)
        {
            gl.drawBuffers(activeTextures);
        }

        if (framebuffer.depthTexture)
        {
            var writeDepthTexture = this.writeDepthTexture;

            if (writeDepthTexture)
            {
                var depthTexture = framebuffer.depthTexture;

                this.renderer.texture.bind(depthTexture, 0);

                gl.framebufferTexture2D(gl.FRAMEBUFFER,
                    gl.DEPTH_ATTACHMENT,
                    gl.TEXTURE_2D,
                    depthTexture._glTextures[this.CONTEXT_UID].texture,
                    0);
            }
        }

        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth))
        {
            fbo.stencil = gl.createRenderbuffer();

            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);

            // TODO.. this is depth AND stencil?
            if (!framebuffer.depthTexture)
            { // you can't have both, so one should take priority if enabled
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
            // fbo.enableStencil();
        }
    };

    /**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    FramebufferSystem.prototype.disposeFramebuffer = function disposeFramebuffer (framebuffer, contextLost)
    {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;

        if (!fbo)
        {
            return;
        }

        delete framebuffer.glFramebuffers[this.CONTEXT_UID];

        var index = this.managedFramebuffers.indexOf(framebuffer);

        if (index >= 0)
        {
            this.managedFramebuffers.splice(index, 1);
        }

        framebuffer.disposeRunner.remove(this);

        if (!contextLost)
        {
            gl.deleteFramebuffer(fbo.framebuffer);
            if (fbo.stencil)
            {
                gl.deleteRenderbuffer(fbo.stencil);
            }
        }
    };

    /**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    FramebufferSystem.prototype.disposeAll = function disposeAll (contextLost)
    {
        var list = this.managedFramebuffers;

        this.managedFramebuffers = [];

        for (var i = 0; i < list.length; i++)
        {
            this.disposeFramebuffer(list[i], contextLost);
        }
    };

    /**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */
    FramebufferSystem.prototype.reset = function reset ()
    {
        this.current = this.unknownFramebuffer;
        this.viewport = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();
    };

    Object.defineProperties( FramebufferSystem.prototype, prototypeAccessors );

    return FramebufferSystem;
}(System));

var GLBuffer = function GLBuffer(buffer)
{
    this.buffer = buffer;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
};

var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };

/**
 * System plugin to the renderer to manage geometry.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var GeometrySystem = /*@__PURE__*/(function (System) {
    function GeometrySystem(renderer)
    {
        System.call(this, renderer);

        this._activeGeometry = null;
        this._activeVao = null;

        /**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */
        this.hasVao = true;

        /**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */
        this.hasInstance = true;

        /**
         * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`
         * @member {boolean}
         * @readonly
         */
        this.canUseUInt32ElementIndex = false;

        /**
         * A cache of currently bound buffer,
         * contains only two members with keys ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER
         * @member {Object.<number, PIXI.Buffer>}
         * @readonly
         */
        this.boundBuffers = {};

        /**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedGeometries = {};

        /**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedBuffers = {};
    }

    if ( System ) GeometrySystem.__proto__ = System;
    GeometrySystem.prototype = Object.create( System && System.prototype );
    GeometrySystem.prototype.constructor = GeometrySystem;

    /**
     * Sets up the renderer context and necessary buffers.
     */
    GeometrySystem.prototype.contextChange = function contextChange ()
    {
        this.disposeAll(true);

        var gl = this.gl = this.renderer.gl;
        var context = this.renderer.context;

        this.CONTEXT_UID = this.renderer.CONTEXT_UID;

        // webgl2
        if (!gl.createVertexArray)
        {
            // webgl 1!
            var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;

            if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL_LEGACY)
            {
                nativeVaoExtension = null;
            }

            if (nativeVaoExtension)
            {
                gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES(); };

                gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao); };

                gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao); };
            }
            else
            {
                this.hasVao = false;
                gl.createVertexArray = function () {
                    // empty
                };

                gl.bindVertexArray = function () {
                    // empty
                };

                gl.deleteVertexArray = function () {
                    // empty
                };
            }
        }

        if (!gl.vertexAttribDivisor)
        {
            var instanceExt = gl.getExtension('ANGLE_instanced_arrays');

            if (instanceExt)
            {
                gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b); };

                gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e); };

                gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d); };
            }
            else
            {
                this.hasInstance = false;
            }
        }

        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
    };

    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     *
     * @param {PIXI.Geometry} geometry instance of geometry to bind
     * @param {PIXI.Shader} [shader] instance of shader to use vao for
     */
    GeometrySystem.prototype.bind = function bind (geometry, shader)
    {
        shader = shader || this.renderer.shader.shader;

        var ref = this;
        var gl = ref.gl;

        // not sure the best way to address this..
        // currently different shaders require different VAOs for the same geometry
        // Still mulling over the best way to solve this one..
        // will likely need to modify the shader attribute locations at run time!
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];

        if (!vaos)
        {
            this.managedGeometries[geometry.id] = geometry;
            geometry.disposeRunner.add(this);
            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }

        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);

        this._activeGeometry = geometry;

        if (this._activeVao !== vao)
        {
            this._activeVao = vao;

            if (this.hasVao)
            {
                gl.bindVertexArray(vao);
            }
            else
            {
                this.activateVao(geometry, shader.program);
            }
        }

        // TODO - optimise later!
        // don't need to loop through if nothing changed!
        // maybe look to add an 'autoupdate' to geometry?
        this.updateBuffers();
    };

    /**
     * Reset and unbind any active VAO and geometry
     */
    GeometrySystem.prototype.reset = function reset ()
    {
        this.unbind();
    };

    /**
     * Update buffers
     * @protected
     */
    GeometrySystem.prototype.updateBuffers = function updateBuffers ()
    {
        var geometry = this._activeGeometry;
        var ref = this;
        var gl = ref.gl;

        for (var i = 0; i < geometry.buffers.length; i++)
        {
            var buffer = geometry.buffers[i];

            var glBuffer = buffer._glBuffers[this.CONTEXT_UID];

            if (buffer._updateID !== glBuffer.updateID)
            {
                glBuffer.updateID = buffer._updateID;

                // TODO can cache this on buffer! maybe added a getter / setter?
                var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;

                // TODO this could change if the VAO changes...
                // need to come up with a better way to cache..
                // if (this.boundBuffers[type] !== glBuffer)
                // {
                // this.boundBuffers[type] = glBuffer;
                gl.bindBuffer(type, glBuffer.buffer);
                // }

                this._boundBuffer = glBuffer;

                if (glBuffer.byteLength >= buffer.data.byteLength)
                {
                    // offset is always zero for now!
                    gl.bufferSubData(type, 0, buffer.data);
                }
                else
                {
                    var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;

                    glBuffer.byteLength = buffer.data.byteLength;
                    gl.bufferData(type, buffer.data, drawType);
                }
            }
        }
    };

    /**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */
    GeometrySystem.prototype.checkCompatibility = function checkCompatibility (geometry, program)
    {
        // geometry must have at least all the attributes that the shader requires.
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;

        for (var j in shaderAttributes)
        {
            if (!geometryAttributes[j])
            {
                throw new Error(("shader and geometry incompatible, geometry missing the \"" + j + "\" attribute"));
            }
        }
    };

    /**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry to get signature from
     * @param {PIXI.Program} program to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */
    GeometrySystem.prototype.getSignature = function getSignature (geometry, program)
    {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;

        var strings = ['g', geometry.id];

        for (var i in attribs)
        {
            if (shaderAttributes[i])
            {
                strings.push(i);
            }
        }

        return strings.join('-');
    };

    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     */
    GeometrySystem.prototype.initGeometryVao = function initGeometryVao (geometry, program)
    {
        this.checkCompatibility(geometry, program);

        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;

        var signature = this.getSignature(geometry, program);

        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];

        var vao = vaoObjectHash[signature];

        if (vao)
        {
            // this will give us easy access to the vao
            vaoObjectHash[program.id] = vao;

            return vao;
        }

        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};

        for (var j in buffers)
        {
            tempStride[j] = 0;
            tempStart[j] = 0;
        }

        for (var j$1 in attributes)
        {
            if (!attributes[j$1].size && program.attributeData[j$1])
            {
                attributes[j$1].size = program.attributeData[j$1].size;
            }
            else if (!attributes[j$1].size)
            {
                console.warn(("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)"));  // eslint-disable-line
            }

            tempStride[attributes[j$1].buffer] += attributes[j$1].size * byteSizeMap$1[attributes[j$1].type];
        }

        for (var j$2 in attributes)
        {
            var attribute = attributes[j$2];
            var attribSize = attribute.size;

            if (attribute.stride === undefined)
            {
                if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type])
                {
                    attribute.stride = 0;
                }
                else
                {
                    attribute.stride = tempStride[attribute.buffer];
                }
            }

            if (attribute.start === undefined)
            {
                attribute.start = tempStart[attribute.buffer];

                tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
            }
        }

        vao = gl.createVertexArray();

        gl.bindVertexArray(vao);

        // first update - and create the buffers!
        // only create a gl buffer if it actually gets
        for (var i = 0; i < buffers.length; i++)
        {
            var buffer = buffers[i];

            if (!buffer._glBuffers[CONTEXT_UID])
            {
                buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
                this.managedBuffers[buffer.id] = buffer;
                buffer.disposeRunner.add(this);
            }

            buffer._glBuffers[CONTEXT_UID].refCount++;
        }

        // TODO - maybe make this a data object?
        // lets wait to see if we need to first!

        this.activateVao(geometry, program);

        this._activeVao = vao;

        // add it to the cache!
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;

        return vao;
    };

    /**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer buffer with data
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    GeometrySystem.prototype.disposeBuffer = function disposeBuffer (buffer, contextLost)
    {
        if (!this.managedBuffers[buffer.id])
        {
            return;
        }

        delete this.managedBuffers[buffer.id];

        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;

        buffer.disposeRunner.remove(this);

        if (!glBuffer)
        {
            return;
        }

        if (!contextLost)
        {
            gl.deleteBuffer(glBuffer.buffer);
        }

        delete buffer._glBuffers[this.CONTEXT_UID];
    };

    /**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    GeometrySystem.prototype.disposeGeometry = function disposeGeometry (geometry, contextLost)
    {
        if (!this.managedGeometries[geometry.id])
        {
            return;
        }

        delete this.managedGeometries[geometry.id];

        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;

        geometry.disposeRunner.remove(this);

        if (!vaos)
        {
            return;
        }

        for (var i = 0; i < buffers.length; i++)
        {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];

            buf.refCount--;
            if (buf.refCount === 0 && !contextLost)
            {
                this.disposeBuffer(buffers[i], contextLost);
            }
        }

        if (!contextLost)
        {
            for (var vaoId in vaos)
            {
                // delete only signatures, everything else are copies
                if (vaoId[0] === 'g')
                {
                    var vao = vaos[vaoId];

                    if (this._activeVao === vao)
                    {
                        this.unbind();
                    }
                    gl.deleteVertexArray(vao);
                }
            }
        }

        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    };

    /**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] If context was lost, we suppress `gl.delete` calls
     */
    GeometrySystem.prototype.disposeAll = function disposeAll (contextLost)
    {
        var all = Object.keys(this.managedGeometries);

        for (var i = 0; i < all.length; i++)
        {
            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i$1 = 0; i$1 < all.length; i$1++)
        {
            this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost);
        }
    };

    /**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */
    GeometrySystem.prototype.activateVao = function activateVao (geometry, program)
    {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;

        if (geometry.indexBuffer)
        {
            // first update the index buffer if we have one..
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }

        var lastBuffer = null;

        // add a new one!
        for (var j in attributes)
        {
            var attribute = attributes[j];
            var buffer = buffers[attribute.buffer];
            var glBuffer = buffer._glBuffers[CONTEXT_UID];

            if (program.attributeData[j])
            {
                if (lastBuffer !== glBuffer)
                {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);

                    lastBuffer = glBuffer;
                }

                var location = program.attributeData[j].location;

                // TODO introduce state again
                // we can optimise this for older devices that have no VAOs
                gl.enableVertexAttribArray(location);

                gl.vertexAttribPointer(location,
                    attribute.size,
                    attribute.type || gl.FLOAT,
                    attribute.normalized,
                    attribute.stride,
                    attribute.start);

                if (attribute.instance)
                {
                    // TODO calculate instance count based of this...
                    if (this.hasInstance)
                    {
                        gl.vertexAttribDivisor(location, 1);
                    }
                    else
                    {
                        throw new Error('geometry error, GPU Instancing is not supported on this device');
                    }
                }
            }
        }
    };

    /**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */
    GeometrySystem.prototype.draw = function draw (type, size, start, instanceCount)
    {
        var ref = this;
        var gl = ref.gl;
        var geometry = this._activeGeometry;

        // TODO.. this should not change so maybe cache the function?

        if (geometry.indexBuffer)
        {
            var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;

            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))
            {
                if (geometry.instanced)
                {
                    /* eslint-disable max-len */
                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
                    /* eslint-enable max-len */
                }
                else
                {
                    /* eslint-disable max-len */
                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
                    /* eslint-enable max-len */
                }
            }
            else
            {
                console.warn('unsupported index buffer type: uint32');
            }
        }
        else if (geometry.instanced)
        {
            // TODO need a better way to calculate size..
            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        }
        else
        {
            gl.drawArrays(type, start, size || geometry.getSize());
        }

        return this;
    };

    /**
     * Unbind/reset everything
     * @protected
     */
    GeometrySystem.prototype.unbind = function unbind ()
    {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
    };

    return GeometrySystem;
}(System));

/**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations)
{
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);

    // optionally, set the attributes manually for the program rather than letting WebGL decide..
    if (attributeLocations)
    {
        for (var i in attributeLocations)
        {
            gl.bindAttribLocation(program, attributeLocations[i], i);
        }
    }

    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return program;
}

/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
function compileShader(gl, type, src)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.warn(src);
        console.error(gl.getShaderInfoLog(shader));

        return null;
    }

    return shader;
}

/**
 * @method defaultValue
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 * @private
 */
function defaultValue(type, size)
{
    switch (type)
    {
        case 'float':
            return 0;

        case 'vec2':
            return new Float32Array(2 * size);

        case 'vec3':
            return new Float32Array(3 * size);

        case 'vec4':
            return new Float32Array(4 * size);

        case 'int':
        case 'sampler2D':
        case 'sampler2DArray':
            return 0;

        case 'ivec2':
            return new Int32Array(2 * size);

        case 'ivec3':
            return new Int32Array(3 * size);

        case 'ivec4':
            return new Int32Array(4 * size);

        case 'bool':
            return false;

        case 'bvec2':

            return booleanArray(2 * size);

        case 'bvec3':
            return booleanArray(3 * size);

        case 'bvec4':
            return booleanArray(4 * size);

        case 'mat2':
            return new Float32Array([1, 0,
                0, 1]);

        case 'mat3':
            return new Float32Array([1, 0, 0,
                0, 1, 0,
                0, 0, 1]);

        case 'mat4':
            return new Float32Array([1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1]);
    }

    return null;
}

function booleanArray(size)
{
    var array = new Array(size);

    for (var i = 0; i < array.length; i++)
    {
        array[i] = false;
    }

    return array;
}

var unknownContext = {};
var context = unknownContext;

/**
 * returns a little WebGL context to use for program inspection.
 *
 * @static
 * @private
 * @returns {webGL-context} a gl context to test with
 */
function getTestContext()
{
    if (context === unknownContext)
    {
        var canvas = document.createElement('canvas');

        var gl;

        if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV >= _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL2)
        {
            gl = canvas.getContext('webgl2', {});
        }

        if (!gl)
        {
            gl = canvas.getContext('webgl', {})
            || canvas.getContext('experimental-webgl', {});

            if (!gl)
            {
                // fail, not able to get a context
                gl = null;
            }
            else
            {
                // for shader testing..
                gl.getExtension('WEBGL_draw_buffers');
            }
        }

        context = gl;
    }

    return context;
}

var maxFragmentPrecision;

function getMaxFragmentPrecision()
{
    if (!maxFragmentPrecision)
    {
        maxFragmentPrecision = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.MEDIUM;
        var gl = getTestContext();

        if (gl)
        {
            if (gl.getShaderPrecisionFormat)
            {
                var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);

                maxFragmentPrecision = shaderFragment.precision ? _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.HIGH : _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.MEDIUM;
            }
        }
    }

    return maxFragmentPrecision;
}

/**
 * Sets the float precision on the shader, ensuring the device supports the request precision.
 * If the precision is already present, it just ensures that the device is able to handle it.
 *
 * @private
 * @param {string} src - The shader source
 * @param {string} requestedPrecision - The request float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param {string} maxSupportedPrecision - The maximum precision the shader supports.
 *
 * @return {string} modified shader source
 */
function setPrecision(src, requestedPrecision, maxSupportedPrecision)
{
    if (src.substring(0, 9) !== 'precision')
    {
        // no precision supplied, so PixiJS will add the requested level.
        var precision = requestedPrecision;

        // If highp is requested but not supported, downgrade precision to a level all devices support.
        if (requestedPrecision === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.HIGH && maxSupportedPrecision !== _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.HIGH)
        {
            precision = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.MEDIUM;
        }

        return ("precision " + precision + " float;\n" + src);
    }
    else if (maxSupportedPrecision !== _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.HIGH && src.substring(0, 15) === 'precision highp')
    {
        // precision was supplied, but at a level this device does not support, so downgrading to mediump.
        return src.replace('precision highp', 'precision mediump');
    }

    return src;
}

var GLSL_TO_SIZE = {
    float:    1,
    vec2:     2,
    vec3:     3,
    vec4:     4,

    int:      1,
    ivec2:    2,
    ivec3:    3,
    ivec4:    4,

    bool:     1,
    bvec2:    2,
    bvec3:    3,
    bvec4:    4,

    mat2:     4,
    mat3:     9,
    mat4:     16,

    sampler2D:  1,
};

/**
 * @private
 * @method mapSize
 * @memberof PIXI.glCore.shader
 * @param type {String}
 * @return {Number}
 */
function mapSize(type)
{
    return GLSL_TO_SIZE[type];
}

var GL_TABLE = null;

var GL_TO_GLSL_TYPES = {
    FLOAT:       'float',
    FLOAT_VEC2:  'vec2',
    FLOAT_VEC3:  'vec3',
    FLOAT_VEC4:  'vec4',

    INT:         'int',
    INT_VEC2:    'ivec2',
    INT_VEC3:    'ivec3',
    INT_VEC4:    'ivec4',

    BOOL:        'bool',
    BOOL_VEC2:   'bvec2',
    BOOL_VEC3:   'bvec3',
    BOOL_VEC4:   'bvec4',

    FLOAT_MAT2:  'mat2',
    FLOAT_MAT3:  'mat3',
    FLOAT_MAT4:  'mat4',

    SAMPLER_2D:  'sampler2D',
    SAMPLER_CUBE:  'samplerCube',
    SAMPLER_2D_ARRAY:  'sampler2DArray',
};

function mapType(gl, type)
{
    if (!GL_TABLE)
    {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

        GL_TABLE = {};

        for (var i = 0; i < typeNames.length; ++i)
        {
            var tn = typeNames[i];

            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
        }
    }

    return GL_TABLE[type];
}

// cv = CachedValue
// v = value
// ud = uniformData
// uv = uniformValue
// l = location
var GLSL_TO_SINGLE_SETTERS_CACHED = {

    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",

    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",

    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",

    vec4:     'gl.uniform4f(location, v[0], v[1], v[2], v[3])',

    int:      'gl.uniform1i(location, v)',
    ivec2:    'gl.uniform2i(location, v[0], v[1])',
    ivec3:    'gl.uniform3i(location, v[0], v[1], v[2])',
    ivec4:    'gl.uniform4i(location, v[0], v[1], v[2], v[3])',

    bool:     'gl.uniform1i(location, v)',
    bvec2:    'gl.uniform2i(location, v[0], v[1])',
    bvec3:    'gl.uniform3i(location, v[0], v[1], v[2])',
    bvec4:    'gl.uniform4i(location, v[0], v[1], v[2], v[3])',

    mat2:     'gl.uniformMatrix2fv(location, false, v)',
    mat3:     'gl.uniformMatrix3fv(location, false, v)',
    mat4:     'gl.uniformMatrix4fv(location, false, v)',

    sampler2D:      'gl.uniform1i(location, v)',
    samplerCube:    'gl.uniform1i(location, v)',
    sampler2DArray: 'gl.uniform1i(location, v)',
};

var GLSL_TO_ARRAY_SETTERS = {

    float:    "gl.uniform1fv(location, v)",

    vec2:     "gl.uniform2fv(location, v)",
    vec3:     "gl.uniform3fv(location, v)",
    vec4:     'gl.uniform4fv(location, v)',

    mat4:     'gl.uniformMatrix4fv(location, false, v)',
    mat3:     'gl.uniformMatrix3fv(location, false, v)',
    mat2:     'gl.uniformMatrix2fv(location, false, v)',

    int:      'gl.uniform1iv(location, v)',
    ivec2:    'gl.uniform2iv(location, v)',
    ivec3:    'gl.uniform3iv(location, v)',
    ivec4:    'gl.uniform4iv(location, v)',

    bool:     'gl.uniform1iv(location, v)',
    bvec2:    'gl.uniform2iv(location, v)',
    bvec3:    'gl.uniform3iv(location, v)',
    bvec4:    'gl.uniform4iv(location, v)',

    sampler2D:      'gl.uniform1iv(location, v)',
    samplerCube:    'gl.uniform1iv(location, v)',
    sampler2DArray: 'gl.uniform1iv(location, v)',
};

function generateUniformsSync(group, uniformData)
{
    var textureCount = 0;
    var func = "var v = null;\n    var cv = null\n    var gl = renderer.gl";

    for (var i in group.uniforms)
    {
        var data = uniformData[i];

        if (!data)
        {
            if (group.uniforms[i].group)
            {
                func += "\n                    renderer.shader.syncUniformGroup(uv." + i + ");\n                ";
            }

            continue;
        }

        // TODO && uniformData[i].value !== 0 <-- do we still need this?
        if (data.type === 'float' && data.size === 1)
        {
            func += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n";
        }
        /* eslint-disable max-len */
        else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray)
        /* eslint-disable max-len */
        {
            func += "\n            renderer.texture.bind(uv." + i + ", " + textureCount + ");\n\n            if(ud." + i + ".value !== " + textureCount + ")\n            {\n                ud." + i + ".value = " + textureCount + ";\n                gl.uniform1i(ud." + i + ".location, " + textureCount + ");\n; // eslint-disable-line max-len\n            }\n";

            textureCount++;
        }
        else if (data.type === 'mat3' && data.size === 1)
        {
            if (group.uniforms[i].a !== undefined)
            {
                // TODO and some smart caching dirty ids here!
                func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n";
            }
            else
            {
                func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n";
            }
        }
        else if (data.type === 'vec2' && data.size === 1)
        {
            // TODO - do we need both here?
            // maybe we can get away with only using points?
            if (group.uniforms[i].x !== undefined)
            {
                func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n";
            }
            else
            {
                func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n";
            }
        }
        else if (data.type === 'vec4' && data.size === 1)
        {
            // TODO - do we need both here?
            // maybe we can get away with only using points?
            if (group.uniforms[i].width !== undefined)
            {
                func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n";
            }
            else
            {
                func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n";
            }
        }
        else
        {
            var templateType = (data.size === 1) ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;

            var template =  templateType[data.type].replace('location', ("ud." + i + ".location"));

            func += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + template + ";\n";
        }
    }

    return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func
}

var fragTemplate = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}' ].join('\n');

function checkMaxIfStatementsInShader(maxIfs, gl)
{
    if (maxIfs === 0)
    {
        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
    }

    var shader = gl.createShader(gl.FRAGMENT_SHADER);

    while (true) // eslint-disable-line no-constant-condition
    {
        var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));

        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        {
            maxIfs = (maxIfs / 2) | 0;
        }
        else
        {
            // valid!
            break;
        }
    }

    return maxIfs;
}

function generateIfTestSrc(maxIfs)
{
    var src = '';

    for (var i = 0; i < maxIfs; ++i)
    {
        if (i > 0)
        {
            src += '\nelse ';
        }

        if (i < maxIfs - 1)
        {
            src += "if(test == " + i + ".0){}";
        }
    }

    return src;
}

// Cache the result to prevent running this over and over
var unsafeEval;

/**
 * Not all platforms allow to generate function code (e.g., `new Function`).
 * this provides the platform-level detection.
 *
 * @private
 * @returns {boolean}
 */
function unsafeEvalSupported()
{
    if (typeof unsafeEval === 'boolean')
    {
        return unsafeEval;
    }

    try
    {
        /* eslint-disable no-new-func */
        var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');
        /* eslint-enable no-new-func */

        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;
    }
    catch (e)
    {
        unsafeEval = false;
    }

    return unsafeEval;
}

var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";

var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";

// import * as from '../systems/shader/shader';

var UID$3 = 0;

var nameCache = {};

/**
 * Helper class to create a shader program.
 *
 * @class
 * @memberof PIXI
 */
var Program = function Program(vertexSrc, fragmentSrc, name)
{
    if ( name === void 0 ) name = 'pixi-shader';

    this.id = UID$3++;

    /**
     * The vertex shader.
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc || Program.defaultVertexSrc;

    /**
     * The fragment shader.
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;

    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();

    if (this.vertexSrc.substring(0, 8) !== '#version')
    {
        name = name.replace(/\s+/g, '-');

        if (nameCache[name])
        {
            nameCache[name]++;
            name += "-" + (nameCache[name]);
        }
        else
        {
            nameCache[name] = 1;
        }

        this.vertexSrc = "#define SHADER_NAME " + name + "\n" + (this.vertexSrc);
        this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + (this.fragmentSrc);

        this.vertexSrc = setPrecision(this.vertexSrc, _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PRECISION_VERTEX, _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.PRECISION.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
    }

    // currently this does not extract structs only default types
    this.extractData(this.vertexSrc, this.fragmentSrc);

    // this is where we store shader references..
    this.glPrograms = {};

    this.syncUniforms = null;
};

var staticAccessors = { defaultVertexSrc: { configurable: true },defaultFragmentSrc: { configurable: true } };

/**
 * Extracts the data for a buy creating a small test program
 * or reading the src directly.
 * @protected
 *
 * @param {string} [vertexSrc] - The source of the vertex shader.
 * @param {string} [fragmentSrc] - The source of the fragment shader.
 */
Program.prototype.extractData = function extractData (vertexSrc, fragmentSrc)
{
    var gl = getTestContext();

    if (gl)
    {
        var program = compileProgram(gl, vertexSrc, fragmentSrc);

        this.attributeData = this.getAttributeData(program, gl);
        this.uniformData = this.getUniformData(program, gl);

        gl.deleteProgram(program);
    }
    else
    {
        this.uniformData = {};
        this.attributeData = {};
    }
};

/**
 * returns the attribute data from the program
 * @private
 *
 * @param {WebGLProgram} [program] - the WebGL program
 * @param {WebGLRenderingContext} [gl] - the WebGL context
 *
 * @returns {object} the attribute data for this program
 */
Program.prototype.getAttributeData = function getAttributeData (program, gl)
{
    var attributes = {};
    var attributesArray = [];

    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < totalAttributes; i++)
    {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);

        /*eslint-disable */
        var data = {
            type: type,
            name: attribData.name,
            size: mapSize(type),
            location: 0,
        };
        /* eslint-enable */

        attributes[attribData.name] = data;
        attributesArray.push(data);
    }

    attributesArray.sort(function (a, b) { return (a.name > b.name) ? 1 : -1; }); // eslint-disable-line no-confusing-arrow

    for (var i$1 = 0; i$1 < attributesArray.length; i$1++)
    {
        attributesArray[i$1].location = i$1;
    }

    return attributes;
};

/**
 * returns the uniform data from the program
 * @private
 *
 * @param {webGL-program} [program] - the webgl program
 * @param {context} [gl] - the WebGL context
 *
 * @returns {object} the uniform data for this program
 */
Program.prototype.getUniformData = function getUniformData (program, gl)
{
    var uniforms = {};

    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    // TODO expose this as a prop?
    // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
    // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');

    for (var i = 0; i < totalUniforms; i++)
    {
        var uniformData = gl.getActiveUniform(program, i);
        var name = uniformData.name.replace(/\[.*?\]/, '');

        var isArray = uniformData.name.match(/\[.*?\]/, '');
        var type = mapType(gl, uniformData.type);

        /*eslint-disable */
        uniforms[name] = {
            type: type,
            size: uniformData.size,
            isArray:isArray,
            value: defaultValue(type, uniformData.size),
        };
        /* eslint-enable */
    }

    return uniforms;
};

/**
 * The default vertex shader source
 *
 * @static
 * @constant
 * @member {string}
 */
staticAccessors.defaultVertexSrc.get = function ()
{
    return defaultVertex;
};

/**
 * The default fragment shader source
 *
 * @static
 * @constant
 * @member {string}
 */
staticAccessors.defaultFragmentSrc.get = function ()
{
    return defaultFragment;
};

/**
 * A short hand function to create a program based of a vertex and fragment shader
 * this method will also check to see if there is a cached program.
 *
 * @param {string} [vertexSrc] - The source of the vertex shader.
 * @param {string} [fragmentSrc] - The source of the fragment shader.
 * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
 *
 * @returns {PIXI.Program} an shiny new Pixi shader!
 */
Program.from = function from (vertexSrc, fragmentSrc, name)
{
    var key = vertexSrc + fragmentSrc;

    var program = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.ProgramCache[key];

    if (!program)
    {
        _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
    }

    return program;
};

Object.defineProperties( Program, staticAccessors );

/**
 * A helper class for shaders
 *
 * @class
 * @memberof PIXI
 */
var Shader = function Shader(program, uniforms)
{
    /**
     * Program that the shader uses
     *
     * @member {PIXI.Program}
     */
    this.program = program;

    // lets see whats been passed in
    // uniforms should be converted to a uniform group
    if (uniforms)
    {
        if (uniforms instanceof UniformGroup)
        {
            this.uniformGroup = uniforms;
        }
        else
        {
            this.uniformGroup = new UniformGroup(uniforms);
        }
    }
    else
    {
        this.uniformGroup = new UniformGroup({});
    }

    // time to build some getters and setters!
    // I guess down the line this could sort of generate an instruction list rather than use dirty ids?
    // does the trick for now though!
    for (var i in program.uniformData)
    {
        if (this.uniformGroup.uniforms[i] instanceof Array)
        {
            this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
        }
    }
};

var prototypeAccessors$2 = { uniforms: { configurable: true } };

// TODO move to shader system..
Shader.prototype.checkUniformExists = function checkUniformExists (name, group)
{
    if (group.uniforms[name])
    {
        return true;
    }

    for (var i in group.uniforms)
    {
        var uniform = group.uniforms[i];

        if (uniform.group)
        {
            if (this.checkUniformExists(name, uniform))
            {
                return true;
            }
        }
    }

    return false;
};

Shader.prototype.destroy = function destroy ()
{
    // usage count on programs?
    // remove if not used!
    this.uniformGroup = null;
};

/**
 * Shader uniform values, shortcut for `uniformGroup.uniforms`
 * @readonly
 * @member {object}
 */
prototypeAccessors$2.uniforms.get = function ()
{
    return this.uniformGroup.uniforms;
};

/**
 * A short hand function to create a shader based of a vertex and fragment shader
 *
 * @param {string} [vertexSrc] - The source of the vertex shader.
 * @param {string} [fragmentSrc] - The source of the fragment shader.
 * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
 *
 * @returns {PIXI.Shader} an shiny new Pixi shader!
 */
Shader.from = function from (vertexSrc, fragmentSrc, uniforms)
{
    var program = Program.from(vertexSrc, fragmentSrc);

    return new Shader(program, uniforms);
};

Object.defineProperties( Shader.prototype, prototypeAccessors$2 );

/* eslint-disable max-len */

var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;

/**
 * This is a WebGL state, and is is passed The WebGL StateManager.
 *
 * Each mesh rendered may require WebGL to be in a different state.
 * For example you may want different blend mode or to enable polygon offsets
 *
 * @class
 * @memberof PIXI
 */
var State = function State()
{
    this.data = 0;

    this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NORMAL;
    this.polygonOffset = 0;

    this.blend = true;
    //  this.depthTest = true;
};

var prototypeAccessors$3 = { blend: { configurable: true },offsets: { configurable: true },culling: { configurable: true },depthTest: { configurable: true },clockwiseFrontFace: { configurable: true },blendMode: { configurable: true },polygonOffset: { configurable: true } };

/**
 * Activates blending of the computed fragment color values
 *
 * @member {boolean}
 */
prototypeAccessors$3.blend.get = function ()
{
    return !!(this.data & (1 << BLEND));
};

prototypeAccessors$3.blend.set = function (value) // eslint-disable-line require-jsdoc
{
    if (!!(this.data & (1 << BLEND)) !== value)
    {
        this.data ^= (1 << BLEND);
    }
};

/**
 * Activates adding an offset to depth values of polygon's fragments
 *
 * @member {boolean}
 * @default false
 */
prototypeAccessors$3.offsets.get = function ()
{
    return !!(this.data & (1 << OFFSET));
};

prototypeAccessors$3.offsets.set = function (value) // eslint-disable-line require-jsdoc
{
    if (!!(this.data & (1 << OFFSET)) !== value)
    {
        this.data ^= (1 << OFFSET);
    }
};

/**
 * Activates culling of polygons.
 *
 * @member {boolean}
 * @default false
 */
prototypeAccessors$3.culling.get = function ()
{
    return !!(this.data & (1 << CULLING));
};

prototypeAccessors$3.culling.set = function (value) // eslint-disable-line require-jsdoc
{
    if (!!(this.data & (1 << CULLING)) !== value)
    {
        this.data ^= (1 << CULLING);
    }
};

/**
 * Activates depth comparisons and updates to the depth buffer.
 *
 * @member {boolean}
 * @default false
 */
prototypeAccessors$3.depthTest.get = function ()
{
    return !!(this.data & (1 << DEPTH_TEST));
};

prototypeAccessors$3.depthTest.set = function (value) // eslint-disable-line require-jsdoc
{
    if (!!(this.data & (1 << DEPTH_TEST)) !== value)
    {
        this.data ^= (1 << DEPTH_TEST);
    }
};

/**
 * Specifies whether or not front or back-facing polygons can be culled.
 * @member {boolean}
 * @default false
 */
prototypeAccessors$3.clockwiseFrontFace.get = function ()
{
    return !!(this.data & (1 << WINDING));
};

prototypeAccessors$3.clockwiseFrontFace.set = function (value) // eslint-disable-line require-jsdoc
{
    if (!!(this.data & (1 << WINDING)) !== value)
    {
        this.data ^= (1 << WINDING);
    }
};

/**
 * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
 * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
 *
 * @member {number}
 * @default PIXI.BLEND_MODES.NORMAL
 * @see PIXI.BLEND_MODES
 */
prototypeAccessors$3.blendMode.get = function ()
{
    return this._blendMode;
};

prototypeAccessors$3.blendMode.set = function (value) // eslint-disable-line require-jsdoc
{
    this.blend = (value !== _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NONE);
    this._blendMode = value;
};

/**
 * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
 *
 * @member {number}
 * @default 0
 */
prototypeAccessors$3.polygonOffset.get = function ()
{
    return this._polygonOffset;
};

prototypeAccessors$3.polygonOffset.set = function (value) // eslint-disable-line require-jsdoc
{
    this.offsets = !!value;
    this._polygonOffset = value;
};

State.for2d = function for2d ()
{
    var state = new State();

    state.depthTest = false;
    state.blend = true;

    return state;
};

Object.defineProperties( State.prototype, prototypeAccessors$3 );

var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";

/**
 * Filter is a special type of WebGL shader that is applied to the screen.
 *
 * {@link http://pixijs.io/examples/#/filters/blur-filter.js Example} of the
 * {@link PIXI.filters.BlurFilter BlurFilter}.
 *
 * ### Usage
 * Filters can be applied to any DisplayObject or Container.
 * PixiJS' `FilterSystem` renders the container into temporary Framebuffer,
 * then filter renders it to the screen.
 * Multiple filters can be added to the `filters` array property and stacked on each other.
 *
 * ```
 * const filter = new PIXI.Filter(myShaderVert, myShaderFrag, { myUniform: 0.5 });
 * const container = new PIXI.Container();
 * container.filters = [filter];
 * ```
 *
 * ### Previous Version Differences
 *
 * In PixiJS **v3**, a filter was always applied to _whole screen_.
 *
 * In PixiJS **v4**, a filter can be applied _only part of the screen_.
 * Developers had to create a set of uniforms to deal with coordinates.
 *
 * In PixiJS **v5** combines _both approaches_.
 * Developers can use normal coordinates of v3 and then allow filter to use partial Framebuffers,
 * bringing those extra uniforms into account.
 *
 * Also be aware that we have changed default vertex shader, please consult
 * {@link https://github.com/pixijs/pixi.js/wiki/v5-Creating-filters Wiki}.
 *
 * ### Built-in Uniforms
 *
 * PixiJS viewport uses screen (CSS) coordinates, `(0, 0, renderer.screen.width, renderer.screen.height)`,
 * and `projectionMatrix` uniform maps it to the gl viewport.
 *
 * **uSampler**
 *
 * The most important uniform is the input texture that container was rendered into.
 * _Important note: as with all Framebuffers in PixiJS, both input and output are
 * premultiplied by alpha._
 *
 * By default, input normalized coordinates are passed to fragment shader with `vTextureCoord`.
 * Use it to sample the input.
 *
 * ```
 * const fragment = `
 * varying vec2 vTextureCoord;
 * uniform sampler2D uSampler;
 * void main(void)
 * {
 *    gl_FragColor = texture2D(uSampler, vTextureCoord);
 * }
 * `;
 *
 * const myFilter = new PIXI.Filter(null, fragment);
 * ```
 *
 * This filter is just one uniform less than {@link PIXI.filters.AlphaFilter AlphaFilter}.
 *
 * **outputFrame**
 *
 * The `outputFrame` holds the rectangle where filter is applied in screen (CSS) coordinates.
 * It's the same as `renderer.screen` for a fullscreen filter.
 * Only a part of  `outputFrame.zw` size of temporary Framebuffer is used,
 * `(0, 0, outputFrame.width, outputFrame.height)`,
 *
 * Filters uses this quad to normalized (0-1) space, its passed into `aVertexPosition` attribute.
 * To calculate vertex position in screen space using normalized (0-1) space:
 *
 * ```
 * vec4 filterVertexPosition( void )
 * {
 *     vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;
 *     return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
 * }
 * ```
 *
 * **inputSize**
 *
 * Temporary framebuffer is different, it can be either the size of screen, either power-of-two.
 * The `inputSize.xy` are size of temporary framebuffer that holds input.
 * The `inputSize.zw` is inverted, it's a shortcut to evade division inside the shader.
 *
 * Set `inputSize.xy = outputFrame.zw` for a fullscreen filter.
 *
 * To calculate input normalized coordinate, you have to map it to filter normalized space.
 * Multiply by `outputFrame.zw` to get input coordinate.
 * Divide by `inputSize.xy` to get input normalized coordinate.
 *
 * ```
 * vec2 filterTextureCoord( void )
 * {
 *     return aVertexPosition * (outputFrame.zw * inputSize.zw); // same as /inputSize.xy
 * }
 * ```
 * **resolution**
 *
 * The `resolution` is the ratio of screen (CSS) pixels to real pixels.
 *
 * **inputPixel**
 *
 * `inputPixel.xy` is the size of framebuffer in real pixels, same as `inputSize.xy * resolution`
 * `inputPixel.zw` is inverted `inputPixel.xy`.
 *
 * It's handy for filters that use neighbour pixels, like {@link PIXI.filters.FXAAFilter FXAAFilter}.
 *
 * **inputClamp**
 *
 * If you try to get info from outside of used part of Framebuffer - you'll get undefined behaviour.
 * For displacements, coordinates has to be clamped.
 *
 * The `inputClamp.xy` is left-top pixel center, you may ignore it, because we use left-top part of Framebuffer
 * `inputClamp.zw` is bottom-right pixel center.
 *
 * ```
 * vec4 color = texture2D(uSampler, clamp(modifigedTextureCoord, inputClamp.xy, inputClamp.zw))
 * ```
 * OR
 * ```
 * vec4 color = texture2D(uSampler, min(modifigedTextureCoord, inputClamp.zw))
 * ```
 *
 * ### Additional Information
 *
 * Complete documentation on Filter usage is located in the
 * {@link https://github.com/pixijs/pixi.js/wiki/v5-Creating-filters Wiki}.
 *
 * Since PixiJS only had a handful of built-in filters, additional filters can be downloaded
 * {@link https://github.com/pixijs/pixi-filters here} from the PixiJS Filters repository.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */
var Filter = /*@__PURE__*/(function (Shader) {
    function Filter(vertexSrc, fragmentSrc, uniforms)
    {
        var program = Program.from(vertexSrc || Filter.defaultVertexSrc,
            fragmentSrc || Filter.defaultFragmentSrc);

        Shader.call(this, program, uniforms);

        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 0;

        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.FILTER_RESOLUTION;

        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;

        /**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;

        /**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */
        this.legacy = !!this.program.attributeData.aTextureCoord;

        /**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */
        this.state = new State();
    }

    if ( Shader ) Filter.__proto__ = Shader;
    Filter.prototype = Object.create( Shader && Shader.prototype );
    Filter.prototype.constructor = Filter;

    var prototypeAccessors = { blendMode: { configurable: true } };
    var staticAccessors = { defaultVertexSrc: { configurable: true },defaultFragmentSrc: { configurable: true } };

    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */
    Filter.prototype.apply = function apply (filterManager, input, output, clear, currentState)
    {
        // do as you please!

        filterManager.applyFilter(this, input, output, clear, currentState);

        // or just do a regular render..
    };

    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    prototypeAccessors.blendMode.get = function ()
    {
        return this.state.blendMode;
    };

    prototypeAccessors.blendMode.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.state.blendMode = value;
    };

    /**
     * The default vertex shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    staticAccessors.defaultVertexSrc.get = function ()
    {
        return defaultVertex$1;
    };

    /**
     * The default fragment shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    staticAccessors.defaultFragmentSrc.get = function ()
    {
        return defaultFragment$1;
    };

    Object.defineProperties( Filter.prototype, prototypeAccessors );
    Object.defineProperties( Filter, staticAccessors );

    return Filter;
}(Shader));

/**
 * Used for caching shader IDs
 *
 * @static
 * @type {object}
 * @protected
 */
Filter.SOURCE_KEY_MAP = {};

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";

var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";

var tempMat = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix();

/**
 * Class controls uv mapping from Texture normal space to BaseTexture normal space.
 *
 * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.
 *
 * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.
 * If you want to add support for texture region of certain feature or filter, that's what you're looking for.
 *
 * Takes track of Texture changes through `_lastTextureID` private field.
 * Use `update()` method call to track it from outside.
 *
 * @see PIXI.Texture
 * @see PIXI.Mesh
 * @see PIXI.TilingSprite
 * @class
 * @memberof PIXI
 */
var TextureMatrix = function TextureMatrix(texture, clampMargin)
{
    this._texture = texture;

    /**
     * Matrix operation that converts texture region coords to texture coords
     * @member {PIXI.Matrix}
     * @readonly
     */
    this.mapCoord = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix();

    /**
     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.
     * Calculated based on clampOffset.
     * @member {Float32Array}
     * @readonly
     */
    this.uClampFrame = new Float32Array(4);

    /**
     * Normalized clamp offset.
     * Calculated based on clampOffset.
     * @member {Float32Array}
     * @readonly
     */
    this.uClampOffset = new Float32Array(2);

    /**
     * Tracks Texture frame changes
     * @member {number}
     * @protected
     */
    this._updateID = -1;

    /**
     * Changes frame clamping
     * Works with TilingSprite and Mesh
     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
     *
     * @default 0
     * @member {number}
     */
    this.clampOffset = 0;

    /**
     * Changes frame clamping
     * Works with TilingSprite and Mesh
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     *
     * @default 0.5
     * @member {number}
     */
    this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;

    /**
     * If texture size is the same as baseTexture
     * @member {boolean}
     * @default false
     * @readonly
     */
    this.isSimple = false;
};

var prototypeAccessors$4 = { texture: { configurable: true } };

/**
 * texture property
 * @member {PIXI.Texture}
 */
prototypeAccessors$4.texture.get = function ()
{
    return this._texture;
};

prototypeAccessors$4.texture.set = function (value) // eslint-disable-line require-jsdoc
{
    this._texture = value;
    this._updateID = -1;
};

/**
 * Multiplies uvs array to transform
 * @param {Float32Array} uvs mesh uvs
 * @param {Float32Array} [out=uvs] output
 * @returns {Float32Array} output
 */
TextureMatrix.prototype.multiplyUvs = function multiplyUvs (uvs, out)
{
    if (out === undefined)
    {
        out = uvs;
    }

    var mat = this.mapCoord;

    for (var i = 0; i < uvs.length; i += 2)
    {
        var x = uvs[i];
        var y = uvs[i + 1];

        out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
        out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
    }

    return out;
};

/**
 * updates matrices if texture was changed
 * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case
 * @returns {boolean} whether or not it was updated
 */
TextureMatrix.prototype.update = function update (forceUpdate)
{
    var tex = this._texture;

    if (!tex || !tex.valid)
    {
        return false;
    }

    if (!forceUpdate
        && this._updateID === tex._updateID)
    {
        return false;
    }

    this._updateID = tex._updateID;

    var uvs = tex._uvs;

    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);

    var orig = tex.orig;
    var trim = tex.trim;

    if (trim)
    {
        tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height,
            -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat);
    }

    var texBase = tex.baseTexture;
    var frame = this.uClampFrame;
    var margin = this.clampMargin / texBase.resolution;
    var offset = this.clampOffset;

    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;

    this.isSimple = tex._frame.width === texBase.width
        && tex._frame.height === texBase.height
        && tex.rotate === 0;

    return true;
};

Object.defineProperties( TextureMatrix.prototype, prototypeAccessors$4 );

/**
 * This handles a Sprite acting as a mask, as opposed to a Graphic.
 *
 * WebGL only.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI
 */
var SpriteMaskFilter = /*@__PURE__*/(function (Filter) {
    function SpriteMaskFilter(sprite)
    {
        var maskMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix();

        Filter.call(this, vertex, fragment);

        sprite.renderable = false;

        /**
         * Sprite mask
         * @member {PIXI.Sprite}
         */
        this.maskSprite = sprite;

        /**
         * Mask matrix
         * @member {PIXI.Matrix}
         */
        this.maskMatrix = maskMatrix;
    }

    if ( Filter ) SpriteMaskFilter.__proto__ = Filter;
    SpriteMaskFilter.prototype = Object.create( Filter && Filter.prototype );
    SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;

    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    SpriteMaskFilter.prototype.apply = function apply (filterManager, input, output, clear)
    {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;

        if (!tex.valid)
        {
            return;
        }
        if (!tex.transform)
        {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new TextureMatrix(tex, 0.0);
        }
        tex.transform.update();

        this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0.0 : 1.0;
        this.uniforms.mask = tex;
        // get _normalized sprite texture coords_ and convert them to _normalized atlas texture coords_ with `prepend`
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
            .prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;

        filterManager.applyFilter(this, input, output, clear);
    };

    return SpriteMaskFilter;
}(Filter));

/**
 * System plugin to the renderer to manage masks.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var MaskSystem = /*@__PURE__*/(function (System) {
    function MaskSystem(renderer)
    {
        System.call(this, renderer);

        // TODO - we don't need both!
        /**
         * `true` if current pushed masked is scissor
         * @member {boolean}
         * @readonly
         */
        this.scissor = false;

        /**
         * Mask data
         * @member {PIXI.Graphics}
         * @readonly
         */
        this.scissorData = null;

        /**
         * Target to mask
         * @member {PIXI.DisplayObject}
         * @readonly
         */
        this.scissorRenderTarget = null;

        /**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */
        this.enableScissor = false;

        /**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */
        this.alphaMaskPool = [];

        /**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */
        this.alphaMaskIndex = 0;
    }

    if ( System ) MaskSystem.__proto__ = System;
    MaskSystem.prototype = Object.create( System && System.prototype );
    MaskSystem.prototype.constructor = MaskSystem;

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    MaskSystem.prototype.push = function push (target, maskData)
    {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545

        if (maskData.isSprite)
        {
            this.pushSpriteMask(target, maskData);
        }
        else if (this.enableScissor
            && !this.scissor
            && this.renderer._activeRenderTarget.root
            && !this.renderer.stencil.stencilMaskStack.length
            && maskData.isFastRect())
        {
            var matrix = maskData.worldTransform;

            var rot = Math.atan2(matrix.b, matrix.a);

            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));

            if (rot % 90)
            {
                this.pushStencilMask(maskData);
            }
            else
            {
                this.pushScissorMask(target, maskData);
            }
        }
        else
        {
            this.pushStencilMask(maskData);
        }
    };

    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    MaskSystem.prototype.pop = function pop (target, maskData)
    {
        if (maskData.isSprite)
        {
            this.popSpriteMask(target, maskData);
        }
        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length)
        {
            this.popScissorMask(target, maskData);
        }
        else
        {
            this.popStencilMask(target, maskData);
        }
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTexture} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */
    MaskSystem.prototype.pushSpriteMask = function pushSpriteMask (target, maskData)
    {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];

        if (!alphaMaskFilter)
        {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskData)];
        }

        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;

        var stashFilterArea = target.filterArea;

        target.filterArea = maskData.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;

        this.alphaMaskIndex++;
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    MaskSystem.prototype.popSpriteMask = function popSpriteMask ()
    {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
    };

    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    MaskSystem.prototype.pushStencilMask = function pushStencilMask (maskData)
    {
        this.renderer.batch.flush();
        this.renderer.stencil.pushStencil(maskData);
    };

    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    MaskSystem.prototype.popStencilMask = function popStencilMask ()
    {
        // this.renderer.currentRenderer.stop();
        this.renderer.stencil.popStencil();
    };

    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */
    MaskSystem.prototype.pushScissorMask = function pushScissorMask (target, maskData)
    {
        maskData.renderable = true;

        var renderTarget = this.renderer._activeRenderTarget;

        var bounds = maskData.getBounds();

        bounds.fit(renderTarget.size);
        maskData.renderable = false;

        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);

        var resolution = this.renderer.resolution;

        this.renderer.gl.scissor(
            bounds.x * resolution,
            (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution,
            bounds.width * resolution,
            bounds.height * resolution
        );

        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    };

    /**
     * Pop scissor mask
     *
     */
    MaskSystem.prototype.popScissorMask = function popScissorMask ()
    {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;

        // must be scissor!
        var ref = this.renderer;
        var gl = ref.gl;

        gl.disable(gl.SCISSOR_TEST);
    };

    return MaskSystem;
}(System));

/**
 * System plugin to the renderer to manage stencils (used for masks).
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var StencilSystem = /*@__PURE__*/(function (System) {
    function StencilSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * The mask stack
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
    }

    if ( System ) StencilSystem.__proto__ = System;
    StencilSystem.prototype = Object.create( System && System.prototype );
    StencilSystem.prototype.constructor = StencilSystem;

    /**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */
    StencilSystem.prototype.setMaskStack = function setMaskStack (stencilMaskStack)
    {
        var gl = this.renderer.gl;
        var curStackLen = this.stencilMaskStack.length;

        this.stencilMaskStack = stencilMaskStack;
        if (stencilMaskStack.length !== curStackLen)
        {
            if (stencilMaskStack.length === 0)
            {
                gl.disable(gl.STENCIL_TEST);
            }
            else
            {
                gl.enable(gl.STENCIL_TEST);
                this._useCurrent();
            }
        }
    };

    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */
    StencilSystem.prototype.pushStencil = function pushStencil (graphics)
    {
        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;

        if (prevMaskCount === 0)
        {
            gl.enable(gl.STENCIL_TEST);
        }

        this.stencilMaskStack.push(graphics);

        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

        graphics.renderable = true;
        graphics.render(this.renderer);
        this.renderer.batch.flush();
        graphics.renderable = false;

        this._useCurrent();
    };

    /**
     * Removes the last mask from the stencil stack. @alvin
     */
    StencilSystem.prototype.popStencil = function popStencil ()
    {
        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();

        if (this.stencilMaskStack.length === 0)
        {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        }
        else
        {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);

            graphics.renderable = true;
            graphics.render(this.renderer);
            this.renderer.batch.flush();
            graphics.renderable = false;

            this._useCurrent();
        }
    };

    /**
     * Setup renderer to use the current stencil data.
     * @private
     */
    StencilSystem.prototype._useCurrent = function _useCurrent ()
    {
        var gl = this.renderer.gl;

        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };

    /**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */
    StencilSystem.prototype._getBitwiseMask = function _getBitwiseMask ()
    {
        return (1 << this.stencilMaskStack.length) - 1;
    };

    /**
     * Destroys the mask stack.
     *
     */
    StencilSystem.prototype.destroy = function destroy ()
    {
        System.prototype.destroy.call(this, this);

        this.stencilMaskStack = null;
    };

    return StencilSystem;
}(System));

/**
 * System plugin to the renderer to manage the projection matrix.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */

var ProjectionSystem = /*@__PURE__*/(function (System) {
    function ProjectionSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = null;

        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = null;

        /**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.defaultFrame = null;

        /**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */
        this.projectionMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix();

        /**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    }

    if ( System ) ProjectionSystem.__proto__ = System;
    ProjectionSystem.prototype = Object.create( System && System.prototype );
    ProjectionSystem.prototype.constructor = ProjectionSystem;

    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    ProjectionSystem.prototype.update = function update (destinationFrame, sourceFrame, resolution, root)
    {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;

        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);

        if (this.transform)
        {
            this.projectionMatrix.append(this.transform);
        }

        var renderer =  this.renderer;

        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();

        // this will work for now
        // but would be sweet to stick and even on the global uniforms..
        if (renderer.shader.shader)
        {
            renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
    };

    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    ProjectionSystem.prototype.calculateProjection = function calculateProjection (destinationFrame, sourceFrame, resolution, root)
    {
        var pm = this.projectionMatrix;

        // I don't think we will need this line..
        // pm.identity();

        if (!root)
        {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (1 / destinationFrame.height * 2) * resolution;

            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = -1 - (sourceFrame.y * pm.d);
        }
        else
        {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (-1 / destinationFrame.height * 2) * resolution;

            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = 1 - (sourceFrame.y * pm.d);
        }
    };

    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */
    ProjectionSystem.prototype.setTransform = function setTransform ()// matrix)
    {
        // this._activeRenderTarget.transform = matrix;
    };

    return ProjectionSystem;
}(System));

var tempRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();

/**
 * System plugin to the renderer to manage render textures.
 *
 * Should be added after FramebufferSystem
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */

var RenderTextureSystem = /*@__PURE__*/(function (System) {
    function RenderTextureSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * The clear background color as rgba
         * @member {number[]}
         */
        this.clearColor = renderer._backgroundColorRgba;

        // TODO move this property somewhere else!
        /**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */
        this.defaultMaskStack = [];

        // empty render texture?
        /**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */
        this.current = null;

        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();

        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle();
    }

    if ( System ) RenderTextureSystem.__proto__ = System;
    RenderTextureSystem.prototype = Object.create( System && System.prototype );
    RenderTextureSystem.prototype.constructor = RenderTextureSystem;

    /**
     * Bind the current render texture
     * @param {PIXI.RenderTexture} [renderTexture] - RenderTexture to bind, by default its `null`, the screen
     * @param {PIXI.Rectangle} [sourceFrame] - part of screen that is mapped to the renderTexture
     * @param {PIXI.Rectangle} [destinationFrame] - part of renderTexture, by default it has the same size as sourceFrame
     */
    RenderTextureSystem.prototype.bind = function bind (renderTexture, sourceFrame, destinationFrame)
    {
        if ( renderTexture === void 0 ) renderTexture = null;

        this.current = renderTexture;

        var renderer = this.renderer;

        var resolution;

        if (renderTexture)
        {
            var baseTexture = renderTexture.baseTexture;

            resolution = baseTexture.resolution;

            if (!destinationFrame)
            {
                tempRect.width = baseTexture.realWidth;
                tempRect.height = baseTexture.realHeight;

                destinationFrame = tempRect;
            }

            if (!sourceFrame)
            {
                sourceFrame = destinationFrame;
            }

            this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame);

            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
            this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack);
        }
        else
        {
            resolution = this.renderer.resolution;

            // TODO these validation checks happen deeper down..
            // thing they can be avoided..
            if (!destinationFrame)
            {
                tempRect.width = renderer.width;
                tempRect.height = renderer.height;

                destinationFrame = tempRect;
            }

            if (!sourceFrame)
            {
                sourceFrame = destinationFrame;
            }

            renderer.framebuffer.bind(null, destinationFrame);

            // TODO store this..
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, true);
            this.renderer.stencil.setMaskStack(this.defaultMaskStack);
        }

        this.sourceFrame.copyFrom(sourceFrame);

        this.destinationFrame.x = destinationFrame.x / resolution;
        this.destinationFrame.y = destinationFrame.y / resolution;

        this.destinationFrame.width = destinationFrame.width / resolution;
        this.destinationFrame.height = destinationFrame.height / resolution;

        if (sourceFrame === destinationFrame)
        {
            this.sourceFrame.copyFrom(this.destinationFrame);
        }
    };

    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @return {PIXI.Renderer} Returns itself.
     */
    RenderTextureSystem.prototype.clear = function clear (clearColor)
    {
        if (this.current)
        {
            clearColor = clearColor || this.current.baseTexture.clearColor;
        }
        else
        {
            clearColor = clearColor || this.clearColor;
        }

        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    };

    RenderTextureSystem.prototype.resize = function resize ()// screenWidth, screenHeight)
    {
        // resize the root only!
        this.bind(null);
    };

    /**
     * Resets renderTexture state
     */
    RenderTextureSystem.prototype.reset = function reset ()
    {
        this.bind(null);
    };

    return RenderTextureSystem;
}(System));

/**
 * Helper class to create a WebGL Program
 *
 * @class
 * @memberof PIXI
 */
var GLProgram = function GLProgram(program, uniformData)
{
    /**
     * The shader program
     *
     * @member {WebGLProgram}
     */
    this.program = program;

    /**
     * holds the uniform data which contains uniform locations
     * and current uniform values used for caching and preventing unneeded GPU commands
     * @member {Object}
     */
    this.uniformData = uniformData;

    /**
     * uniformGroups holds the various upload functions for the shader. Each uniform group
     * and program have a unique upload function generated.
     * @member {Object}
     */
    this.uniformGroups = {};
};

/**
 * Destroys this program
 */
GLProgram.prototype.destroy = function destroy ()
{
    this.uniformData = null;
    this.uniformGroups = null;
    this.program = null;
};

var UID$4 = 0;

/**
 * System plugin to the renderer to manage shaders.
 *
 * @class
 * @memberof PIXI.systems
 * @extends PIXI.System
 */
var ShaderSystem = /*@__PURE__*/(function (System) {
    function ShaderSystem(renderer)
    {
        System.call(this, renderer);

        // Validation check that this environment support `new Function`
        this.systemCheck();

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = null;

        this.shader = null;
        this.program = null;

        /**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */
        this.cache = {};

        this.id = UID$4++;
    }

    if ( System ) ShaderSystem.__proto__ = System;
    ShaderSystem.prototype = Object.create( System && System.prototype );
    ShaderSystem.prototype.constructor = ShaderSystem;

    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */
    ShaderSystem.prototype.systemCheck = function systemCheck ()
    {
        if (!unsafeEvalSupported())
        {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    };

    ShaderSystem.prototype.contextChange = function contextChange (gl)
    {
        this.gl = gl;
        this.reset();
    };

    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} dontSync - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */
    ShaderSystem.prototype.bind = function bind (shader, dontSync)
    {
        shader.uniforms.globals = this.renderer.globalUniforms;

        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);

        this.shader = shader;

        // TODO - some current Pixi plugins bypass this.. so it not safe to use yet..
        if (this.program !== program)
        {
            this.program = program;
            this.gl.useProgram(glProgram.program);
        }

        if (!dontSync)
        {
            this.syncUniformGroup(shader.uniformGroup);
        }

        return glProgram;
    };

    /**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */
    ShaderSystem.prototype.setUniforms = function setUniforms (uniforms)
    {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];

        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    };

    ShaderSystem.prototype.syncUniformGroup = function syncUniformGroup (group)
    {
        var glProgram = this.getglProgram();

        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id])
        {
            glProgram.uniformGroups[group.id] = group.dirtyId;

            this.syncUniforms(group, glProgram);
        }
    };

    /**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */
    ShaderSystem.prototype.syncUniforms = function syncUniforms (group, glProgram)
    {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);

        syncFunc(glProgram.uniformData, group.uniforms, this.renderer);
    };

    ShaderSystem.prototype.createSyncGroups = function createSyncGroups (group)
    {
        var id = this.getSignature(group, this.shader.program.uniformData);

        if (!this.cache[id])
        {
            this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
        }

        group.syncUniforms[this.shader.program.id] = this.cache[id];

        return group.syncUniforms[this.shader.program.id];
    };

    /**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group the uniform group to get signature of
     * @param {Object} uniformData uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */
    ShaderSystem.prototype.getSignature = function getSignature (group, uniformData)
    {
        var uniforms = group.uniforms;

        var strings = [];

        for (var i in uniforms)
        {
            strings.push(i);

            if (uniformData[i])
            {
                strings.push(uniformData[i].type);
            }
        }

        return strings.join('-');
    };

    /**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */
    ShaderSystem.prototype.getglProgram = function getglProgram ()
    {
        if (this.shader)
        {
            return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }

        return null;
    };

    /**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */
    ShaderSystem.prototype.generateShader = function generateShader (shader)
    {
        var gl = this.gl;

        var program = shader.program;

        var attribMap = {};

        for (var i in program.attributeData)
        {
            attribMap[i] = program.attributeData[i].location;
        }

        var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};

        for (var i$1 in program.uniformData)
        {
            var data = program.uniformData[i$1];

            uniformData[i$1] = {
                location: gl.getUniformLocation(shaderProgram, i$1),
                value: defaultValue(data.type, data.size),
            };
        }

        var glProgram = new GLProgram(shaderProgram, uniformData);

        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;

        return glProgram;
    };

    /**
     * Resets ShaderSystem state, does not affect WebGL state
     */
    ShaderSystem.prototype.reset = function reset ()
    {
        this.program = null;
        this.shader = null;
    };

    /**
     * Destroys this System and removes all its textures
     */
    ShaderSystem.prototype.destroy = function destroy ()
    {
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    };

    return ShaderSystem;
}(System));

/**
 * Maps gl blend combinations to WebGL.
 *
 * @memberof PIXI
 * @function mapWebGLBlendModesToPixi
 * @private
 * @param {WebGLRenderingContext} gl - The rendering context.
 * @param {number[][]} [array=[]] - The array to output into.
 * @return {number[][]} Mapped modes.
 */
function mapWebGLBlendModesToPixi(gl, array)
{
    if ( array === void 0 ) array = [];

    // TODO - premultiply alpha would be different.
    // add a boolean for that!
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NONE] = [0, 0];

    // not-premultiplied blend modes
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

    // composite operations
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];

    // SUBTRACT from flash
    array[_pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];

    return array;
}

var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;

/**
 * System plugin to the renderer to manage WebGL state machines.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var StateSystem = /*@__PURE__*/(function (System) {
    function StateSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */
        this.gl = null;

        /**
         * State ID
         * @member {number}
         * @readonly
         */
        this.stateId = 0;

        /**
         * Polygon offset
         * @member {number}
         * @readonly
         */
        this.polygonOffset = 0;

        /**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */
        this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.BLEND_MODES.NONE;

        /**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */
        this._blendEq = false;

        /**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */
        this.map = [];

        // map functions for when we set state..
        this.map[BLEND$1] = this.setBlend;
        this.map[OFFSET$1] = this.setOffset;
        this.map[CULLING$1] = this.setCullFace;
        this.map[DEPTH_TEST$1] = this.setDepthTest;
        this.map[WINDING$1] = this.setFrontFace;

        /**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */
        this.checks = [];

        /**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */
        this.defaultState = new State();
        this.defaultState.blend = true;
        this.defaultState.depth = true;
    }

    if ( System ) StateSystem.__proto__ = System;
    StateSystem.prototype = Object.create( System && System.prototype );
    StateSystem.prototype.constructor = StateSystem;

    StateSystem.prototype.contextChange = function contextChange (gl)
    {
        this.gl = gl;

        this.blendModes = mapWebGLBlendModesToPixi(gl);

        this.set(this.defaultState);

        this.reset();
    };

    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */
    StateSystem.prototype.set = function set (state)
    {
        state = state || this.defaultState;

        // TODO maybe to an object check? ( this.state === state )?
        if (this.stateId !== state.data)
        {
            var diff = this.stateId ^ state.data;
            var i = 0;

            // order from least to most common
            while (diff)
            {
                if (diff & 1)
                {
                    // state change!
                    this.map[i].call(this, !!(state.data & (1 << i)));
                }

                diff = diff >> 1;
                i++;
            }

            this.stateId = state.data;
        }

        // based on the above settings we check for specific modes..
        // for example if blend is active we check and set the blend modes
        // or of polygon offset is active we check the poly depth.
        for (var i$1 = 0; i$1 < this.checks.length; i$1++)
        {
            this.checks[i$1](this, state);
        }
    };

    /**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */
    StateSystem.prototype.forceState = function forceState (state)
    {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++)
        {
            this.map[i].call(this, !!(state.data & (1 << i)));
        }
        for (var i$1 = 0; i$1 < this.checks.length; i$1++)
        {
            this.checks[i$1](this, state);
        }

        this.stateId = state.data;
    };

    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */
    StateSystem.prototype.setBlend = function setBlend (value)
    {
        this.updateCheck(StateSystem.checkBlendMode, value);

        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    };

    /**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */
    StateSystem.prototype.setOffset = function setOffset (value)
    {
        this.updateCheck(StateSystem.checkPolygonOffset, value);

        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
    };

    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */
    StateSystem.prototype.setDepthTest = function setDepthTest (value)
    {
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    };

    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    StateSystem.prototype.setCullFace = function setCullFace (value)
    {
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    };

    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    StateSystem.prototype.setFrontFace = function setFrontFace (value)
    {
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    };

    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */
    StateSystem.prototype.setBlendMode = function setBlendMode (value)
    {
        if (value === this.blendMode)
        {
            return;
        }

        this.blendMode = value;

        var mode = this.blendModes[value];
        var gl = this.gl;

        if (mode.length === 2)
        {
            gl.blendFunc(mode[0], mode[1]);
        }
        else
        {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6)
        {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
        }
        else if (this._blendEq)
        {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
    };

    /**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    StateSystem.prototype.setPolygonOffset = function setPolygonOffset (value, scale)
    {
        this.gl.polygonOffset(value, scale);
    };

    // used
    /**
     * Resets all the logic and disables the vaos
     */
    StateSystem.prototype.reset = function reset ()
    {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.forceState(0);

        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
    };

    /**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func  the checking function to add or remove
     * @param {boolean} value  should the check function be added or removed.
     */
    StateSystem.prototype.updateCheck = function updateCheck (func, value)
    {
        var index = this.checks.indexOf(func);

        if (value && index === -1)
        {
            this.checks.push(func);
        }
        else if (!value && index !== -1)
        {
            this.checks.splice(index, 1);
        }
    };

    /**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    StateSystem.checkBlendMode = function checkBlendMode (system, state)
    {
        system.setBlendMode(state.blendMode);
    };

    /**
     * A private little wrapper function that we call to check the polygon offset.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    StateSystem.checkPolygonOffset = function checkPolygonOffset (system, state)
    {
        system.setPolygonOffset(state.polygonOffset, 0);
    };

    return StateSystem;
}(System));

/**
 * System plugin to the renderer to manage texture garbage collection on the GPU,
 * ensuring that it does not get clogged up with textures that are no longer being used.
 *
 * @class
 * @memberof PIXI.systems
 * @extends PIXI.System
 */
var TextureGCSystem = /*@__PURE__*/(function (System) {
    function TextureGCSystem(renderer)
    {
        System.call(this, renderer);

        /**
         * Count
         * @member {number}
         * @readonly
         */
        this.count = 0;

        /**
         * Check count
         * @member {number}
         * @readonly
         */
        this.checkCount = 0;

        /**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */
        this.maxIdle = _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.GC_MAX_IDLE;

        /**
         * Maximum number of item to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */
        this.checkCountMax = _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.GC_MAX_CHECK_COUNT;

        /**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */
        this.mode = _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.GC_MODE;
    }

    if ( System ) TextureGCSystem.__proto__ = System;
    TextureGCSystem.prototype = Object.create( System && System.prototype );
    TextureGCSystem.prototype.constructor = TextureGCSystem;

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    TextureGCSystem.prototype.postrender = function postrender ()
    {
        this.count++;

        if (this.mode === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.GC_MODES.MANUAL)
        {
            return;
        }

        this.checkCount++;

        if (this.checkCount > this.checkCountMax)
        {
            this.checkCount = 0;

            this.run();
        }
    };

    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    TextureGCSystem.prototype.run = function run ()
    {
        var tm = this.renderer.texture;
        var managedTextures =  tm.managedTextures;
        var wasRemoved = false;

        for (var i = 0; i < managedTextures.length; i++)
        {
            var texture = managedTextures[i];

            // only supports non generated textures at the moment!
            if (!texture.framebuffer && this.count - texture.touched > this.maxIdle)
            {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }

        if (wasRemoved)
        {
            var j = 0;

            for (var i$1 = 0; i$1 < managedTextures.length; i$1++)
            {
                if (managedTextures[i$1] !== null)
                {
                    managedTextures[j++] = managedTextures[i$1];
                }
            }

            managedTextures.length = j;
        }
    };

    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */
    TextureGCSystem.prototype.unload = function unload (displayObject)
    {
        var tm = this.renderer.textureSystem;

        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets)
        {
            tm.destroyTexture(displayObject._texture);
        }

        for (var i = displayObject.children.length - 1; i >= 0; i--)
        {
            this.unload(displayObject.children[i]);
        }
    };

    return TextureGCSystem;
}(System));

/**
 * Internal texture for WebGL context
 * @class
 * @memberof PIXI
 */
var GLTexture = function GLTexture(texture)
{
    /**
     * The WebGL texture
     * @member {WebGLTexture}
     */
    this.texture = texture;

    /**
     * Width of texture that was used in texImage2D
     * @member {number}
     */
    this.width = -1;

    /**
     * Height of texture that was used in texImage2D
     * @member {number}
     */
    this.height = -1;

    /**
     * Texture contents dirty flag
     * @member {number}
     */
    this.dirtyId = -1;

    /**
     * Texture style dirty flag
     * @member {number}
     */
    this.dirtyStyleId = -1;

    /**
     * Whether mip levels has to be generated
     * @member {boolean}
     */
    this.mipmap = false;

    /**
     * WrapMode copied from baseTexture
     * @member {number}
     */
    this.wrapMode = 33071;

    /**
     * Type copied from baseTexture
     * @member {number}
     */
    this.type = 6408;

    /**
     * Type copied from baseTexture
     * @member {number}
     */
    this.internalFormat = 5121;
};

/**
 * System plugin to the renderer to manage textures.
 *
 * @class
 * @extends PIXI.System
 * @memberof PIXI.systems
 */
var TextureSystem = /*@__PURE__*/(function (System) {
    function TextureSystem(renderer)
    {
        System.call(this, renderer);

        // TODO set to max textures...
        /**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.boundTextures = [];
        /**
         * Current location
         * @member {number}
         * @readonly
         */
        this.currentLocation = -1;

        /**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.managedTextures = [];

        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;

        /**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */
        this.unknownTexture = new BaseTexture();
    }

    if ( System ) TextureSystem.__proto__ = System;
    TextureSystem.prototype = Object.create( System && System.prototype );
    TextureSystem.prototype.constructor = TextureSystem;

    /**
     * Sets up the renderer context and necessary buffers.
     */
    TextureSystem.prototype.contextChange = function contextChange ()
    {
        var gl = this.gl = this.renderer.gl;

        this.CONTEXT_UID = this.renderer.CONTEXT_UID;

        this.webGLVersion = this.renderer.context.webGLVersion;

        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        this.boundTextures.length = maxTextures;

        for (var i = 0; i < maxTextures; i++)
        {
            this.boundTextures[i] = null;
        }

        // TODO move this.. to a nice make empty textures class..
        this.emptyTextures = {};

        var emptyTexture2D = new GLTexture(gl.createTexture());

        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));

        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);

        for (var i$1 = 0; i$1 < 6; i$1++)
        {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++)
        {
            this.bind(null, i$2);
        }
    };

    /**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */
    TextureSystem.prototype.bind = function bind (texture, location)
    {
        if ( location === void 0 ) location = 0;

        var ref = this;
        var gl = ref.gl;

        if (texture)
        {
            texture = texture.baseTexture || texture;

            if (texture.valid)
            {
                texture.touched = this.renderer.textureGC.count;

                var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);

                if (this.currentLocation !== location)
                {
                    this.currentLocation = location;
                    gl.activeTexture(gl.TEXTURE0 + location);
                }

                if (this.boundTextures[location] !== texture)
                {
                    gl.bindTexture(texture.target, glTexture.texture);
                }

                if (glTexture.dirtyId !== texture.dirtyId)
                {
                    this.updateTexture(texture);
                }

                this.boundTextures[location] = texture;
            }
        }
        else
        {
            if (this.currentLocation !== location)
            {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
            }

            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
            this.boundTextures[location] = null;
        }
    };

    /**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */
    TextureSystem.prototype.reset = function reset ()
    {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;

        for (var i = 0; i < this.boundTextures.length; i++)
        {
            this.boundTextures[i] = this.unknownTexture;
        }
    };

    /**
     * Unbind a texture
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     */
    TextureSystem.prototype.unbind = function unbind (texture)
    {
        var ref = this;
        var gl = ref.gl;
        var boundTextures = ref.boundTextures;

        if (this._unknownBoundTextures)
        {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multi-texture renderer samplers
            for (var i = 0; i < boundTextures.length; i++)
            {
                if (boundTextures[i] === this.unknownTexture)
                {
                    this.bind(null, i);
                }
            }
        }

        for (var i$1 = 0; i$1 < boundTextures.length; i$1++)
        {
            if (boundTextures[i$1] === texture)
            {
                if (this.currentLocation !== i$1)
                {
                    gl.activeTexture(gl.TEXTURE0 + i$1);
                    this.currentLocation = i$1;
                }

                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
                boundTextures[i$1] = null;
            }
        }
    };

    /**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    TextureSystem.prototype.initTexture = function initTexture (texture)
    {
        var glTexture = new GLTexture(this.gl.createTexture());

        // guarantee an update..
        glTexture.dirtyId = -1;

        texture._glTextures[this.CONTEXT_UID] = glTexture;

        this.managedTextures.push(texture);
        texture.on('dispose', this.destroyTexture, this);

        return glTexture;
    };

    TextureSystem.prototype.initTextureType = function initTextureType (texture, glTexture)
    {
        glTexture.internalFormat = texture.format;
        glTexture.type = texture.type;
        if (this.webGLVersion !== 2)
        {
            return;
        }
        var gl = this.renderer.gl;

        if (texture.type === gl.FLOAT
            && texture.format === gl.RGBA)
        {
            glTexture.internalFormat = gl.RGBA32F;
        }
        // that's WebGL1 HALF_FLOAT_OES
        // we have to convert it to WebGL HALF_FLOAT
        if (texture.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.HALF_FLOAT)
        {
            glTexture.type = gl.HALF_FLOAT;
        }
        if (glTexture.type === gl.HALF_FLOAT
            && texture.format === gl.RGBA)
        {
            glTexture.internalFormat = gl.RGBA16F;
        }
    };

    /**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    TextureSystem.prototype.updateTexture = function updateTexture (texture)
    {
        var glTexture = texture._glTextures[this.CONTEXT_UID];

        if (!glTexture)
        {
            return;
        }

        var renderer = this.renderer;

        this.initTextureType(texture, glTexture);

        if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
        ;
        else
        {
            // default, renderTexture-like logic
            var width = texture.realWidth;
            var height = texture.realHeight;
            var gl = renderer.gl;

            if (glTexture.width !== width
                || glTexture.height !== height
                || glTexture.dirtyId < 0)
            {
                glTexture.width = width;
                glTexture.height = height;

                gl.texImage2D(texture.target, 0,
                    glTexture.internalFormat,
                    width,
                    height,
                    0,
                    texture.format,
                    glTexture.type,
                    null);
            }
        }

        // lets only update what changes..
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId)
        {
            this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
    };

    /**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */
    TextureSystem.prototype.destroyTexture = function destroyTexture (texture, skipRemove)
    {
        var ref = this;
        var gl = ref.gl;

        texture = texture.baseTexture || texture;

        if (texture._glTextures[this.CONTEXT_UID])
        {
            this.unbind(texture);

            gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
            texture.off('dispose', this.destroyTexture, this);

            delete texture._glTextures[this.CONTEXT_UID];

            if (!skipRemove)
            {
                var i = this.managedTextures.indexOf(texture);

                if (i !== -1)
                {
                    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.removeItems)(this.managedTextures, i, 1);
                }
            }
        }
    };

    /**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */
    TextureSystem.prototype.updateTextureStyle = function updateTextureStyle (texture)
    {
        var glTexture = texture._glTextures[this.CONTEXT_UID];

        if (!glTexture)
        {
            return;
        }

        if ((texture.mipmap === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo)
        {
            glTexture.mipmap = 0;
            glTexture.wrapMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.WRAP_MODES.CLAMP;
        }
        else
        {
            glTexture.mipmap = texture.mipmap >= 1;
            glTexture.wrapMode = texture.wrapMode;
        }

        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        ;
        else
        {
            this.setStyle(texture, glTexture);
        }

        glTexture.dirtyStyleId = texture.dirtyStyleId;
    };

    /**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {PIXI.GLTexture} glTexture
     */
    TextureSystem.prototype.setStyle = function setStyle (texture, glTexture)
    {
        var gl = this.gl;

        if (glTexture.mipmap)
        {
            gl.generateMipmap(texture.target);
        }

        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);

        if (glTexture.mipmap)
        {
            /* eslint-disable max-len */
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            /* eslint-disable max-len */

            var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;

            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.SCALE_MODES.LINEAR)
            {
                var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));

                gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
            }
        }
        else
        {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
        }

        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
    };

    return TextureSystem;
}(System));

/**
 * Systems are individual components to the Renderer pipeline.
 * @namespace PIXI.systems
 */

var systems = ({
    FilterSystem: FilterSystem,
    BatchSystem: BatchSystem,
    ContextSystem: ContextSystem,
    FramebufferSystem: FramebufferSystem,
    GeometrySystem: GeometrySystem,
    MaskSystem: MaskSystem,
    StencilSystem: StencilSystem,
    ProjectionSystem: ProjectionSystem,
    RenderTextureSystem: RenderTextureSystem,
    ShaderSystem: ShaderSystem,
    StateSystem: StateSystem,
    TextureGCSystem: TextureGCSystem,
    TextureSystem: TextureSystem
});

var tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix();

/**
 * The AbstractRenderer is the base for a PixiJS Renderer. It is extended by the {@link PIXI.CanvasRenderer}
 * and {@link PIXI.Renderer} which can be used for rendering a PixiJS scene.
 *
 * @abstract
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI
 */
var AbstractRenderer = /*@__PURE__*/(function (EventEmitter) {
    function AbstractRenderer(system, options)
    {
        EventEmitter.call(this);

        // Add the default render options
        options = Object.assign({}, _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.RENDER_OPTIONS, options);

        // Deprecation notice for renderer roundPixels option
        if (options.roundPixels)
        {
            _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.ROUND_PIXELS = options.roundPixels;
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.deprecation)('5.0.0', 'Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS', 2);
        }

        /**
         * The supplied constructor options.
         *
         * @member {Object}
         * @readOnly
         */
        this.options = options;

        /**
         * The type of the renderer.
         *
         * @member {number}
         * @default PIXI.RENDERER_TYPE.UNKNOWN
         * @see PIXI.RENDERER_TYPE
         */
        this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.RENDERER_TYPE.UNKNOWN;

        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         *
         * @member {PIXI.Rectangle}
         */
        this.screen = new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Rectangle(0, 0, options.width, options.height);

        /**
         * The canvas element that everything is drawn to.
         *
         * @member {HTMLCanvasElement}
         */
        this.view = options.view || document.createElement('canvas');

        /**
         * The resolution / device pixel ratio of the renderer.
         *
         * @member {number}
         * @default 1
         */
        this.resolution = options.resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.RESOLUTION;

        /**
         * Whether the render view is transparent.
         *
         * @member {boolean}
         */
        this.transparent = options.transparent;

        /**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         *
         * @member {boolean}
         */
        this.autoDensity = options.autoDensity || options.autoResize || false;
        // autoResize is deprecated, provides fallback support

        /**
         * The value of the preserveDrawingBuffer flag affects whether or not the contents of
         * the stencil buffer is retained after rendering.
         *
         * @member {boolean}
         */
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;

        /**
         * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
         * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every
         * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect
         * to clear the canvas every frame. Disable this by setting this to false. For example, if
         * your game has a canvas filling background image you often don't need this set.
         *
         * @member {boolean}
         * @default
         */
        this.clearBeforeRender = options.clearBeforeRender;

        /**
         * The background color as a number.
         *
         * @member {number}
         * @protected
         */
        this._backgroundColor = 0x000000;

        /**
         * The background color as an [R, G, B] array.
         *
         * @member {number[]}
         * @protected
         */
        this._backgroundColorRgba = [0, 0, 0, 0];

        /**
         * The background color as a string.
         *
         * @member {string}
         * @protected
         */
        this._backgroundColorString = '#000000';

        this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter

        /**
         * This temporary display object used as the parent of the currently being rendered item.
         *
         * @member {PIXI.DisplayObject}
         * @protected
         */
        this._tempDisplayObjectParent = new _pixi_display__WEBPACK_IMPORTED_MODULE_6__.Container();

        /**
         * The last root object that the renderer tried to render.
         *
         * @member {PIXI.DisplayObject}
         * @protected
         */
        this._lastObjectRendered = this._tempDisplayObjectParent;

        /**
         * Collection of plugins.
         * @readonly
         * @member {object}
         */
        this.plugins = {};
    }

    if ( EventEmitter ) AbstractRenderer.__proto__ = EventEmitter;
    AbstractRenderer.prototype = Object.create( EventEmitter && EventEmitter.prototype );
    AbstractRenderer.prototype.constructor = AbstractRenderer;

    var prototypeAccessors = { width: { configurable: true },height: { configurable: true },backgroundColor: { configurable: true } };

    /**
     * Initialize the plugins.
     *
     * @protected
     * @param {object} staticMap - The dictionary of statically saved plugins.
     */
    AbstractRenderer.prototype.initPlugins = function initPlugins (staticMap)
    {
        for (var o in staticMap)
        {
            this.plugins[o] = new (staticMap[o])(this);
        }
    };

    /**
     * Same as view.width, actual number of pixels in the canvas by horizontal.
     *
     * @member {number}
     * @readonly
     * @default 800
     */
    prototypeAccessors.width.get = function ()
    {
        return this.view.width;
    };

    /**
     * Same as view.height, actual number of pixels in the canvas by vertical.
     *
     * @member {number}
     * @readonly
     * @default 600
     */
    prototypeAccessors.height.get = function ()
    {
        return this.view.height;
    };

    /**
     * Resizes the screen and canvas to the specified width and height.
     * Canvas dimensions are multiplied by resolution.
     *
     * @param {number} screenWidth - The new width of the screen.
     * @param {number} screenHeight - The new height of the screen.
     */
    AbstractRenderer.prototype.resize = function resize (screenWidth, screenHeight)
    {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;

        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;

        if (this.autoDensity)
        {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
        }
    };

    /**
     * Useful function that returns a texture of the display object that can then be used to create sprites
     * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
     *
     * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from.
     * @param {number} scaleMode - Should be one of the scaleMode consts.
     * @param {number} resolution - The resolution / device pixel ratio of the texture being generated.
     * @param {PIXI.Rectangle} [region] - The region of the displayObject, that shall be rendered,
     *        if no region is specified, defaults to the local bounds of the displayObject.
     * @return {PIXI.RenderTexture} A texture of the graphics object.
     */
    AbstractRenderer.prototype.generateTexture = function generateTexture (displayObject, scaleMode, resolution, region)
    {
        region = region || displayObject.getLocalBounds();

        // minimum texture size is 1x1, 0x0 will throw an error
        if (region.width === 0) { region.width = 1; }
        if (region.height === 0) { region.height = 1; }

        var renderTexture = RenderTexture.create(region.width | 0, region.height | 0, scaleMode, resolution);

        tempMatrix.tx = -region.x;
        tempMatrix.ty = -region.y;

        this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);

        return renderTexture;
    };

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */
    AbstractRenderer.prototype.destroy = function destroy (removeView)
    {
        for (var o in this.plugins)
        {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        if (removeView && this.view.parentNode)
        {
            this.view.parentNode.removeChild(this.view);
        }

        this.plugins = null;

        this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.RENDERER_TYPE.UNKNOWN;

        this.view = null;

        this.screen = null;

        this.resolution = 0;

        this.transparent = false;

        this.autoDensity = false;

        this.blendModes = null;

        this.options = null;

        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;

        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;

        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
    };

    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     */
    prototypeAccessors.backgroundColor.get = function ()
    {
        return this._backgroundColor;
    };

    prototypeAccessors.backgroundColor.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._backgroundColor = value;
        this._backgroundColorString = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.hex2string)(value);
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.hex2rgb)(value, this._backgroundColorRgba);
    };

    Object.defineProperties( AbstractRenderer.prototype, prototypeAccessors );

    return AbstractRenderer;
}(_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter));

/**
 * The Renderer draws the scene and all its content onto a WebGL enabled canvas.
 *
 * This renderer should be used for browsers that support WebGL.
 *
 * This renderer works by automatically managing WebGLBatchesm, so no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything!
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.AbstractRenderer
 */
var Renderer = /*@__PURE__*/(function (AbstractRenderer) {
    function Renderer(options)
    {
        if ( options === void 0 ) options = {};

        AbstractRenderer.call(this, 'WebGL', options);

        // the options will have been modified here in the super constructor with pixi's default settings..
        options = this.options;

        /**
         * The type of this renderer as a standardized const
         *
         * @member {number}
         * @see PIXI.RENDERER_TYPE
         */
        this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.RENDERER_TYPE.WEBGL;

        // this will be set by the contextSystem (this.context)
        this.gl = null;
        this.CONTEXT_UID = 0;

        // TODO legacy!

        /**
         * Internal signal instances of **runner**, these
         * are assigned to each system created.
         * @see PIXI.Runner
         * @name PIXI.Renderer#runners
         * @private
         * @type {object}
         * @readonly
         * @property {PIXI.Runner} destroy - Destroy runner
         * @property {PIXI.Runner} contextChange - Context change runner
         * @property {PIXI.Runner} reset - Reset runner
         * @property {PIXI.Runner} update - Update runner
         * @property {PIXI.Runner} postrender - Post-render runner
         * @property {PIXI.Runner} prerender - Pre-render runner
         * @property {PIXI.Runner} resize - Resize runner
         */
        this.runners = {
            destroy: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('destroy'),
            contextChange: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('contextChange', 1),
            reset: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('reset'),
            update: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('update'),
            postrender: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('postrender'),
            prerender: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('prerender'),
            resize: new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner('resize', 2),
        };

        /**
         * Global uniforms
         * @member {PIXI.UniformGroup}
         */
        this.globalUniforms = new UniformGroup({
            projectionMatrix: new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix(),
        }, true);

        /**
         * Mask system instance
         * @member {PIXI.systems.MaskSystem} mask
         * @memberof PIXI.Renderer#
         * @readonly
         */
        this.addSystem(MaskSystem, 'mask')
            /**
             * Context system instance
             * @member {PIXI.systems.ContextSystem} context
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(ContextSystem, 'context')
            /**
             * State system instance
             * @member {PIXI.systems.StateSystem} state
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(StateSystem, 'state')
            /**
             * Shader system instance
             * @member {PIXI.systems.ShaderSystem} shader
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(ShaderSystem, 'shader')
            /**
             * Texture system instance
             * @member {PIXI.systems.TextureSystem} texture
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(TextureSystem, 'texture')
            /**
             * Geometry system instance
             * @member {PIXI.systems.GeometrySystem} geometry
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(GeometrySystem, 'geometry')
            /**
             * Framebuffer system instance
             * @member {PIXI.systems.FramebufferSystem} framebuffer
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(FramebufferSystem, 'framebuffer')
            /**
             * Stencil system instance
             * @member {PIXI.systems.StencilSystem} stencil
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(StencilSystem, 'stencil')
            /**
             * Projection system instance
             * @member {PIXI.systems.ProjectionSystem} projection
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(ProjectionSystem, 'projection')
            /**
             * Texture garbage collector system instance
             * @member {PIXI.systems.TextureGCSystem} textureGC
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(TextureGCSystem, 'textureGC')
            /**
             * Filter system instance
             * @member {PIXI.systems.FilterSystem} filter
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(FilterSystem, 'filter')
            /**
             * RenderTexture system instance
             * @member {PIXI.systems.RenderTextureSystem} renderTexture
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(RenderTextureSystem, 'renderTexture')

            /**
             * Batch system instance
             * @member {PIXI.systems.BatchSystem} batch
             * @memberof PIXI.Renderer#
             * @readonly
             */
            .addSystem(BatchSystem, 'batch');

        this.initPlugins(Renderer.__plugins);

        /**
         * The options passed in to create a new WebGL context.
         */
        if (options.context)
        {
            this.context.initFromContext(options.context);
        }
        else
        {
            this.context.initFromOptions({
                alpha: this.transparent,
                antialias: options.antialias,
                premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
                stencil: true,
                preserveDrawingBuffer: options.preserveDrawingBuffer,
                powerPreference: this.options.powerPreference,
            });
        }

        /**
         * Flag if we are rendering to the screen vs renderTexture
         * @member {boolean}
         * @readonly
         * @default true
         */
        this.renderingToScreen = true;

        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.sayHello)(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1');

        this.resize(this.options.width, this.options.height);
    }

    if ( AbstractRenderer ) Renderer.__proto__ = AbstractRenderer;
    Renderer.prototype = Object.create( AbstractRenderer && AbstractRenderer.prototype );
    Renderer.prototype.constructor = Renderer;

    /**
     * Add a new system to the renderer.
     * @param {Function} ClassRef - Class reference
     * @param {string} [name] - Property name for system, if not specified
     *        will use a static `name` property on the class itself. This
     *        name will be assigned as s property on the Renderer so make
     *        sure it doesn't collide with properties on Renderer.
     * @return {PIXI.Renderer} Return instance of renderer
     */
    Renderer.create = function create (options)
    {
        if ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.isWebGLSupported)())
        {
            return new Renderer(options);
        }

        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };

    Renderer.prototype.addSystem = function addSystem (ClassRef, name)
    {
        if (!name)
        {
            name = ClassRef.name;
        }

        var system = new ClassRef(this);

        if (this[name])
        {
            throw new Error(("Whoops! The name \"" + name + "\" is already in use"));
        }

        this[name] = system;

        for (var i in this.runners)
        {
            this.runners[i].add(system);
        }

        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         */

        /**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         */

        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */

        return this;
    };

    /**
     * Renders the object to its WebGL view
     *
     * @param {PIXI.DisplayObject} displayObject - The object to be rendered.
     * @param {PIXI.RenderTexture} [renderTexture] - The render texture to render to.
     * @param {boolean} [clear=true] - Should the canvas be cleared before the new render.
     * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.
     * @param {boolean} [skipUpdateTransform=false] - Should we skip the update transform pass?
     */
    Renderer.prototype.render = function render (displayObject, renderTexture, clear, transform, skipUpdateTransform)
    {
        // can be handy to know!
        this.renderingToScreen = !renderTexture;

        this.runners.prerender.run();
        this.emit('prerender');

        // apply a transform at a GPU level
        this.projection.transform = transform;

        // no point rendering if our context has been blown up!
        if (this.context.isLost)
        {
            return;
        }

        if (!renderTexture)
        {
            this._lastObjectRendered = displayObject;
        }

        if (!skipUpdateTransform)
        {
            // update the scene graph
            var cacheParent = displayObject.parent;

            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
            // displayObject.hitArea = //TODO add a temp hit area
        }

        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();

        if (clear !== undefined ? clear : this.clearBeforeRender)
        {
            this.renderTexture.clear();
        }

        displayObject.render(this);

        // apply transform..
        this.batch.currentRenderer.flush();

        if (renderTexture)
        {
            renderTexture.baseTexture.update();
        }

        this.runners.postrender.run();

        // reset transform after render
        this.projection.transform = null;

        this.emit('postrender');
    };

    /**
     * Resizes the WebGL view to the specified width and height.
     *
     * @param {number} screenWidth - The new width of the screen.
     * @param {number} screenHeight - The new height of the screen.
     */
    Renderer.prototype.resize = function resize (screenWidth, screenHeight)
    {
        AbstractRenderer.prototype.resize.call(this, screenWidth, screenHeight);

        this.runners.resize.run(screenWidth, screenHeight);
    };

    /**
     * Resets the WebGL state so you can render things however you fancy!
     *
     * @return {PIXI.Renderer} Returns itself.
     */
    Renderer.prototype.reset = function reset ()
    {
        this.runners.reset.run();

        return this;
    };

    /**
     * Clear the frame buffer
     */
    Renderer.prototype.clear = function clear ()
    {
        this.framebuffer.bind();
        this.framebuffer.clear();
    };

    /**
     * Removes everything from the renderer (event listeners, spritebatch, etc...)
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     *  See: https://github.com/pixijs/pixi.js/issues/2233
     */
    Renderer.prototype.destroy = function destroy (removeView)
    {
        this.runners.destroy.run();

        for (var r in this.runners)
        {
            this.runners[r].destroy();
        }

        // call base destroy
        AbstractRenderer.prototype.destroy.call(this, removeView);

        // TODO nullify all the managers..
        this.gl = null;
    };

    /**
     * Collection of installed plugins. These are included by default in PIXI, but can be excluded
     * by creating a custom build. Consult the README for more information about creating custom
     * builds and excluding plugins.
     * @name PIXI.Renderer#plugins
     * @type {object}
     * @readonly
     * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
     * @property {PIXI.extract.Extract} extract Extract image data from renderer.
     * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
     * @property {PIXI.prepare.Prepare} prepare Pre-render display objects.
     */

    /**
     * Adds a plugin to the renderer.
     *
     * @method
     * @param {string} pluginName - The name of the plugin.
     * @param {Function} ctor - The constructor function or class for the plugin.
     */
    Renderer.registerPlugin = function registerPlugin (pluginName, ctor)
    {
        Renderer.__plugins = Renderer.__plugins || {};
        Renderer.__plugins[pluginName] = ctor;
    };

    return Renderer;
}(AbstractRenderer));

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If WebGL is not supported by
 * the browser then this function will return a canvas renderer
 *
 * @memberof PIXI
 * @function autoDetectRenderer
 * @param {object} [options] - The optional renderer parameters
 * @param {number} [options.width=800] - the width of the renderers view
 * @param {number} [options.height=600] - the height of the renderers view
 * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
 * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
 * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
 *   resolutions other than 1
 * @param {boolean} [options.antialias=false] - sets antialias
 * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
 *  need to call toDataUrl on the webgl context
 * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
 *  (shown if not transparent).
 * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
 *   not before the new render pass.
 * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
 * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present, this
 *   option only is available when using **pixi.js-legacy** or **@pixi/canvas-renderer** modules, otherwise
 *   it is ignored.
 * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
 *  FXAA is faster, but may not always look as great **webgl only**
 * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
 *  for devices with dual graphics card **webgl only**
 * @return {PIXI.Renderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
 */
function autoDetectRenderer(options)
{
    return Renderer.create(options);
}

var _default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var defaultFilter = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

/**
 * A Texture that depends on six other resources.
 *
 * @class
 * @extends PIXI.BaseTexture
 * @memberof PIXI
 */
var CubeTexture = /*@__PURE__*/(function (BaseTexture) {
    function CubeTexture () {
        BaseTexture.apply(this, arguments);
    }

    if ( BaseTexture ) CubeTexture.__proto__ = BaseTexture;
    CubeTexture.prototype = Object.create( BaseTexture && BaseTexture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.from = function from (resources, options)
    {
        return new CubeTexture(new CubeResource(resources, options));
    };

    return CubeTexture;
}(BaseTexture));

/**
 * Used by the batcher to draw batches.
 * Each one of these contains all information required to draw a bound geometry.
 *
 * @class
 * @memberof PIXI
 */
var BatchDrawCall = function BatchDrawCall()
{
    this.textures = [];
    this.ids = [];
    this.blend = 0;
    this.textureCount = 0;
    this.start = 0;
    this.size = 0;
    this.type = 4;
};

/**
 * Flexible wrapper around `ArrayBuffer` that also provides
 * typed array views on demand.
 *
 * @class
 * @memberof PIXI
 */
var ViewableBuffer = function ViewableBuffer(size)
{
    /**
     * Underlying `ArrayBuffer` that holds all the data
     * and is of capacity `size`.
     *
     * @member {ArrayBuffer}
     */
    this.rawBinaryData = new ArrayBuffer(size);

    /**
     * View on the raw binary data as a `Uint32Array`.
     *
     * @member {Uint32Array}
     */
    this.uint32View = new Uint32Array(this.rawBinaryData);

    /**
     * View on the raw binary data as a `Float32Array`.
     *
     * @member {Float32Array}
     */
    this.float32View = new Float32Array(this.rawBinaryData);
};

var prototypeAccessors$5 = { int8View: { configurable: true },uint8View: { configurable: true },int16View: { configurable: true },uint16View: { configurable: true },int32View: { configurable: true } };

/**
 * View on the raw binary data as a `Int8Array`.
 *
 * @member {Int8Array}
 */
prototypeAccessors$5.int8View.get = function ()
{
    if (!this._int8View)
    {
        this._int8View = new Int8Array(this.rawBinaryData);
    }

    return this._int8View;
};

/**
 * View on the raw binary data as a `Uint8Array`.
 *
 * @member {Uint8Array}
 */
prototypeAccessors$5.uint8View.get = function ()
{
    if (!this._uint8View)
    {
        this._uint8View = new Uint8Array(this.rawBinaryData);
    }

    return this._uint8View;
};

/**
 * View on the raw binary data as a `Int16Array`.
 *
 * @member {Int16Array}
 */
prototypeAccessors$5.int16View.get = function ()
{
    if (!this._int16View)
    {
        this._int16View = new Int16Array(this.rawBinaryData);
    }

    return this._int16View;
};

/**
 * View on the raw binary data as a `Uint16Array`.
 *
 * @member {Uint16Array}
 */
prototypeAccessors$5.uint16View.get = function ()
{
    if (!this._uint16View)
    {
        this._uint16View = new Uint16Array(this.rawBinaryData);
    }

    return this._uint16View;
};

/**
 * View on the raw binary data as a `Int32Array`.
 *
 * @member {Int32Array}
 */
prototypeAccessors$5.int32View.get = function ()
{
    if (!this._int32View)
    {
        this._int32View = new Int32Array(this.rawBinaryData);
    }

    return this._int32View;
};

/**
 * Returns the view of the given type.
 *
 * @param {string} type - One of `int8`, `uint8`, `int16`,
 *`uint16`, `int32`, `uint32`, and `float32`.
 * @return {object} typed array of given type
 */
ViewableBuffer.prototype.view = function view (type)
{
    return this[(type + "View")];
};

/**
 * Destroys all buffer references. Do not use after calling
 * this.
 */
ViewableBuffer.prototype.destroy = function destroy ()
{
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
};

ViewableBuffer.sizeOf = function sizeOf (type)
{
    switch (type)
    {
        case 'int8':
        case 'uint8':
            return 1;
        case 'int16':
        case 'uint16':
            return 2;
        case 'int32':
        case 'uint32':
        case 'float32':
            return 4;
        default:
            throw new Error((type + " isn't a valid view type"));
    }
};

Object.defineProperties( ViewableBuffer.prototype, prototypeAccessors$5 );

/**
 * Renderer dedicated to drawing and batching sprites.
 *
 * This is the default batch renderer. It buffers objects
 * with texture-based geometries and renders them in
 * batches. It uploads multiple textures to the GPU to
 * reduce to the number of draw calls.
 *
 * @class
 * @protected
 * @memberof PIXI
 * @extends PIXI.ObjectRenderer
 */
var AbstractBatchRenderer = /*@__PURE__*/(function (ObjectRenderer) {
    function AbstractBatchRenderer(renderer)
    {
        ObjectRenderer.call(this, renderer);

        /**
         * This is used to generate a shader that can
         * color each vertex based on a `aTextureId`
         * attribute that points to an texture in `uSampler`.
         *
         * This enables the objects with different textures
         * to be drawn in the same draw call.
         *
         * You can customize your shader by creating your
         * custom shader generator.
         *
         * @member {PIXI.BatchShaderGenerator}
         * @protected
         */
        this.shaderGenerator = null;

        /**
         * The class that represents the geometry of objects
         * that are going to be batched with this.
         *
         * @member {object}
         * @default PIXI.BatchGeometry
         * @protected
         */
        this.geometryClass = null;

        /**
         * Size of data being buffered per vertex in the
         * attribute buffers (in floats). By default, the
         * batch-renderer plugin uses 6:
         *
         * | aVertexPosition | 2 |
         * |-----------------|---|
         * | aTextureCoords  | 2 |
         * | aColor          | 1 |
         * | aTextureId      | 1 |
         *
         * @member {number}
         * @readonly
         */
        this.vertexSize = null;

        /**
         * The WebGL state in which this renderer will work.
         *
         * @member {PIXI.State}
         * @readonly
         */
        this.state = State.for2d();

        /**
         * The number of bufferable objects before a flush
         * occurs automatically.
         *
         * @member {number}
         * @default settings.SPRITE_MAX_TEXTURES
         */
        this.size = 2000 * 4;// settings.SPRITE_BATCH_SIZE, 2000 is a nice balance between mobile/desktop

        /**
         * Total count of all vertices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */
        this._vertexCount = 0;

        /**
         * Total count of all indices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */
        this._indexCount = 0;

        /**
         * Buffer of objects that are yet to be rendered.
         *
         * @member {PIXI.DisplayObject[]}
         * @private
         */
        this._bufferedElements = [];

        /**
         * Number of elements that are buffered and are
         * waiting to be flushed.
         *
         * @member {number}
         * @private
         */
        this._bufferSize = 0;

        /**
         * This shader is generated by `this.shaderGenerator`.
         *
         * It is generated specifically to handle the required
         * number of textures being batched together.
         *
         * @member {PIXI.Shader}
         * @protected
         */
        this._shader = null;

        /**
         * Pool of `this.geometryClass` geometry objects
         * that store buffers. They are used to pass data
         * to the shader on each draw call.
         *
         * These are never re-allocated again, unless a
         * context change occurs; however, the pool may
         * be expanded if required.
         *
         * @member {PIXI.Geometry[]}
         * @private
         * @see PIXI.AbstractBatchRenderer.contextChange
         */
        this._packedGeometries = [];

        /**
         * Size of `this._packedGeometries`. It can be expanded
         * if more than `this._packedGeometryPoolSize` flushes
         * occur in a single frame.
         *
         * @member {number}
         * @private
         */
        this._packedGeometryPoolSize = 2;

        /**
         * A flush may occur multiple times in a single
         * frame. On iOS devices or when
         * `settings.CAN_UPLOAD_SAME_BUFFER` is false, the
         * batch renderer does not upload data to the same
         * `WebGLBuffer` for performance reasons.
         *
         * This is the index into `packedGeometries` that points to
         * geometry holding the most recent buffers.
         *
         * @member {number}
         * @private
         */
        this._flushId = 0;

        /**
         * Pool of `BatchDrawCall` objects that `flush` used
         * to create "batches" of the objects being rendered.
         *
         * These are never re-allocated again.
         *
         * @member BatchDrawCall[]
         * @private
         */
        this._drawCalls = [];

        for (var k = 0; k < this.size / 4; k++)
        { // initialize the draw-calls pool to max size.
            this._drawCalls[k] = new BatchDrawCall();
        }

        /**
         * Pool of `ViewableBuffer` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing attributes.
         *
         * The first buffer has a size of 8; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {PIXI.ViewableBuffer}
         * @private
         * @see PIXI.AbstractBatchRenderer#getAttributeBuffer
         */
        this._aBuffers = {};

        /**
         * Pool of `Uint16Array` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing indices.
         *
         * The first buffer has a size of 12; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {Uint16Array[]}
         * @private
         * @see PIXI.AbstractBatchRenderer#getIndexBuffer
         */
        this._iBuffers = {};

        /**
         * Maximum number of textures that can be uploaded to
         * the GPU under the current context. It is initialized
         * properly in `this.contextChange`.
         *
         * @member {number}
         * @see PIXI.AbstractBatchRenderer#contextChange
         * @readonly
         */
        this.MAX_TEXTURES = 1;

        this.renderer.on('prerender', this.onPrerender, this);
        renderer.runners.contextChange.add(this);
    }

    if ( ObjectRenderer ) AbstractBatchRenderer.__proto__ = ObjectRenderer;
    AbstractBatchRenderer.prototype = Object.create( ObjectRenderer && ObjectRenderer.prototype );
    AbstractBatchRenderer.prototype.constructor = AbstractBatchRenderer;

    /**
     * Handles the `contextChange` signal.
     *
     * It calculates `this.MAX_TEXTURES` and allocating the
     * packed-geometry object pool.
     */
    AbstractBatchRenderer.prototype.contextChange = function contextChange ()
    {
        var gl = this.renderer.gl;

        if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.ENV.WEBGL_LEGACY)
        {
            this.MAX_TEXTURES = 1;
        }
        else
        {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(
                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.SPRITE_MAX_TEXTURES);

            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = checkMaxIfStatementsInShader(
                this.MAX_TEXTURES, gl);
        }

        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);

        // we use the second shader as the first one depending on your browser
        // may omit aTextureId as it is not used by the shader so is optimized out.
        for (var i = 0; i < this._packedGeometryPoolSize; i++)
        {
            /* eslint-disable max-len */
            this._packedGeometries[i] = new (this.geometryClass)();
        }
    };

    /**
     * Handles the `prerender` signal.
     *
     * It ensures that flushes start from the first geometry
     * object again.
     */
    AbstractBatchRenderer.prototype.onPrerender = function onPrerender ()
    {
        this._flushId = 0;
    };

    /**
     * Buffers the "batchable" object. It need not be rendered
     * immediately.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when
     *    using this spritebatch
     */
    AbstractBatchRenderer.prototype.render = function render (element)
    {
        if (!element._texture.valid)
        {
            return;
        }

        if (this._vertexCount + (element.vertexData.length / 2) > this.size)
        {
            this.flush();
        }

        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedElements[this._bufferSize++] = element;
    };

    /**
     * Renders the content _now_ and empties the current batch.
     */
    AbstractBatchRenderer.prototype.flush = function flush ()
    {
        if (this._vertexCount === 0)
        {
            return;
        }

        var attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        var indexBuffer = this.getIndexBuffer(this._indexCount);
        var gl = this.renderer.gl;

        var ref = this;
        var elements = ref._bufferedElements;
        var drawCalls = ref._drawCalls;
        var MAX_TEXTURES = ref.MAX_TEXTURES;
        var packedGeometries = ref._packedGeometries;
        var vertexSize = ref.vertexSize;

        var touch = this.renderer.textureGC.count;

        var index = 0;
        var _indexCount = 0;

        var nextTexture;
        var currentTexture;
        var textureCount = 0;

        var currentGroup = drawCalls[0];
        var groupCount = 0;

        var blendMode = -1;// blend-mode of previous element/sprite/object!

        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;

        var TICK = ++BaseTexture._globalBatch;
        var i;

        for (i = 0; i < this._bufferSize; ++i)
        {
            var sprite = elements[i];

            elements[i] = null;
            nextTexture = sprite._texture.baseTexture;

            var spriteBlendMode = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.premultiplyBlendMode[
                nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode];

            if (blendMode !== spriteBlendMode)
            {
                blendMode = spriteBlendMode;

                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }

            if (currentTexture !== nextTexture)
            {
                currentTexture = nextTexture;

                if (nextTexture._batchEnabled !== TICK)
                {
                    if (textureCount === MAX_TEXTURES)
                    {
                        TICK++;

                        textureCount = 0;

                        currentGroup.size = _indexCount - currentGroup.start;

                        currentGroup = drawCalls[groupCount++];
                        currentGroup.textureCount = 0;
                        currentGroup.blend = blendMode;
                        currentGroup.start = _indexCount;
                    }

                    nextTexture.touched = touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;

                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }

            this.packInterleavedGeometry(sprite, attributeBuffer,
                indexBuffer, index, _indexCount);

            // push a graphics..
            index += (sprite.vertexData.length / 2) * vertexSize;
            _indexCount += sprite.indices.length;
        }

        BaseTexture._globalBatch = TICK;
        currentGroup.size = _indexCount - currentGroup.start;

        if (!_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.CAN_UPLOAD_SAME_BUFFER)
        { /* Usually on iOS devices, where the browser doesn't
            like uploads to the same buffer in a single frame. */
            if (this._packedGeometryPoolSize <= this._flushId)
            {
                this._packedGeometryPoolSize++;
                packedGeometries[this._flushId] = new (this.geometryClass)();
            }

            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData, 0);
            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer, 0);

            this.renderer.geometry.bind(packedGeometries[this._flushId]);
            this.renderer.geometry.updateBuffers();
            this._flushId++;
        }
        else
        {
            // lets use the faster option, always use buffer number 0
            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData, 0);
            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer, 0);

            this.renderer.geometry.updateBuffers();
        }

        var textureSystem = this.renderer.texture;
        var stateSystem = this.renderer.state;

        // Upload textures and do the draw calls
        for (i = 0; i < groupCount; i++)
        {
            var group = drawCalls[i];
            var groupTextureCount = group.textureCount;

            for (var j = 0; j < groupTextureCount; j++)
            {
                textureSystem.bind(group.textures[j], j);
                group.textures[j] = null;
            }

            stateSystem.setBlendMode(group.blend);
            gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, group.start * 2);
        }

        // reset elements for the next flush
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
    };

    /**
     * Starts a new sprite batch.
     */
    AbstractBatchRenderer.prototype.start = function start ()
    {
        this.renderer.state.set(this.state);

        this.renderer.shader.bind(this._shader);

        if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.CAN_UPLOAD_SAME_BUFFER)
        {
            // bind buffer #0, we don't need others
            this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
    };

    /**
     * Stops and flushes the current batch.
     */
    AbstractBatchRenderer.prototype.stop = function stop ()
    {
        this.flush();
    };

    /**
     * Destroys this `AbstractBatchRenderer`. It cannot be used again.
     */
    AbstractBatchRenderer.prototype.destroy = function destroy ()
    {
        for (var i = 0; i < this._packedGeometryPoolSize; i++)
        {
            if (this._packedGeometries[i])
            {
                this._packedGeometries[i].destroy();
            }
        }

        this.renderer.off('prerender', this.onPrerender, this);

        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._drawCalls = null;

        if (this._shader)
        {
            this._shader.destroy();
            this._shader = null;
        }

        ObjectRenderer.prototype.destroy.call(this);
    };

    /**
     * Fetches an attribute buffer from `this._aBuffers` that
     * can hold atleast `size` floats.
     *
     * @param {number} size - minimum capacity required
     * @return {ViewableBuffer} - buffer than can hold atleast `size` floats
     * @private
     */
    AbstractBatchRenderer.prototype.getAttributeBuffer = function getAttributeBuffer (size)
    {
        // 8 vertices is enough for 2 quads
        var roundedP2 = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(Math.ceil(size / 8));
        var roundedSizeIndex = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.log2)(roundedP2);
        var roundedSize = roundedP2 * 8;

        if (this._aBuffers.length <= roundedSizeIndex)
        {
            this._iBuffers.length = roundedSizeIndex + 1;
        }

        var buffer = this._aBuffers[roundedSize];

        if (!buffer)
        {
            this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
        }

        return buffer;
    };

    /**
     * Fetches an index buffer from `this._iBuffers` that can
     * has atleast `size` capacity.
     *
     * @param {number} size - minimum required capacity
     * @return {Uint16Array} - buffer that can fit `size`
     *    indices.
     * @private
     */
    AbstractBatchRenderer.prototype.getIndexBuffer = function getIndexBuffer (size)
    {
        // 12 indices is enough for 2 quads
        var roundedP2 = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(Math.ceil(size / 12));
        var roundedSizeIndex = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.log2)(roundedP2);
        var roundedSize = roundedP2 * 12;

        if (this._iBuffers.length <= roundedSizeIndex)
        {
            this._iBuffers.length = roundedSizeIndex + 1;
        }

        var buffer = this._iBuffers[roundedSizeIndex];

        if (!buffer)
        {
            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }

        return buffer;
    };

    /**
     * Takes the four batching parameters of `element`, interleaves
     * and pushes them into the batching attribute/index buffers given.
     *
     * It uses these properties: `vertexData` `uvs`, `textureId` and
     * `indicies`. It also uses the "tint" of the base-texture, if
     * present.
     *
     * @param {PIXI.Sprite} element - element being rendered
     * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
     * @param {Uint16Array} indexBuffer - index buffer
     * @param {number} aIndex - number of floats already in the attribute buffer
     * @param {number} iIndex - number of indices already in `indexBuffer`
     */
    AbstractBatchRenderer.prototype.packInterleavedGeometry = function packInterleavedGeometry (element, attributeBuffer, indexBuffer, aIndex, iIndex)
    {
        var uint32View = attributeBuffer.uint32View;
        var float32View = attributeBuffer.float32View;

        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._id;

        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = (alpha < 1.0
          && element._texture.baseTexture.premultiplyAlpha)
            ? (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.premultiplyTint)(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);

        // lets not worry about tint! for now..
        for (var i = 0; i < vertexData.length; i += 2)
        {
            float32View[aIndex++] = vertexData[i];
            float32View[aIndex++] = vertexData[i + 1];
            float32View[aIndex++] = uvs[i];
            float32View[aIndex++] = uvs[i + 1];
            uint32View[aIndex++] = argb;
            float32View[aIndex++] = textureId;
        }

        for (var i$1 = 0; i$1 < indicies.length; i$1++)
        {
            indexBuffer[iIndex++] = packedVertices + indicies[i$1];
        }
    };

    return AbstractBatchRenderer;
}(ObjectRenderer));

/**
 * Helper that generates batching multi-texture shader. Use it with your new BatchRenderer
 *
 * @class
 * @memberof PIXI
 */
var BatchShaderGenerator = function BatchShaderGenerator(vertexSrc, fragTemplate)
{
    /**
     * Reference to the vertex shader source.
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc;

    /**
     * Reference to the fragement shader template. Must contain "%count%" and "%forloop%".
     *
     * @member {string}
     */
    this.fragTemplate = fragTemplate;

    this.programCache = {};
    this.defaultGroupCache = {};

    if (fragTemplate.indexOf('%count%') < 0)
    {
        throw new Error('Fragment template must contain "%count%".');
    }

    if (fragTemplate.indexOf('%forloop%') < 0)
    {
        throw new Error('Fragment template must contain "%forloop%".');
    }
};

BatchShaderGenerator.prototype.generateShader = function generateShader (maxTextures)
{
    if (!this.programCache[maxTextures])
    {
        var sampleValues = new Int32Array(maxTextures);

        for (var i = 0; i < maxTextures; i++)
        {
            sampleValues[i] = i;
        }

        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);

        var fragmentSrc = this.fragTemplate;

        fragmentSrc = fragmentSrc.replace(/%count%/gi, ("" + maxTextures));
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));

        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }

    var uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new _pixi_math__WEBPACK_IMPORTED_MODULE_5__.Matrix(),
        default: this.defaultGroupCache[maxTextures],
    };

    return new Shader(this.programCache[maxTextures], uniforms);
};

BatchShaderGenerator.prototype.generateSampleSrc = function generateSampleSrc (maxTextures)
{
    var src = '';

    src += '\n';
    src += '\n';

    for (var i = 0; i < maxTextures; i++)
    {
        if (i > 0)
        {
            src += '\nelse ';
        }

        if (i < maxTextures - 1)
        {
            src += "if(vTextureId < " + i + ".5)";
        }

        src += '\n{';
        src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
        src += '\n}';
    }

    src += '\n';
    src += '\n';

    return src;
};

/**
 * Geometry used to batch standard PIXI content (e.g. Mesh, Sprite, Graphics objects).
 *
 * @class
 * @memberof PIXI
 */
var BatchGeometry = /*@__PURE__*/(function (Geometry) {
    function BatchGeometry(_static)
    {
        if ( _static === void 0 ) _static = false;

        Geometry.call(this);

        /**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._buffer = new Buffer(null, _static, false);

        /**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._indexBuffer = new Buffer(null, _static, true);

        this.addAttribute('aVertexPosition', this._buffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.FLOAT)
            .addAttribute('aTextureCoord', this._buffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.FLOAT)
            .addAttribute('aColor', this._buffer, 4, true, _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.UNSIGNED_BYTE)
            .addAttribute('aTextureId', this._buffer, 1, true, _pixi_constants__WEBPACK_IMPORTED_MODULE_3__.TYPES.FLOAT)
            .addIndex(this._indexBuffer);
    }

    if ( Geometry ) BatchGeometry.__proto__ = Geometry;
    BatchGeometry.prototype = Object.create( Geometry && Geometry.prototype );
    BatchGeometry.prototype.constructor = BatchGeometry;

    return BatchGeometry;
}(Geometry));

var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";

var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";

/**
 * @class
 * @memberof PIXI
 * @hideconstructor
 */
var BatchPluginFactory = function BatchPluginFactory () {};

var staticAccessors$1 = { defaultVertexSrc: { configurable: true },defaultFragmentTemplate: { configurable: true } };

BatchPluginFactory.create = function create (options)
{
    var ref = Object.assign({
        vertex: defaultVertex$2,
        fragment: defaultFragment$2,
        geometryClass: BatchGeometry,
        vertexSize: 6,
    }, options);
        var vertex = ref.vertex;
        var fragment = ref.fragment;
        var vertexSize = ref.vertexSize;
        var geometryClass = ref.geometryClass;

    return /*@__PURE__*/(function (AbstractBatchRenderer) {
            function BatchPlugin(renderer)
        {
            AbstractBatchRenderer.call(this, renderer);

            this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);
            this.geometryClass = geometryClass;
            this.vertexSize = vertexSize;
        }

            if ( AbstractBatchRenderer ) BatchPlugin.__proto__ = AbstractBatchRenderer;
            BatchPlugin.prototype = Object.create( AbstractBatchRenderer && AbstractBatchRenderer.prototype );
            BatchPlugin.prototype.constructor = BatchPlugin;

            return BatchPlugin;
        }(AbstractBatchRenderer));
};

/**
 * The default vertex shader source
 *
 * @static
 * @type {string}
 * @constant
 */
staticAccessors$1.defaultVertexSrc.get = function ()
{
    return defaultVertex$2;
};

/**
 * The default fragment shader source
 *
 * @static
 * @type {string}
 * @constant
 */
staticAccessors$1.defaultFragmentTemplate.get = function ()
{
    return defaultFragment$2;
};

Object.defineProperties( BatchPluginFactory, staticAccessors$1 );

// Setup the default BatchRenderer plugin, this is what
// we'll actually export at the root level
var BatchRenderer = BatchPluginFactory.create();


//# sourceMappingURL=core.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/display.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/display/lib/display.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": () => (/* binding */ Bounds),
/* harmony export */   "Container": () => (/* binding */ Container),
/* harmony export */   "DisplayObject": () => (/* binding */ DisplayObject)
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/*!
 * @pixi/display - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */




/**
 * Sets the default value for the container property 'sortableChildren'.
 * If set to true, the container will sort its children by zIndex value
 * when updateTransform() is called, or manually if sortChildren() is called.
 *
 * This actually changes the order of elements in the array, so should be treated
 * as a basic solution that is not performant compared to other solutions,
 * such as @link https://github.com/pixijs/pixi-display
 *
 * Also be aware of that this may not work nicely with the addChildAt() function,
 * as the zIndex sorting may cause the child to automatically sorted to another position.
 *
 * @static
 * @constant
 * @name SORTABLE_CHILDREN
 * @memberof PIXI.settings
 * @type {boolean}
 * @default false
 */
_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.SORTABLE_CHILDREN = false;

/**
 * 'Builder' pattern for bounds rectangles.
 *
 * This could be called an Axis-Aligned Bounding Box.
 * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.
 *
 * @class
 * @memberof PIXI
 */
var Bounds = function Bounds()
{
    /**
     * @member {number}
     * @default 0
     */
    this.minX = Infinity;

    /**
     * @member {number}
     * @default 0
     */
    this.minY = Infinity;

    /**
     * @member {number}
     * @default 0
     */
    this.maxX = -Infinity;

    /**
     * @member {number}
     * @default 0
     */
    this.maxY = -Infinity;

    this.rect = null;
};

/**
 * Checks if bounds are empty.
 *
 * @return {boolean} True if empty.
 */
Bounds.prototype.isEmpty = function isEmpty ()
{
    return this.minX > this.maxX || this.minY > this.maxY;
};

/**
 * Clears the bounds and resets.
 *
 */
Bounds.prototype.clear = function clear ()
{
    this.updateID++;

    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
};

/**
 * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
 * It is not guaranteed that it will return tempRect
 *
 * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
 * @returns {PIXI.Rectangle} A rectangle of the bounds
 */
Bounds.prototype.getRectangle = function getRectangle (rect)
{
    if (this.minX > this.maxX || this.minY > this.maxY)
    {
        return _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle.EMPTY;
    }

    rect = rect || new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle(0, 0, 1, 1);

    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;

    return rect;
};

/**
 * This function should be inlined when its possible.
 *
 * @param {PIXI.Point} point - The point to add.
 */
Bounds.prototype.addPoint = function addPoint (point)
{
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
};

/**
 * Adds a quad, not transformed
 *
 * @param {Float32Array} vertices - The verts to add.
 */
Bounds.prototype.addQuad = function addQuad (vertices)
{
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;

    var x = vertices[0];
    var y = vertices[1];

    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
};

/**
 * Adds sprite frame, transformed.
 *
 * @param {PIXI.Transform} transform - TODO
 * @param {number} x0 - TODO
 * @param {number} y0 - TODO
 * @param {number} x1 - TODO
 * @param {number} y1 - TODO
 */
Bounds.prototype.addFrame = function addFrame (transform, x0, y0, x1, y1)
{
    var matrix = transform.worldTransform;
    var a = matrix.a;
    var b = matrix.b;
    var c = matrix.c;
    var d = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;

    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;

    var x = (a * x0) + (c * y0) + tx;
    var y = (b * x0) + (d * y0) + ty;

    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = (a * x1) + (c * y0) + tx;
    y = (b * x1) + (d * y0) + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = (a * x0) + (c * y1) + tx;
    y = (b * x0) + (d * y1) + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    x = (a * x1) + (c * y1) + tx;
    y = (b * x1) + (d * y1) + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;

    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
};

/**
 * Adds screen vertices from array
 *
 * @param {Float32Array} vertexData - calculated vertices
 * @param {number} beginOffset - begin offset
 * @param {number} endOffset - end offset, excluded
 */
Bounds.prototype.addVertexData = function addVertexData (vertexData, beginOffset, endOffset)
{
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;

    for (var i = beginOffset; i < endOffset; i += 2)
    {
        var x = vertexData[i];
        var y = vertexData[i + 1];

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
    }

    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
};

/**
 * Add an array of mesh vertices
 *
 * @param {PIXI.Transform} transform - mesh transform
 * @param {Float32Array} vertices - mesh coordinates in array
 * @param {number} beginOffset - begin offset
 * @param {number} endOffset - end offset, excluded
 */
Bounds.prototype.addVertices = function addVertices (transform, vertices, beginOffset, endOffset)
{
    var matrix = transform.worldTransform;
    var a = matrix.a;
    var b = matrix.b;
    var c = matrix.c;
    var d = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;

    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;

    for (var i = beginOffset; i < endOffset; i += 2)
    {
        var rawX = vertices[i];
        var rawY = vertices[i + 1];
        var x = (a * rawX) + (c * rawY) + tx;
        var y = (d * rawY) + (b * rawX) + ty;

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
    }

    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
};

/**
 * Adds other Bounds
 *
 * @param {PIXI.Bounds} bounds - TODO
 */
Bounds.prototype.addBounds = function addBounds (bounds)
{
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;

    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
};

/**
 * Adds other Bounds, masked with Bounds
 *
 * @param {PIXI.Bounds} bounds - TODO
 * @param {PIXI.Bounds} mask - TODO
 */
Bounds.prototype.addBoundsMask = function addBoundsMask (bounds, mask)
{
    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;

    if (_minX <= _maxX && _minY <= _maxY)
    {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
    }
};

/**
 * Adds other Bounds, masked with Rectangle
 *
 * @param {PIXI.Bounds} bounds - TODO
 * @param {PIXI.Rectangle} area - TODO
 */
Bounds.prototype.addBoundsArea = function addBoundsArea (bounds, area)
{
    var _minX = bounds.minX > area.x ? bounds.minX : area.x;
    var _minY = bounds.minY > area.y ? bounds.minY : area.y;
    var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);
    var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);

    if (_minX <= _maxX && _minY <= _maxY)
    {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;

        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
    }
};

// _tempDisplayObjectParent = new DisplayObject();

/**
 * The base class for all objects that are rendered on the screen.
 *
 * This is an abstract class and should not be used on its own; rather it should be extended.
 *
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI
 */
var DisplayObject = /*@__PURE__*/(function (EventEmitter) {
    function DisplayObject()
    {
        EventEmitter.call(this);

        this.tempDisplayObjectParent = null;

        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */
        this.transform = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Transform();

        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        this.alpha = 1;

        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */
        this.visible = true;

        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */
        this.renderable = true;

        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        this.parent = null;

        /**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */
        this.worldAlpha = 1;

        /**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */
        this._lastSortedIndex = 0;

        /**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */
        this._zIndex = 0;

        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */
        this.filterArea = null;

        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */
        this.filters = null;
        this._enabledFilters = null;

        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds();
        this._boundsID = 0;
        this._lastBoundsID = -1;
        this._boundsRect = null;
        this._localBoundsRect = null;

        /**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Graphics|PIXI.Sprite|null}
         * @protected
         */
        this._mask = null;

        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */

        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */

        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */
        this._destroyed = false;

        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = false;
    }

    if ( EventEmitter ) DisplayObject.__proto__ = EventEmitter;
    DisplayObject.prototype = Object.create( EventEmitter && EventEmitter.prototype );
    DisplayObject.prototype.constructor = DisplayObject;

    var prototypeAccessors = { _tempDisplayObjectParent: { configurable: true },x: { configurable: true },y: { configurable: true },worldTransform: { configurable: true },localTransform: { configurable: true },position: { configurable: true },scale: { configurable: true },pivot: { configurable: true },skew: { configurable: true },rotation: { configurable: true },angle: { configurable: true },zIndex: { configurable: true },worldVisible: { configurable: true },mask: { configurable: true } };

    /**
     * @protected
     * @member {PIXI.DisplayObject}
     */
    DisplayObject.mixin = function mixin (source)
    {
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));

        // get all the enumerable property keys
        var keys = Object.keys(source);

        // loop through properties
        for (var i = 0; i < keys.length; ++i)
        {
            var propertyName = keys[i];

            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(
                DisplayObject.prototype,
                propertyName,
                Object.getOwnPropertyDescriptor(source, propertyName)
            );
        }
    };

    prototypeAccessors._tempDisplayObjectParent.get = function ()
    {
        if (this.tempDisplayObjectParent === null)
        {
            this.tempDisplayObjectParent = new DisplayObject();
        }

        return this.tempDisplayObjectParent;
    };

    /**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */
    DisplayObject.prototype.updateTransform = function updateTransform ()
    {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        this._bounds.updateID++;
    };

    /**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */
    DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform ()
    {
        if (this.parent)
        {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        }
        else
        {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    };

    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    DisplayObject.prototype.getBounds = function getBounds (skipUpdate, rect)
    {
        if (!skipUpdate)
        {
            if (!this.parent)
            {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            }
            else
            {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }

        if (this._boundsID !== this._lastBoundsID)
        {
            this.calculateBounds();
            this._lastBoundsID = this._boundsID;
        }

        if (!rect)
        {
            if (!this._boundsRect)
            {
                this._boundsRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
            }

            rect = this._boundsRect;
        }

        return this._bounds.getRectangle(rect);
    };

    /**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    DisplayObject.prototype.getLocalBounds = function getLocalBounds (rect)
    {
        var transformRef = this.transform;
        var parentRef = this.parent;

        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;

        if (!rect)
        {
            if (!this._localBoundsRect)
            {
                this._localBoundsRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
            }

            rect = this._localBoundsRect;
        }

        var bounds = this.getBounds(false, rect);

        this.parent = parentRef;
        this.transform = transformRef;

        return bounds;
    };

    /**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.IPoint} A point object representing the position of this object.
     */
    DisplayObject.prototype.toGlobal = function toGlobal (position, point, skipUpdate)
    {
        if ( skipUpdate === void 0 ) skipUpdate = false;

        if (!skipUpdate)
        {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent)
            {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else
            {
                this.displayObjectUpdateTransform();
            }
        }

        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    };

    /**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.IPoint} A point object representing the position of this object
     */
    DisplayObject.prototype.toLocal = function toLocal (position, from, point, skipUpdate)
    {
        if (from)
        {
            position = from.toGlobal(position, point, skipUpdate);
        }

        if (!skipUpdate)
        {
            this._recursivePostUpdateTransform();

            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent)
            {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else
            {
                this.displayObjectUpdateTransform();
            }
        }

        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    };

    /**
     * Renders the object using the WebGL renderer.
     *
     * @param {PIXI.Renderer} renderer - The renderer.
     */
    DisplayObject.prototype.render = function render (renderer) // eslint-disable-line no-unused-vars
    {
        // OVERWRITE;
    };

    /**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */
    DisplayObject.prototype.setParent = function setParent (container)
    {
        if (!container || !container.addChild)
        {
            throw new Error('setParent: Argument must be a Container');
        }

        container.addChild(this);

        return container;
    };

    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */
    DisplayObject.prototype.setTransform = function setTransform (x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY)
    {
        if ( x === void 0 ) x = 0;
        if ( y === void 0 ) y = 0;
        if ( scaleX === void 0 ) scaleX = 1;
        if ( scaleY === void 0 ) scaleY = 1;
        if ( rotation === void 0 ) rotation = 0;
        if ( skewX === void 0 ) skewX = 0;
        if ( skewY === void 0 ) skewY = 0;
        if ( pivotX === void 0 ) pivotX = 0;
        if ( pivotY === void 0 ) pivotY = 0;

        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;

        return this;
    };

    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */
    DisplayObject.prototype.destroy = function destroy ()
    {
        this.removeAllListeners();
        if (this.parent)
        {
            this.parent.removeChild(this);
        }
        this.transform = null;

        this.parent = null;

        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;

        this.filterArea = null;

        this.interactive = false;
        this.interactiveChildren = false;

        this._destroyed = true;
    };

    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */
    prototypeAccessors.x.get = function ()
    {
        return this.position.x;
    };

    prototypeAccessors.x.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.position.x = value;
    };

    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     *
     * @member {number}
     */
    prototypeAccessors.y.get = function ()
    {
        return this.position.y;
    };

    prototypeAccessors.y.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.position.y = value;
    };

    /**
     * Current transform of the object based on world (parent) factors.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    prototypeAccessors.worldTransform.get = function ()
    {
        return this.transform.worldTransform;
    };

    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    prototypeAccessors.localTransform.get = function ()
    {
        return this.transform.localTransform;
    };

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    prototypeAccessors.position.get = function ()
    {
        return this.transform.position;
    };

    prototypeAccessors.position.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.position.copyFrom(value);
    };

    /**
     * The scale factor of the object.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    prototypeAccessors.scale.get = function ()
    {
        return this.transform.scale;
    };

    prototypeAccessors.scale.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.scale.copyFrom(value);
    };

    /**
     * The pivot point of the displayObject that it rotates around.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    prototypeAccessors.pivot.get = function ()
    {
        return this.transform.pivot;
    };

    prototypeAccessors.pivot.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.pivot.copyFrom(value);
    };

    /**
     * The skew factor for the object in radians.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.ObservablePoint}
     */
    prototypeAccessors.skew.get = function ()
    {
        return this.transform.skew;
    };

    prototypeAccessors.skew.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.skew.copyFrom(value);
    };

    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    prototypeAccessors.rotation.get = function ()
    {
        return this.transform.rotation;
    };

    prototypeAccessors.rotation.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.rotation = value;
    };

    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    prototypeAccessors.angle.get = function ()
    {
        return this.transform.rotation * _pixi_math__WEBPACK_IMPORTED_MODULE_1__.RAD_TO_DEG;
    };

    prototypeAccessors.angle.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.transform.rotation = value * _pixi_math__WEBPACK_IMPORTED_MODULE_1__.DEG_TO_RAD;
    };

    /**
     * The zIndex of the displayObject.
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other displayObjects within the same container.
     *
     * @member {number}
     */
    prototypeAccessors.zIndex.get = function ()
    {
        return this._zIndex;
    };

    prototypeAccessors.zIndex.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._zIndex = value;
        if (this.parent)
        {
            this.parent.sortDirty = true;
        }
    };

    /**
     * Indicates if the object is globally visible.
     *
     * @member {boolean}
     * @readonly
     */
    prototypeAccessors.worldVisible.get = function ()
    {
        var item = this;

        do
        {
            if (!item.visible)
            {
                return false;
            }

            item = item.parent;
        } while (item);

        return true;
    };

    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite|null}
     */
    prototypeAccessors.mask.get = function ()
    {
        return this._mask;
    };

    prototypeAccessors.mask.set = function (value) // eslint-disable-line require-jsdoc
    {
        if (this._mask)
        {
            this._mask.renderable = true;
            this._mask.isMask = false;
        }

        this._mask = value;

        if (this._mask)
        {
            this._mask.renderable = false;
            this._mask.isMask = true;
        }
    };

    Object.defineProperties( DisplayObject.prototype, prototypeAccessors );

    return DisplayObject;
}(_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.EventEmitter));

/**
 * DisplayObject default updateTransform, does not update children of container.
 * Will crash if there's no parent element.
 *
 * @memberof PIXI.DisplayObject#
 * @function displayObjectUpdateTransform
 */
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

function sortChildren(a, b)
{
    if (a.zIndex === b.zIndex)
    {
        return a._lastSortedIndex - b._lastSortedIndex;
    }

    return a.zIndex - b.zIndex;
}

/**
 * A Container represents a collection of display objects.
 *
 * It is the base class of all display objects that act as a container for other objects (like Sprites).
 *
 *```js
 * let container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 *
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */
var Container = /*@__PURE__*/(function (DisplayObject) {
    function Container()
    {
        DisplayObject.call(this);

        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        this.children = [];

        /**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */
        this.sortableChildren = _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.SORTABLE_CHILDREN;

        /**
         * Should children be sorted by zIndex at the next updateTransform call.
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */
        this.sortDirty = false;

        /**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         */

        /**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */
    }

    if ( DisplayObject ) Container.__proto__ = DisplayObject;
    Container.prototype = Object.create( DisplayObject && DisplayObject.prototype );
    Container.prototype.constructor = Container;

    var prototypeAccessors = { width: { configurable: true },height: { configurable: true } };

    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */
    Container.prototype.onChildrenChange = function onChildrenChange ()
    {
        /* empty */
    };

    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    Container.prototype.addChild = function addChild (child)
    {
        var arguments$1 = arguments;

        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1)
        {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++)
            {
                this.addChild(arguments$1[i]);
            }
        }
        else
        {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent)
            {
                child.parent.removeChild(child);
            }

            child.parent = this;
            this.sortDirty = true;

            // ensure child transform will be recalculated
            child.transform._parentID = -1;

            this.children.push(child);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            this.emit('childAdded', child, this, this.children.length - 1);
            child.emit('added', this);
        }

        return child;
    };

    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */
    Container.prototype.addChildAt = function addChildAt (child, index)
    {
        if (index < 0 || index > this.children.length)
        {
            throw new Error((child + "addChildAt: The index " + index + " supplied is out of bounds " + (this.children.length)));
        }

        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;
        this.sortDirty = true;

        // ensure child transform will be recalculated
        child.transform._parentID = -1;

        this.children.splice(index, 0, child);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('added', this);
        this.emit('childAdded', child, this, index);

        return child;
    };

    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */
    Container.prototype.swapChildren = function swapChildren (child, child2)
    {
        if (child === child2)
        {
            return;
        }

        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);

        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    };

    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */
    Container.prototype.getChildIndex = function getChildIndex (child)
    {
        var index = this.children.indexOf(child);

        if (index === -1)
        {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }

        return index;
    };

    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */
    Container.prototype.setChildIndex = function setChildIndex (child, index)
    {
        if (index < 0 || index >= this.children.length)
        {
            throw new Error(("The index " + index + " supplied is out of bounds " + (this.children.length)));
        }

        var currentIndex = this.getChildIndex(child);

        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.removeItems)(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position

        this.onChildrenChange(index);
    };

    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */
    Container.prototype.getChildAt = function getChildAt (index)
    {
        if (index < 0 || index >= this.children.length)
        {
            throw new Error(("getChildAt: Index (" + index + ") does not exist."));
        }

        return this.children[index];
    };

    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */
    Container.prototype.removeChild = function removeChild (child)
    {
        var arguments$1 = arguments;

        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1)
        {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++)
            {
                this.removeChild(arguments$1[i]);
            }
        }
        else
        {
            var index = this.children.indexOf(child);

            if (index === -1) { return null; }

            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.removeItems)(this.children, index, 1);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit('removed', this);
            this.emit('childRemoved', child, this, index);
        }

        return child;
    };

    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */
    Container.prototype.removeChildAt = function removeChildAt (index)
    {
        var child = this.getChildAt(index);

        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.removeItems)(this.children, index, 1);

        // ensure bounds will be recalculated
        this._boundsID++;

        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        child.emit('removed', this);
        this.emit('childRemoved', child, this, index);

        return child;
    };

    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {PIXI.DisplayObject[]} List of removed children
     */
    Container.prototype.removeChildren = function removeChildren (beginIndex, endIndex)
    {
        if ( beginIndex === void 0 ) beginIndex = 0;

        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed;

        if (range > 0 && range <= end)
        {
            removed = this.children.splice(begin, range);

            for (var i = 0; i < removed.length; ++i)
            {
                removed[i].parent = null;
                if (removed[i].transform)
                {
                    removed[i].transform._parentID = -1;
                }
            }

            this._boundsID++;

            this.onChildrenChange(beginIndex);

            for (var i$1 = 0; i$1 < removed.length; ++i$1)
            {
                removed[i$1].emit('removed', this);
                this.emit('childRemoved', removed[i$1], this, i$1);
            }

            return removed;
        }
        else if (range === 0 && this.children.length === 0)
        {
            return [];
        }

        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    };

    /**
     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.
     */
    Container.prototype.sortChildren = function sortChildren$1 ()
    {
        var sortRequired = false;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            child._lastSortedIndex = i;

            if (!sortRequired && child.zIndex !== 0)
            {
                sortRequired = true;
            }
        }

        if (sortRequired && this.children.length > 1)
        {
            this.children.sort(sortChildren);
        }

        this.sortDirty = false;
    };

    /**
     * Updates the transform on all children of this container for rendering
     */
    Container.prototype.updateTransform = function updateTransform ()
    {
        if (this.sortableChildren && this.sortDirty)
        {
            this.sortChildren();
        }

        this._boundsID++;

        this.transform.updateTransform(this.parent.transform);

        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            if (child.visible)
            {
                child.updateTransform();
            }
        }
    };

    /**
     * Recalculates the bounds of the container.
     *
     */
    Container.prototype.calculateBounds = function calculateBounds ()
    {
        this._bounds.clear();

        this._calculateBounds();

        for (var i = 0; i < this.children.length; i++)
        {
            var child = this.children[i];

            if (!child.visible || !child.renderable)
            {
                continue;
            }

            child.calculateBounds();

            // TODO: filter+mask, need to mask both somehow
            if (child._mask)
            {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            }
            else if (child.filterArea)
            {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            }
            else
            {
                this._bounds.addBounds(child._bounds);
            }
        }

        this._lastBoundsID = this._boundsID;
    };

    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     * @protected
     */
    Container.prototype._calculateBounds = function _calculateBounds ()
    {
        // FILL IN//
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    Container.prototype.render = function render (renderer)
    {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
        {
            return;
        }

        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || (this.filters && this.filters.length))
        {
            this.renderAdvanced(renderer);
        }
        else
        {
            this._render(renderer);

            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i)
            {
                this.children[i].render(renderer);
            }
        }
    };

    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    Container.prototype.renderAdvanced = function renderAdvanced (renderer)
    {
        renderer.batch.flush();

        var filters = this.filters;
        var mask = this._mask;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters)
        {
            if (!this._enabledFilters)
            {
                this._enabledFilters = [];
            }

            this._enabledFilters.length = 0;

            for (var i = 0; i < filters.length; i++)
            {
                if (filters[i].enabled)
                {
                    this._enabledFilters.push(filters[i]);
                }
            }

            if (this._enabledFilters.length)
            {
                renderer.filter.push(this, this._enabledFilters);
            }
        }

        if (mask)
        {
            renderer.mask.push(this, this._mask);
        }

        // add this object to the batch, only rendered if it has a texture.
        this._render(renderer);

        // now loop through the children and make sure they get rendered
        for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++)
        {
            this.children[i$1].render(renderer);
        }

        renderer.batch.flush();

        if (mask)
        {
            renderer.mask.pop(this, this._mask);
        }

        if (filters && this._enabledFilters && this._enabledFilters.length)
        {
            renderer.filter.pop();
        }
    };

    /**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    Container.prototype._render = function _render (renderer) // eslint-disable-line no-unused-vars
    {
        // this is where content itself gets rendered...
    };

    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    Container.prototype.destroy = function destroy (options)
    {
        DisplayObject.prototype.destroy.call(this);

        this.sortDirty = false;

        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;

        var oldChildren = this.removeChildren(0, this.children.length);

        if (destroyChildren)
        {
            for (var i = 0; i < oldChildren.length; ++i)
            {
                oldChildren[i].destroy(options);
            }
        }
    };

    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    prototypeAccessors.width.get = function ()
    {
        return this.scale.x * this.getLocalBounds().width;
    };

    prototypeAccessors.width.set = function (value) // eslint-disable-line require-jsdoc
    {
        var width = this.getLocalBounds().width;

        if (width !== 0)
        {
            this.scale.x = value / width;
        }
        else
        {
            this.scale.x = 1;
        }

        this._width = value;
    };

    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    prototypeAccessors.height.get = function ()
    {
        return this.scale.y * this.getLocalBounds().height;
    };

    prototypeAccessors.height.set = function (value) // eslint-disable-line require-jsdoc
    {
        var height = this.getLocalBounds().height;

        if (height !== 0)
        {
            this.scale.y = value / height;
        }
        else
        {
            this.scale.y = 1;
        }

        this._height = value;
    };

    Object.defineProperties( Container.prototype, prototypeAccessors );

    return Container;
}(DisplayObject));

// performance increase to avoid using call.. (10x faster)
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;


//# sourceMappingURL=display.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/extract/lib/extract.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/extract/lib/extract.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Extract": () => (/* binding */ Extract)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/*!
 * @pixi/extract - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */




var TEMP_RECT = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
var BYTES_PER_PIXEL = 4;

/**
 * The extract manager provides functionality to export content from the renderers.
 *
 * An instance of this class is automatically created by default, and can be found at `renderer.plugins.extract`
 *
 * @class
 * @memberof PIXI.extract
 */
var Extract = function Extract(renderer)
{
    this.renderer = renderer;
    /**
     * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
     *
     * @member {PIXI.extract.Extract} extract
     * @memberof PIXI.Renderer#
     * @see PIXI.extract.Extract
     */
    renderer.extract = this;
};

/**
 * Will return a HTML Image of the target
 *
 * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
 *  to convert. If left empty will use the main renderer
 * @param {string} [format] - Image format, e.g. "image/jpeg" or "image/webp".
 * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.
 * @return {HTMLImageElement} HTML Image of the target
 */
Extract.prototype.image = function image (target, format, quality)
{
    var image = new Image();

    image.src = this.base64(target, format, quality);

    return image;
};

/**
 * Will return a a base64 encoded string of this target. It works by calling
 *  `Extract.getCanvas` and then running toDataURL on that.
 *
 * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
 *  to convert. If left empty will use the main renderer
 * @param {string} [format] - Image format, e.g. "image/jpeg" or "image/webp".
 * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.
 * @return {string} A base64 encoded string of the texture.
 */
Extract.prototype.base64 = function base64 (target, format, quality)
{
    return this.canvas(target).toDataURL(format, quality);
};

/**
 * Creates a Canvas element, renders this target to it and then returns it.
 *
 * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
 *  to convert. If left empty will use the main renderer
 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
 */
Extract.prototype.canvas = function canvas (target)
{
    var renderer = this.renderer;
    var resolution;
    var frame;
    var flipY = false;
    var renderTexture;
    var generated = false;

    if (target)
    {
        if (target instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture)
        {
            renderTexture = target;
        }
        else
        {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
        }
    }

    if (renderTexture)
    {
        resolution = renderTexture.baseTexture.resolution;
        frame = renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
    }
    else
    {
        resolution = this.renderer.resolution;

        flipY = true;

        frame = TEMP_RECT;
        frame.width = this.renderer.width;
        frame.height = this.renderer.height;

        renderer.renderTexture.bind(null);
    }

    var width = Math.floor(frame.width * resolution);
    var height = Math.floor(frame.height * resolution);

    var canvasBuffer = new _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.CanvasRenderTarget(width, height, 1);

    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

    // read pixels to the array
    var gl = renderer.gl;

    gl.readPixels(
        frame.x * resolution,
        frame.y * resolution,
        width,
        height,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        webglPixels
    );

    // add the pixels to the canvas
    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);

    Extract.arrayPostDivide(webglPixels, canvasData.data);

    canvasBuffer.context.putImageData(canvasData, 0, 0);

    // pulling pixels
    if (flipY)
    {
        canvasBuffer.context.scale(1, -1);
        canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
    }

    if (generated)
    {
        renderTexture.destroy(true);
    }

    // send the canvas back..
    return canvasBuffer.canvas;
};

/**
 * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
 * order, with integer values between 0 and 255 (included).
 *
 * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
 *  to convert. If left empty will use the main renderer
 * @return {Uint8Array} One-dimensional array containing the pixel data of the entire texture
 */
Extract.prototype.pixels = function pixels (target)
{
    var renderer = this.renderer;
    var resolution;
    var frame;
    var renderTexture;
    var generated = false;

    if (target)
    {
        if (target instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture)
        {
            renderTexture = target;
        }
        else
        {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
        }
    }

    if (renderTexture)
    {
        resolution = renderTexture.baseTexture.resolution;
        frame = renderTexture.frame;

        // bind the buffer
        renderer.renderTexture.bind(renderTexture);
    }
    else
    {
        resolution = renderer.resolution;

        frame = TEMP_RECT;
        frame.width = renderer.width;
        frame.height = renderer.height;

        renderer.renderTexture.bind(null);
    }

    var width = frame.width * resolution;
    var height = frame.height * resolution;

    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);

    // read pixels to the array
    var gl = renderer.gl;

    gl.readPixels(
        frame.x * resolution,
        frame.y * resolution,
        width,
        height,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        webglPixels
    );

    if (generated)
    {
        renderTexture.destroy(true);
    }

    Extract.arrayPostDivide(webglPixels, webglPixels);

    return webglPixels;
};

/**
 * Destroys the extract
 *
 */
Extract.prototype.destroy = function destroy ()
{
    this.renderer.extract = null;
    this.renderer = null;
};

/**
 * Takes premultiplied pixel data and produces regular pixel data
 *
 * @private
 * @param pixels {number[] | Uint8Array | Uint8ClampedArray} array of pixel data
 * @param out {number[] | Uint8Array | Uint8ClampedArray} output array
 */
Extract.arrayPostDivide = function arrayPostDivide (pixels, out)
{
    for (var i = 0; i < pixels.length; i += 4)
    {
        var alpha = out[i + 3] = pixels[i + 3];

        if (alpha !== 0)
        {
            out[i] = Math.round(Math.min(pixels[i] * 255.0 / alpha, 255.0));
            out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255.0 / alpha, 255.0));
            out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255.0 / alpha, 255.0));
        }
        else
        {
            out[i] = pixels[i];
            out[i + 1] = pixels[i + 1];
            out[i + 2] = pixels[i + 2];
        }
    }
};

/**
 * This namespace provides renderer-specific plugins for exporting content from a renderer.
 * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).
 *
 * Do not instantiate these plugins directly. It is available from the `renderer.plugins` property.
 * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.
 * @example
 * // Create a new app (will auto-add extract plugin to renderer)
 * const app = new PIXI.Application();
 *
 * // Draw a red circle
 * const graphics = new PIXI.Graphics()
 *     .beginFill(0xFF0000)
 *     .drawCircle(0, 0, 50);
 *
 * // Render the graphics as an HTMLImageElement
 * const image = app.renderer.plugins.extract.image(graphics);
 * document.body.appendChild(image);
 * @namespace PIXI.extract
 */


//# sourceMappingURL=extract.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/filter-alpha.es.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/filter-alpha.es.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlphaFilter": () => (/* binding */ AlphaFilter)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/filter-alpha - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */


var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";

/**
 * Simplest filter - applies alpha.
 *
 * Use this instead of Container's alpha property to avoid visual layering of individual elements.
 * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.
 * If elements are not opaque, they will blend with each other anyway.
 *
 * Very handy if you want to use common features of all filters:
 *
 * 1. Assign a blendMode to this filter, blend all elements inside display object with background.
 *
 * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var AlphaFilter = /*@__PURE__*/(function (Filter) {
    function AlphaFilter(alpha)
    {
        if ( alpha === void 0 ) alpha = 1.0;

        Filter.call(this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultVertex, fragment, { uAlpha: 1 });

        this.alpha = alpha;
    }

    if ( Filter ) AlphaFilter.__proto__ = Filter;
    AlphaFilter.prototype = Object.create( Filter && Filter.prototype );
    AlphaFilter.prototype.constructor = AlphaFilter;

    var prototypeAccessors = { alpha: { configurable: true } };

    /**
     * Coefficient for alpha multiplication
     *
     * @member {number}
     * @default 1
     */
    prototypeAccessors.alpha.get = function ()
    {
        return this.uniforms.uAlpha;
    };

    prototypeAccessors.alpha.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.uAlpha = value;
    };

    Object.defineProperties( AlphaFilter.prototype, prototypeAccessors );

    return AlphaFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));


//# sourceMappingURL=filter-alpha.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/filter-blur.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/filter-blur.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurFilter": () => (/* binding */ BlurFilter),
/* harmony export */   "BlurFilterPass": () => (/* binding */ BlurFilterPass)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/*!
 * @pixi/filter-blur - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";

function generateBlurVertSource(kernelSize, x)
{
    var halfLength = Math.ceil(kernelSize / 2);

    var vertSource = vertTemplate;

    var blurLoop = '';
    var template;
    // let value;

    if (x)
    {
        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);';
    }
    else
    {
        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
    }

    for (var i = 0; i < kernelSize; i++)
    {
        var blur = template.replace('%index%', i);

        // value = i;

        // if(i >= halfLength)
        // {
        //     value = kernelSize - i - 1;
        // }

        blur = blur.replace('%sampleIndex%', ((i - (halfLength - 1)) + ".0"));

        blurLoop += blur;
        blurLoop += '\n';
    }

    vertSource = vertSource.replace('%blur%', blurLoop);
    vertSource = vertSource.replace('%size%', kernelSize);

    return vertSource;
}

var GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
};

var fragTemplate = [
    'varying vec2 vBlurTexCoords[%size%];',
    'uniform sampler2D uSampler;',

    'void main(void)',
    '{',
    '    gl_FragColor = vec4(0.0);',
    '    %blur%',
    '}' ].join('\n');

function generateBlurFragSource(kernelSize)
{
    var kernel = GAUSSIAN_VALUES[kernelSize];
    var halfLength = kernel.length;

    var fragSource = fragTemplate;

    var blurLoop = '';
    var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
    var value;

    for (var i = 0; i < kernelSize; i++)
    {
        var blur = template.replace('%index%', i);

        value = i;

        if (i >= halfLength)
        {
            value = kernelSize - i - 1;
        }

        blur = blur.replace('%value%', kernel[value]);

        blurLoop += blur;
        blurLoop += '\n';
    }

    fragSource = fragSource.replace('%blur%', blurLoop);
    fragSource = fragSource.replace('%size%', kernelSize);

    return fragSource;
}

/**
 * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var BlurFilterPass = /*@__PURE__*/(function (Filter) {
    function BlurFilterPass(horizontal, strength, quality, resolution, kernelSize)
    {
        kernelSize = kernelSize || 5;
        var vertSrc = generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = generateBlurFragSource(kernelSize);

        Filter.call(
            // vertex shader
            this, vertSrc,
            // fragment shader
            fragSrc
        );

        this.horizontal = horizontal;

        this.resolution = resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.RESOLUTION;

        this._quality = 0;

        this.quality = quality || 4;

        this.blur = strength || 8;
    }

    if ( Filter ) BlurFilterPass.__proto__ = Filter;
    BlurFilterPass.prototype = Object.create( Filter && Filter.prototype );
    BlurFilterPass.prototype.constructor = BlurFilterPass;

    var prototypeAccessors = { blur: { configurable: true },quality: { configurable: true } };

    BlurFilterPass.prototype.apply = function apply (filterManager, input, output, clear)
    {
        if (output)
        {
            if (this.horizontal)
            {
                this.uniforms.strength = (1 / output.width) * (output.width / input.width);
            }
            else
            {
                this.uniforms.strength = (1 / output.height) * (output.height / input.height);
            }
        }
        else
        {
            if (this.horizontal) // eslint-disable-line
            {
                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);
            }
            else
            {
                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line
            }
        }

        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;

        if (this.passes === 1)
        {
            filterManager.applyFilter(this, input, output, clear);
        }
        else
        {
            var renderTarget = filterManager.getFilterTexture();
            var renderer = filterManager.renderer;

            var flip = input;
            var flop = renderTarget;

            this.state.blend = false;
            filterManager.applyFilter(this, flip, flop, false);

            for (var i = 1; i < this.passes - 1; i++)
            {
                renderer.renderTexture.bind(flip, flip.filterFrame);

                this.uniforms.uSampler = flop;

                var temp = flop;

                flop = flip;
                flip = temp;

                renderer.shader.bind(this);
                renderer.geometry.draw(5);
            }

            this.state.blend = true;
            filterManager.applyFilter(this, flop, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
    };
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */
    prototypeAccessors.blur.get = function ()
    {
        return this.strength;
    };

    prototypeAccessors.blur.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.padding = 1 + (Math.abs(value) * 2);
        this.strength = value;
    };

    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    prototypeAccessors.quality.get = function ()
    {
        return this._quality;
    };

    prototypeAccessors.quality.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._quality = value;
        this.passes = value;
    };

    Object.defineProperties( BlurFilterPass.prototype, prototypeAccessors );

    return BlurFilterPass;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));

/**
 * The BlurFilter applies a Gaussian blur to an object.
 *
 * The strength of the blur can be set for the x-axis and y-axis separately.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var BlurFilter = /*@__PURE__*/(function (Filter) {
    function BlurFilter(strength, quality, resolution, kernelSize)
    {
        Filter.call(this);

        this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
        this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);

        this.resolution = resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.RESOLUTION;
        this.quality = quality || 4;
        this.blur = strength || 8;

        this.repeatEdgePixels = false;
    }

    if ( Filter ) BlurFilter.__proto__ = Filter;
    BlurFilter.prototype = Object.create( Filter && Filter.prototype );
    BlurFilter.prototype.constructor = BlurFilter;

    var prototypeAccessors = { blur: { configurable: true },quality: { configurable: true },blurX: { configurable: true },blurY: { configurable: true },blendMode: { configurable: true },repeatEdgePixels: { configurable: true } };

    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    BlurFilter.prototype.apply = function apply (filterManager, input, output, clear)
    {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);

        if (xStrength && yStrength)
        {
            var renderTarget = filterManager.getFilterTexture();

            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, clear);

            filterManager.returnFilterTexture(renderTarget);
        }
        else if (yStrength)
        {
            this.blurYFilter.apply(filterManager, input, output, clear);
        }
        else
        {
            this.blurXFilter.apply(filterManager, input, output, clear);
        }
    };

    BlurFilter.prototype.updatePadding = function updatePadding ()
    {
        if (this._repeatEdgePixels)
        {
            this.padding = 0;
        }
        else
        {
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
    };

    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    prototypeAccessors.blur.get = function ()
    {
        return this.blurXFilter.blur;
    };

    prototypeAccessors.blur.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
    };

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    prototypeAccessors.quality.get = function ()
    {
        return this.blurXFilter.quality;
    };

    prototypeAccessors.quality.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
    };

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    prototypeAccessors.blurX.get = function ()
    {
        return this.blurXFilter.blur;
    };

    prototypeAccessors.blurX.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.blurXFilter.blur = value;
        this.updatePadding();
    };

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    prototypeAccessors.blurY.get = function ()
    {
        return this.blurYFilter.blur;
    };

    prototypeAccessors.blurY.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.blurYFilter.blur = value;
        this.updatePadding();
    };

    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    prototypeAccessors.blendMode.get = function ()
    {
        return this.blurYFilter.blendMode;
    };

    prototypeAccessors.blendMode.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.blurYFilter.blendMode = value;
    };

    /**
     * If set to true the edge of the target will be clamped
     *
     * @member {bool}
     * @default false
     */
    prototypeAccessors.repeatEdgePixels.get = function ()
    {
        return this._repeatEdgePixels;
    };

    prototypeAccessors.repeatEdgePixels.set = function (value)
    {
        this._repeatEdgePixels = value;
        this.updatePadding();
    };

    Object.defineProperties( BlurFilter.prototype, prototypeAccessors );

    return BlurFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));


//# sourceMappingURL=filter-blur.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/filter-color-matrix.es.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/filter-color-matrix.es.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorMatrixFilter": () => (/* binding */ ColorMatrixFilter)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/filter-color-matrix - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */


var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";

/**
 * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * ```js
 *  let colorMatrix = new PIXI.filters.ColorMatrixFilter();
 *  container.filters = [colorMatrix];
 *  colorMatrix.contrast(2);
 * ```
 * @author Clément Chenebault <clement@goodboydigital.com>
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var ColorMatrixFilter = /*@__PURE__*/(function (Filter) {
    function ColorMatrixFilter()
    {
        var uniforms = {
            m: new Float32Array([1, 0, 0, 0, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0]),
            uAlpha: 1,
        };

        Filter.call(this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultFilterVertex, fragment, uniforms);

        this.alpha = 1;
    }

    if ( Filter ) ColorMatrixFilter.__proto__ = Filter;
    ColorMatrixFilter.prototype = Object.create( Filter && Filter.prototype );
    ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;

    var prototypeAccessors = { matrix: { configurable: true },alpha: { configurable: true } };

    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype._loadMatrix = function _loadMatrix (matrix, multiply)
    {
        if ( multiply === void 0 ) multiply = false;

        var newMatrix = matrix;

        if (multiply)
        {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }

        // set the new matrix
        this.uniforms.m = newMatrix;
    };

    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    ColorMatrixFilter.prototype._multiply = function _multiply (out, a, b)
    {
        // Red Channel
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];

        // Green Channel
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];

        // Blue Channel
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];

        // Alpha Channel
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];

        return out;
    };

    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    ColorMatrixFilter.prototype._colorMatrix = function _colorMatrix (matrix)
    {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);

        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;

        return m;
    };

    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.brightness = function brightness (b, multiply)
    {
        var matrix = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.greyscale = function greyscale (scale, multiply)
    {
        var matrix = [
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.blackAndWhite = function blackAndWhite (multiply)
    {
        var matrix = [
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.hue = function hue (rotation, multiply)
    {
        rotation = (rotation || 0) / 180 * Math.PI;

        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;

        /* a good approximation for hue rotation
         This matrix is far better than the versions with magic luminance constants
         formerly used here, but also used in the starling framework (flash) and known from this
         old part of the internet: quasimondo.com/archives/000565.php

         This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
         implementation as a shader not a general matrix:
         https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js

         This is the source for the code:
         see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
         */

        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is

        var a00 = cosR + ((1.0 - cosR) * w);
        var a01 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a02 = (w * (1.0 - cosR)) + (sqrW * sinR);

        var a10 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a11 = cosR + (w * (1.0 - cosR));
        var a12 = (w * (1.0 - cosR)) - (sqrW * sinR);

        var a20 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a21 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a22 = cosR + (w * (1.0 - cosR));

        var matrix = [
            a00, a01, a02, 0, 0,
            a10, a11, a12, 0, 0,
            a20, a21, a22, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.contrast = function contrast (amount, multiply)
    {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);

        var matrix = [
            v, 0, 0, 0, o,
            0, v, 0, 0, o,
            0, 0, v, 0, o,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.saturate = function saturate (amount, multiply)
    {
        if ( amount === void 0 ) amount = 0;

        var x = (amount * 2 / 3) + 1;
        var y = ((x - 1) * -0.5);

        var matrix = [
            x, y, y, 0, 0,
            y, x, y, 0, 0,
            y, y, x, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    ColorMatrixFilter.prototype.desaturate = function desaturate () // eslint-disable-line no-unused-vars
    {
        this.saturate(-1);
    };

    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.negative = function negative (multiply)
    {
        var matrix = [
            -1, 0, 0, 1, 0,
            0, -1, 0, 1, 0,
            0, 0, -1, 1, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.sepia = function sepia (multiply)
    {
        var matrix = [
            0.393, 0.7689999, 0.18899999, 0, 0,
            0.349, 0.6859999, 0.16799999, 0, 0,
            0.272, 0.5339999, 0.13099999, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.technicolor = function technicolor (multiply)
    {
        var matrix = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.polaroid = function polaroid (multiply)
    {
        var matrix = [
            1.438, -0.062, -0.062, 0, 0,
            -0.122, 1.378, -0.122, 0, 0,
            -0.016, -0.016, 1.483, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.toBGR = function toBGR (multiply)
    {
        var matrix = [
            0, 0, 1, 0, 0,
            0, 1, 0, 0, 0,
            1, 0, 0, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.kodachrome = function kodachrome (multiply)
    {
        var matrix = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.browni = function browni (multiply)
    {
        var matrix = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.vintage = function vintage (multiply)
    {
        var matrix = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.colorTone = function colorTone (desaturation, toned, lightColor, darkColor, multiply)
    {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;

        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;

        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;

        var matrix = [
            0.3, 0.59, 0.11, 0, 0,
            lR, lG, lB, desaturation, 0,
            dR, dG, dB, toned, 0,
            lR - dR, lG - dG, lB - dB, 0, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.night = function night (intensity, multiply)
    {
        intensity = intensity || 0.1;
        var matrix = [
            intensity * (-2.0), -intensity, 0, 0, 0,
            -intensity, 0, intensity, 0, 0,
            0, intensity, intensity * 2.0, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.predator = function predator (amount, multiply)
    {
        var matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    ColorMatrixFilter.prototype.lsd = function lsd (multiply)
    {
        var matrix = [
            2, -0.4, 0.5, 0, 0,
            -0.5, 2, -0.4, 0, 0,
            -0.4, -0.5, 3, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, multiply);
    };

    /**
     * Erase the current matrix by setting the default one
     *
     */
    ColorMatrixFilter.prototype.reset = function reset ()
    {
        var matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0 ];

        this._loadMatrix(matrix, false);
    };

    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    prototypeAccessors.matrix.get = function ()
    {
        return this.uniforms.m;
    };

    prototypeAccessors.matrix.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.m = value;
    };

    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    prototypeAccessors.alpha.get = function ()
    {
        return this.uniforms.uAlpha;
    };

    prototypeAccessors.alpha.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.uAlpha = value;
    };

    Object.defineProperties( ColorMatrixFilter.prototype, prototypeAccessors );

    return ColorMatrixFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));

// Americanized alias
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;


//# sourceMappingURL=filter-color-matrix.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/filter-displacement.es.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/filter-displacement.es.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplacementFilter": () => (/* binding */ DisplacementFilter)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/*!
 * @pixi/filter-displacement - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



var vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";

var fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";

/**
 * The DisplacementFilter class uses the pixel values from the specified texture
 * (called the displacement map) to perform a displacement of an object.
 *
 * You can use this filter to apply all manor of crazy warping effects.
 * Currently the `r` property of the texture is used to offset the `x`
 * and the `g` property of the texture is used to offset the `y`.
 *
 * The way it works is it uses the values of the displacement map to look up the
 * correct pixels to output. This means it's not technically moving the original.
 * Instead, it's starting at the output and asking "which pixel from the original goes here".
 * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,
 * this filter will output the pixel approximately 20 pixels to the right of the original.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var DisplacementFilter = /*@__PURE__*/(function (Filter) {
    function DisplacementFilter(sprite, scale)
    {
        var maskMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();

        sprite.renderable = false;

        Filter.call(this, vertex, fragment, {
            mapSampler: sprite._texture,
            filterMatrix: maskMatrix,
            scale: { x: 1, y: 1 },
            rotation: new Float32Array([1, 0, 0, 1]),
        });

        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;

        if (scale === null || scale === undefined)
        {
            scale = 20;
        }

        /**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */
        this.scale = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point(scale, scale);
    }

    if ( Filter ) DisplacementFilter.__proto__ = Filter;
    DisplacementFilter.prototype = Object.create( Filter && Filter.prototype );
    DisplacementFilter.prototype.constructor = DisplacementFilter;

    var prototypeAccessors = { map: { configurable: true } };

    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    DisplacementFilter.prototype.apply = function apply (filterManager, input, output, clear)
    {
        // fill maskMatrix with _normalized sprite texture coords_
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;

        // Extract rotation from world transform
        var wt = this.maskSprite.transform.worldTransform;
        var lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));
        var lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));

        if (lenX !== 0 && lenY !== 0)
        {
            this.uniforms.rotation[0] = wt.a / lenX;
            this.uniforms.rotation[1] = wt.b / lenX;
            this.uniforms.rotation[2] = wt.c / lenY;
            this.uniforms.rotation[3] = wt.d / lenY;
        }

        // draw the filter...
        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */
    prototypeAccessors.map.get = function ()
    {
        return this.uniforms.mapSampler;
    };

    prototypeAccessors.map.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.mapSampler = value;
    };

    Object.defineProperties( DisplacementFilter.prototype, prototypeAccessors );

    return DisplacementFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));


//# sourceMappingURL=filter-displacement.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/filter-fxaa.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/filter-fxaa.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FXAAFilter": () => (/* binding */ FXAAFilter)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/filter-fxaa - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */


var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";

var fragment = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";

/**
 * Basic FXAA (Fast Approximate Anti-Aliasing) implementation based on the code on geeks3d.com
 * with the modification that the texture2DLod stuff was removed since it is unsupported by WebGL.
 *
 * @see https://github.com/mitsuhiko/webgl-meincraft
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 *
 */
var FXAAFilter = /*@__PURE__*/(function (Filter) {
    function FXAAFilter()
    {
        // TODO - needs work
        Filter.call(this, vertex, fragment);
    }

    if ( Filter ) FXAAFilter.__proto__ = Filter;
    FXAAFilter.prototype = Object.create( Filter && Filter.prototype );
    FXAAFilter.prototype.constructor = FXAAFilter;

    return FXAAFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));


//# sourceMappingURL=filter-fxaa.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/filter-noise.es.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/filter-noise.es.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NoiseFilter": () => (/* binding */ NoiseFilter)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/filter-noise - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */


var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";

/**
 * @author Vico @vicocotea
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
 */

/**
 * A Noise effect filter.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */
var NoiseFilter = /*@__PURE__*/(function (Filter) {
    function NoiseFilter(noise, seed)
    {
        if ( noise === void 0 ) noise = 0.5;
        if ( seed === void 0 ) seed = Math.random();

        Filter.call(this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultFilterVertex, fragment, {
            uNoise: 0,
            uSeed: 0,
        });

        this.noise = noise;
        this.seed = seed;
    }

    if ( Filter ) NoiseFilter.__proto__ = Filter;
    NoiseFilter.prototype = Object.create( Filter && Filter.prototype );
    NoiseFilter.prototype.constructor = NoiseFilter;

    var prototypeAccessors = { noise: { configurable: true },seed: { configurable: true } };

    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     *
     * @member {number}
     * @default 0.5
     */
    prototypeAccessors.noise.get = function ()
    {
        return this.uniforms.uNoise;
    };

    prototypeAccessors.noise.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.uNoise = value;
    };

    /**
     * A seed value to apply to the random noise generation. `Math.random()` is a good value to use.
     *
     * @member {number}
     */
    prototypeAccessors.seed.get = function ()
    {
        return this.uniforms.uSeed;
    };

    prototypeAccessors.seed.set = function (value) // eslint-disable-line require-jsdoc
    {
        this.uniforms.uSeed = value;
    };

    Object.defineProperties( NoiseFilter.prototype, prototypeAccessors );

    return NoiseFilter;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter));


//# sourceMappingURL=filter-noise.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/graphics.es.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/graphics.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillStyle": () => (/* binding */ FillStyle),
/* harmony export */   "GRAPHICS_CURVES": () => (/* binding */ GRAPHICS_CURVES),
/* harmony export */   "Graphics": () => (/* binding */ Graphics),
/* harmony export */   "GraphicsData": () => (/* binding */ GraphicsData),
/* harmony export */   "GraphicsGeometry": () => (/* binding */ GraphicsGeometry),
/* harmony export */   "LineStyle": () => (/* binding */ LineStyle)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/constants.es.js");
/*!
 * @pixi/graphics - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */






/**
 * Graphics curves resolution settings. If `adaptive` flag is set to `true`,
 * the resolution is calculated based on the curve's length to ensure better visual quality.
 * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name GRAPHICS_CURVES
 * @type {object}
 * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
 * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
 * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
 * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
 */
var GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    _segmentsCount: function _segmentsCount(length, defaultSegments)
    {
        if ( defaultSegments === void 0 ) defaultSegments = 20;

        if (!this.adaptive)
        {
            return defaultSegments;
        }

        var result = Math.ceil(length / this.maxLength);

        if (result < this.minSegments)
        {
            result = this.minSegments;
        }
        else if (result > this.maxSegments)
        {
            result = this.maxSegments;
        }

        return result;
    },
};

/**
 * Fill style object for Graphics.
 *
 * @class
 * @memberof PIXI
 */
var FillStyle = function FillStyle()
{
    this.reset();
};

/**
 * Clones the object
 *
 * @return {PIXI.FillStyle}
 */
FillStyle.prototype.clone = function clone ()
{
    var obj = new FillStyle();

    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;

    return obj;
};

/**
 * Reset
 */
FillStyle.prototype.reset = function reset ()
{
    /**
     * The hex color value used when coloring the Graphics object.
     *
     * @member {number}
     * @default 1
     */
    this.color = 0xFFFFFF;

    /**
     * The alpha value used when filling the Graphics object.
     *
     * @member {number}
     * @default 1
     */
    this.alpha = 1;

    /**
     * The texture to be used for the fill.
     *
     * @member {string}
     * @default 0
     */
    this.texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE;

    /**
     * The transform aplpied to the texture.
     *
     * @member {string}
     * @default 0
     */
    this.matrix = null;

    /**
     * If the current fill is visible.
     *
     * @member {boolean}
     * @default false
     */
    this.visible = false;
};

/**
 * Destroy and don't use after this
 */
FillStyle.prototype.destroy = function destroy ()
{
    this.texture = null;
    this.matrix = null;
};

/**
 * A class to contain data useful for Graphics objects
 *
 * @class
 * @memberof PIXI
 */
var GraphicsData = function GraphicsData(shape, fillStyle, lineStyle, matrix)
{
    if ( fillStyle === void 0 ) fillStyle = null;
    if ( lineStyle === void 0 ) lineStyle = null;
    if ( matrix === void 0 ) matrix = null;

    /**
     * The shape object to draw.
     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
     */
    this.shape = shape;

    /**
     * The style of the line.
     * @member {PIXI.LineStyle}
     */
    this.lineStyle = lineStyle;

    /**
     * The style of the fill.
     * @member {PIXI.FillStyle}
     */
    this.fillStyle = fillStyle;

    /**
     * The transform matrix.
     * @member {PIXI.Matrix}
     */
    this.matrix = matrix;

    /**
     * The type of the shape, see the Const.Shapes file for all the existing types,
     * @member {number}
     */
    this.type = shape.type;

    /**
     * The collection of points.
     * @member {number[]}
     */
    this.points = [];

    /**
     * The collection of holes.
     * @member {PIXI.GraphicsData[]}
     */
    this.holes = [];
};

/**
 * Creates a new GraphicsData object with the same values as this one.
 *
 * @return {PIXI.GraphicsData} Cloned GraphicsData object
 */
GraphicsData.prototype.clone = function clone ()
{
    return new GraphicsData(
        this.shape,
        this.fillStyle,
        this.lineStyle,
        this.matrix
    );
};

/**
 * Destroys the Graphics data.
 */
GraphicsData.prototype.destroy = function destroy ()
{
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
};

/**
 * Builds a circle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */
var buildCircle = {

    build: function build(graphicsData)
    {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;

        points.length = 0;

        // TODO - bit hacky??
        if (graphicsData.type === _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRC)
        {
            width = circleData.radius;
            height = circleData.radius;
        }
        else
        {
            width = circleData.width;
            height = circleData.height;
        }

        if (width === 0 || height === 0)
        {
            return;
        }

        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))
            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

        totalSegs /= 2.3;

        var seg = (Math.PI * 2) / totalSegs;

        for (var i = 0; i < totalSegs; i++)
        {
            points.push(
                x + (Math.sin(-seg * i) * width),
                y + (Math.cos(-seg * i) * height)
            );
        }

        points.push(
            points[0],
            points[1]
        );
    },

    triangulate: function triangulate(graphicsData, graphicsGeometry)
    {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;

        var vertPos = verts.length / 2;
        var center = vertPos;

        verts.push(graphicsData.shape.x, graphicsData.shape.y);

        for (var i = 0; i < points.length; i += 2)
        {
            verts.push(points[i], points[i + 1]);

            // add some uvs
            indices.push(vertPos++, center, vertPos);
        }
    },
};

/**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
function buildLine (graphicsData, graphicsGeometry)
{
    if (graphicsData.lineStyle.native)
    {
        buildNativeLine(graphicsData, graphicsGeometry);
    }
    else
    {
        buildLine$1(graphicsData, graphicsGeometry);
    }
}

/**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
function buildLine$1(graphicsData, graphicsGeometry)
{
    var shape = graphicsData.shape;
    var points = graphicsData.points || shape.points.slice();
    var eps = graphicsGeometry.closePointEps;

    if (points.length === 0)
    {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    var style = graphicsData.lineStyle;

    // get first and last point.. figure out the middle!
    var firstPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point(points[0], points[1]);
    var lastPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point(points[points.length - 2], points[points.length - 1]);
    var closedShape = shape.type !== _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLY || shape.closeStroke;
    var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps
        && Math.abs(firstPoint.y - lastPoint.y) < eps;

    // if the first point is the last point - gonna have issues :)
    if (closedShape)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        if (closedPath)
        {
            points.pop();
            points.pop();
            lastPoint.set(points[points.length - 2], points[points.length - 1]);
        }

        var midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);
        var midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = graphicsGeometry.points;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 2;

    // DRAW the Line
    var width = style.width / 2;

    // sort color
    var p1x = points[0];
    var p1y = points[1];
    var p2x = points[2];
    var p2y = points[3];
    var p3x = 0;
    var p3y = 0;

    var perpx = -(p1y - p2y);
    var perpy = p1x - p2x;
    var perp2x = 0;
    var perp2y = 0;
    var perp3x = 0;
    var perp3y = 0;

    var dist = Math.sqrt((perpx * perpx) + (perpy * perpy));

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    var ratio = style.alignment;// 0.5;
    var r1 = (1 - ratio) * 2;
    var r2 = ratio * 2;

    // start
    verts.push(
        p1x - (perpx * r1),
        p1y - (perpy * r1));

    verts.push(
        p1x + (perpx * r2),
        p1y + (perpy * r2));

    for (var i = 1; i < length - 1; ++i)
    {
        p1x = points[(i - 1) * 2];
        p1y = points[((i - 1) * 2) + 1];

        p2x = points[i * 2];
        p2y = points[(i * 2) + 1];

        p3x = points[(i + 1) * 2];
        p3y = points[((i + 1) * 2) + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        var a1 = (-perpy + p1y) - (-perpy + p2y);
        var b1 = (-perpx + p2x) - (-perpx + p1x);
        var c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));
        var a2 = (-perp2y + p3y) - (-perp2y + p2y);
        var b2 = (-perp2x + p2x) - (-perp2x + p3x);
        var c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));

        var denom = (a1 * b2) - (a2 * b1);

        if (Math.abs(denom) < 0.1)
        {
            denom += 10.1;
            verts.push(
                p2x - (perpx * r1),
                p2y - (perpy * r1));

            verts.push(
                p2x + (perpx * r2),
                p2y + (perpy * r2));

            continue;
        }

        var px = ((b1 * c2) - (b2 * c1)) / denom;
        var py = ((a2 * c1) - (a1 * c2)) / denom;
        var pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));

        if (pdist > (196 * width * width))
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));

            verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));

            verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));

            indexCount++;
        }
        else
        {
            verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));

            verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));
        }
    }

    p1x = points[(length - 2) * 2];
    p1y = points[((length - 2) * 2) + 1];

    p2x = points[(length - 1) * 2];
    p2y = points[((length - 1) * 2) + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - (perpx * r1), p2y - (perpy * r1));

    verts.push(p2x + (perpx * r2), p2y + (perpy * r2));

    var indices = graphicsGeometry.indices;

    // indices.push(indexStart);

    for (var i$1 = 0; i$1 < indexCount - 2; ++i$1)
    {
        indices.push(indexStart, indexStart + 1, indexStart + 2);

        indexStart++;
    }
}

/**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
function buildNativeLine(graphicsData, graphicsGeometry)
{
    var i = 0;

    var shape = graphicsData.shape;
    var points = graphicsData.points || shape.points;
    var closedShape = shape.type !== _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLY || shape.closeStroke;

    if (points.length === 0) { return; }

    var verts = graphicsGeometry.points;
    var indices = graphicsGeometry.indices;
    var length = points.length / 2;

    var startIndex = verts.length / 2;
    var currentIndex = startIndex;

    verts.push(points[0], points[1]);

    for (i = 1; i < length; i++)
    {
        verts.push(points[i * 2], points[(i * 2) + 1]);
        indices.push(currentIndex, currentIndex + 1);

        currentIndex++;
    }

    if (closedShape)
    {
        indices.push(currentIndex, startIndex);
    }
}

/**
 * Builds a polygon to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */
var buildPoly = {

    build: function build(graphicsData)
    {
        graphicsData.points = graphicsData.shape.points.slice();
    },

    triangulate: function triangulate(graphicsData, graphicsGeometry)
    {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;

        if (points.length >= 6)
        {
            var holeArray = [];
            // Process holes..

            for (var i = 0; i < holes.length; i++)
            {
                var hole = holes[i];

                holeArray.push(points.length / 2);
                points = points.concat(hole.points);
            }

            // sort color
            var triangles = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.earcut)(points, holeArray, 2);

            if (!triangles)
            {
                return;
            }

            var vertPos = verts.length / 2;

            for (var i$1 = 0; i$1 < triangles.length; i$1 += 3)
            {
                indices.push(triangles[i$1] + vertPos);
                indices.push(triangles[i$1 + 1] + vertPos);
                indices.push(triangles[i$1 + 2] + vertPos);
            }

            for (var i$2 = 0; i$2 < points.length; i$2++)
            {
                verts.push(points[i$2]);
            }
        }
    },
};

/**
 * Builds a rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */
var buildRectangle = {

    build: function build(graphicsData)
    {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;

        var points = graphicsData.points;

        points.length = 0;

        points.push(x, y,
            x + width, y,
            x + width, y + height,
            x, y + height);
    },

    triangulate: function triangulate(graphicsData, graphicsGeometry)
    {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;

        var vertPos = verts.length / 2;

        verts.push(points[0], points[1],
            points[2], points[3],
            points[6], points[7],
            points[4], points[5]);

        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,
            vertPos + 1, vertPos + 2, vertPos + 3);
    },
};

/**
 * Builds a rounded rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */
var buildRoundedRectangle = {

    build: function build(graphicsData)
    {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;

        var radius = rrectData.radius;

        points.length = 0;

        quadraticBezierCurve(x, y + radius,
            x, y,
            x + radius, y,
            points);
        quadraticBezierCurve(x + width - radius,
            y, x + width, y,
            x + width, y + radius,
            points);
        quadraticBezierCurve(x + width, y + height - radius,
            x + width, y + height,
            x + width - radius, y + height,
            points);
        quadraticBezierCurve(x + radius, y + height,
            x, y + height,
            x, y + height - radius,
            points);

        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    },

    triangulate: function triangulate(graphicsData, graphicsGeometry)
    {
        var points = graphicsData.points;

        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;

        var vecPos = verts.length / 2;

        var triangles = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.earcut)(points, null, 2);

        for (var i = 0, j = triangles.length; i < j; i += 3)
        {
            indices.push(triangles[i] + vecPos);
            //     indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            //   indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }

        for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++)
        {
            verts.push(points[i$1], points[++i$1]);
        }
    },
};

/**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
function getPt(n1, n2, perc)
{
    var diff = n2 - n1;

    return n1 + (diff * perc);
}

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out)
{
    if ( out === void 0 ) out = [];

    var n = 20;
    var points = out;

    var xa = 0;
    var ya = 0;
    var xb = 0;
    var yb = 0;
    var x = 0;
    var y = 0;

    for (var i = 0, j = 0; i <= n; ++i)
    {
        j = i / n;

        // The Green Line
        xa = getPt(fromX, cpX, j);
        ya = getPt(fromY, cpY, j);
        xb = getPt(cpX, toX, j);
        yb = getPt(cpY, toY, j);

        // The Black Dot
        x = getPt(xa, xb, j);
        y = getPt(ya, yb, j);

        points.push(x, y);
    }

    return points;
}

var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
var tmpPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point();

/**
 * Map of fill commands for each shape type.
 *
 * @member {Object}
 * @private
 */
var fillCommands = {};

fillCommands[_pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLY] = buildPoly;
fillCommands[_pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRC] = buildCircle;
fillCommands[_pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.ELIP] = buildCircle;
fillCommands[_pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.RECT] = buildRectangle;
fillCommands[_pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.RREC] = buildRoundedRectangle;

/**
 * A little internal structure to hold interim batch objects.
 *
 * @private
 */
var BatchPart = function BatchPart()
{
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
};

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive
 * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.
 *
 * @class
 * @extends PIXI.BatchGeometry
 * @memberof PIXI
 */
var GraphicsGeometry = /*@__PURE__*/(function (BatchGeometry) {
    function GraphicsGeometry()
    {
        BatchGeometry.call(this);

        /**
         * An array of points to draw, 2 numbers per point
         *
         * @member {number[]}
         * @protected
         */
        this.points = [];

        /**
         * The collection of colors
         *
         * @member {number[]}
         * @protected
         */
        this.colors = [];

        /**
         * The UVs collection
         *
         * @member {number[]}
         * @protected
         */
        this.uvs = [];

        /**
         * The indices of the vertices
         *
         * @member {number[]}
         * @protected
         */
        this.indices = [];

        /**
         * Reference to the texture IDs.
         *
         * @member {number[]}
         * @protected
         */
        this.textureIds = [];

        /**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         * @protected
         */
        this.graphicsData = [];

        /**
         * Used to detect if the graphics object has changed.
         *
         * @member {number}
         * @protected
         */
        this.dirty = 0;

        /**
         * Batches need to regenerated if the geometry is updated.
         *
         * @member {number}
         * @protected
         */
        this.batchDirty = -1;

        /**
         * Used to check if the cache is dirty.
         *
         * @member {number}
         * @protected
         */
        this.cacheDirty = -1;

        /**
         * Used to detect if we cleared the graphicsData.
         *
         * @member {number}
         * @default 0
         * @protected
         */
        this.clearDirty = 0;

        /**
         * List of current draw calls drived from the batches.
         *
         * @member {object[]}
         * @protected
         */
        this.drawCalls = [];

        /**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {object[]}
         * @protected
         */
        this.batches = [];

        /**
         * Index of the last batched shape in the stack of calls.
         *
         * @member {number}
         * @protected
         */
        this.shapeIndex = 0;

        /**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new _pixi_display__WEBPACK_IMPORTED_MODULE_3__.Bounds();

        /**
         * The bounds dirty flag.
         *
         * @member {number}
         * @protected
         */
        this.boundsDirty = -1;

        /**
         * Padding to add to the bounds.
         *
         * @member {number}
         * @default 0
         */
        this.boundsPadding = 0;

        this.batchable = false;

        this.indicesUint16 = null;

        this.uvsFloat32 = null;

        /**
         * Minimal distance between points that are considered different.
         * Affects line tesselation.
         *
         * @member {number}
         */
        this.closePointEps = 1e-4;
    }

    if ( BatchGeometry ) GraphicsGeometry.__proto__ = BatchGeometry;
    GraphicsGeometry.prototype = Object.create( BatchGeometry && BatchGeometry.prototype );
    GraphicsGeometry.prototype.constructor = GraphicsGeometry;

    var prototypeAccessors = { bounds: { configurable: true } };

    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    prototypeAccessors.bounds.get = function ()
    {
        if (this.boundsDirty !== this.dirty)
        {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
        }

        return this._bounds;
    };

    /**
     * Call if you changed graphicsData manually.
     * Empties all batch buffers.
     */
    GraphicsGeometry.prototype.invalidate = function invalidate ()
    {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;

        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;

        for (var i = 0; i < this.drawCalls.length; i++)
        {
            this.drawCalls[i].textures.length = 0;
            DRAW_CALL_POOL.push(this.drawCalls[i]);
        }

        this.drawCalls.length = 0;

        for (var i$1 = 0; i$1 < this.batches.length; i$1++)
        {
            var batch =  this.batches[i$1];

            batch.start = 0;
            batch.attribStart = 0;
            batch.style = null;
            BATCH_POOL.push(batch);
        }

        this.batches.length = 0;
    };

    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */
    GraphicsGeometry.prototype.clear = function clear ()
    {
        if (this.graphicsData.length > 0)
        {
            this.invalidate();
            this.clearDirty++;
            this.graphicsData.length = 0;
        }

        return this;
    };

    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    GraphicsGeometry.prototype.drawShape = function drawShape (shape, fillStyle, lineStyle, matrix)
    {
        var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);

        this.graphicsData.push(data);
        this.dirty++;

        return this;
    };

    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    GraphicsGeometry.prototype.drawHole = function drawHole (shape, matrix)
    {
        if (!this.graphicsData.length)
        {
            return null;
        }

        var data = new GraphicsData(shape, null, null, matrix);

        var lastShape = this.graphicsData[this.graphicsData.length - 1];

        data.lineStyle = lastShape.lineStyle;

        lastShape.holes.push(data);

        this.dirty++;

        return this;
    };

    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    GraphicsGeometry.prototype.destroy = function destroy (options)
    {
        BatchGeometry.prototype.destroy.call(this, options);

        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i)
        {
            this.graphicsData[i].destroy();
        }

        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
    };

    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.Point} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    GraphicsGeometry.prototype.containsPoint = function containsPoint (point)
    {
        var graphicsData = this.graphicsData;

        for (var i = 0; i < graphicsData.length; ++i)
        {
            var data = graphicsData[i];

            if (!data.fillStyle.visible)
            {
                continue;
            }

            // only deal with fills..
            if (data.shape)
            {
                if (data.matrix)
                {
                    data.matrix.applyInverse(point, tmpPoint);
                }
                else
                {
                    tmpPoint.copyFrom(point);
                }

                if (data.shape.contains(tmpPoint.x, tmpPoint.y))
                {
                    if (data.holes)
                    {
                        for (var i$1 = 0; i$1 < data.holes.length; i$1++)
                        {
                            var hole = data.holes[i$1];

                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))
                            {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     */
    GraphicsGeometry.prototype.updateBatches = function updateBatches ()
    {
        if (this.dirty === this.cacheDirty) { return; }
        if (this.graphicsData.length === 0)
        {
            this.batchable = true;

            return;
        }

        if (this.dirty !== this.cacheDirty)
        {
            for (var i = 0; i < this.graphicsData.length; i++)
            {
                var data = this.graphicsData[i];

                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) { return; }
                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) { return; }
            }
        }

        this.cacheDirty = this.dirty;

        var uvs = this.uvs;

        var batchPart = null;
        var currentTexture = null;
        var currentColor = 0;
        var currentNative = false;

        if (this.batches.length > 0)
        {
            batchPart = this.batches[this.batches.length - 1];

            var style = batchPart.style;

            currentTexture = style.texture.baseTexture;
            currentColor = style.color + style.alpha;
            currentNative = !!style.native;
        }

        for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++)
        {
            this.shapeIndex++;

            var data$1 = this.graphicsData[i$1];
            var command = fillCommands[data$1.type];

            var fillStyle = data$1.fillStyle;
            var lineStyle = data$1.lineStyle;

            // build out the shapes points..
            command.build(data$1);

            if (data$1.matrix)
            {
                this.transformPoints(data$1.points, data$1.matrix);
            }

            for (var j = 0; j < 2; j++)
            {
                var style$1 = (j === 0) ? fillStyle : lineStyle;

                if (!style$1.visible) { continue; }

                var nextTexture = style$1.texture.baseTexture;

                var index$1 = this.indices.length;
                var attribIndex = this.points.length / 2;

                // close batch if style is different
                if (batchPart
                    && (currentTexture !== nextTexture
                    || currentColor !== (style$1.color + style$1.alpha)
                    || currentNative !== !!style$1.native))
                {
                    batchPart.size = index$1 - batchPart.start;
                    batchPart.attribSize = attribIndex - batchPart.attribStart;

                    if (batchPart.size > 0)
                    {
                        batchPart = null;
                    }
                }
                // spawn new batch if its first batch or previous was closed
                if (!batchPart)
                {
                    batchPart = BATCH_POOL.pop() || new BatchPart();
                    this.batches.push(batchPart);
                    nextTexture.wrapMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.WRAP_MODES.REPEAT;
                    currentTexture = nextTexture;
                    currentColor = style$1.color + style$1.alpha;
                    currentNative = style$1.native;

                    batchPart.style = style$1;
                    batchPart.start = index$1;
                    batchPart.attribStart = attribIndex;
                }

                var start = this.points.length / 2;

                if (j === 0)
                {
                    if (data$1.holes.length)
                    {
                        this.processHoles(data$1.holes);

                        buildPoly.triangulate(data$1, this);
                    }
                    else
                    {
                        command.triangulate(data$1, this);
                    }
                }
                else
                {
                    buildLine(data$1, this);

                    for (var i$2 = 0; i$2 < data$1.holes.length; i$2++)
                    {
                        buildLine(data$1.holes[i$2], this);
                    }
                }

                var size = (this.points.length / 2) - start;

                this.addUvs(this.points, uvs, style$1.texture, start, size, style$1.matrix);
            }
        }

        var index = this.indices.length;
        var attrib = this.points.length / 2;

        if (!batchPart)
        {
            // there are no visible styles in GraphicsData
            // its possible that someone wants Graphics just for the bounds
            this.batchable = true;

            return;
        }

        batchPart.size = index - batchPart.start;
        batchPart.attribSize = attrib - batchPart.attribStart;
        this.indicesUint16 = new Uint16Array(this.indices);

        // TODO make this a const..
        this.batchable = this.isBatchable();

        if (this.batchable)
        {
            this.batchDirty++;

            this.uvsFloat32 = new Float32Array(this.uvs);

            // offset the indices so that it works with the batcher...
            for (var i$3 = 0; i$3 < this.batches.length; i$3++)
            {
                var batch = this.batches[i$3];

                for (var j$1 = 0; j$1 < batch.size; j$1++)
                {
                    var index$2 = batch.start + j$1;

                    this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart;
                }
            }
        }
        else
        {
            this.buildDrawCalls();
        }
    };

    /**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     * @protected
     */
    GraphicsGeometry.prototype.isBatchable = function isBatchable ()
    {
        var batches = this.batches;

        for (var i = 0; i < batches.length; i++)
        {
            if (batches[i].style.native)
            {
                return false;
            }
        }

        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);
    };

    /**
     * Converts intermediate batches data to drawCalls.
     * @protected
     */
    GraphicsGeometry.prototype.buildDrawCalls = function buildDrawCalls ()
    {
        var TICK = ++_pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture._globalBatch;

        for (var i = 0; i < this.drawCalls.length; i++)
        {
            this.drawCalls[i].textures.length = 0;
            DRAW_CALL_POOL.push(this.drawCalls[i]);
        }

        this.drawCalls.length = 0;

        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;

        var currentGroup =  DRAW_CALL_POOL.pop() || new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchDrawCall();

        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.DRAW_MODES.TRIANGLES;

        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.DRAW_MODES.TRIANGLES;

        var index = 0;

        this.drawCalls.push(currentGroup);

        // TODO - this can be simplified
        for (var i$1 = 0; i$1 < this.batches.length; i$1++)
        {
            var data = this.batches[i$1];

            // TODO add some full on MAX_TEXTURE CODE..
            var MAX_TEXTURES = 8;

            var style = data.style;

            var nextTexture = style.texture.baseTexture;

            if (native !== !!style.native)
            {
                native = style.native;
                drawMode = native ? _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.DRAW_MODES.LINES : _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.DRAW_MODES.TRIANGLES;

                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }

            if (currentTexture !== nextTexture)
            {
                currentTexture = nextTexture;

                if (nextTexture._batchEnabled !== TICK)
                {
                    if (textureCount === MAX_TEXTURES)
                    {
                        TICK++;

                        textureCount = 0;

                        if (currentGroup.size > 0)
                        {
                            currentGroup = DRAW_CALL_POOL.pop() || new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchDrawCall();
                            this.drawCalls.push(currentGroup);
                        }

                        currentGroup.start = index;
                        currentGroup.size = 0;
                        currentGroup.textureCount = 0;
                        currentGroup.type = drawMode;
                    }

                    // TODO add this to the render part..
                    nextTexture.touched = 1;// touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    nextTexture.wrapMode = 10497;

                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }

            currentGroup.size += data.size;
            index += data.size;

            textureId = nextTexture._id;

            this.addColors(colors, style.color, style.alpha, data.attribSize);
            this.addTextureIds(textureIds, textureId, data.attribSize);
        }

        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture._globalBatch = TICK;

        // upload..
        // merge for now!
        var verts = this.points;

        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);

        var p = 0;

        for (var i$2 = 0; i$2 < verts.length / 2; i$2++)
        {
            f32[p++] = verts[i$2 * 2];
            f32[p++] = verts[(i$2 * 2) + 1];

            f32[p++] = uvs[i$2 * 2];
            f32[p++] = uvs[(i$2 * 2) + 1];

            u32[p++] = colors[i$2];

            f32[p++] = textureIds[i$2];
        }

        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
    };

    /**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */
    GraphicsGeometry.prototype.processHoles = function processHoles (holes)
    {
        for (var i = 0; i < holes.length; i++)
        {
            var hole = holes[i];

            var command = fillCommands[hole.type];

            command.build(hole);

            if (hole.matrix)
            {
                this.transformPoints(hole.points, hole.matrix);
            }
        }
    };

    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     * @protected
     */
    GraphicsGeometry.prototype.calculateBounds = function calculateBounds ()
    {
        var minX = Infinity;
        var maxX = -Infinity;

        var minY = Infinity;
        var maxY = -Infinity;

        if (this.graphicsData.length)
        {
            var shape = null;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;

            for (var i = 0; i < this.graphicsData.length; i++)
            {
                var data = this.graphicsData[i];

                var type = data.type;
                var lineWidth = data.lineStyle ? data.lineStyle.width : 0;

                shape = data.shape;

                if (type === _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.RECT || type === _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.RREC)
                {
                    x = shape.x - (lineWidth / 2);
                    y = shape.y - (lineWidth / 2);
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;

                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRC)
                {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + (lineWidth / 2);
                    h = shape.radius + (lineWidth / 2);

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === _pixi_math__WEBPACK_IMPORTED_MODULE_1__.SHAPES.ELIP)
                {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + (lineWidth / 2);
                    h = shape.height + (lineWidth / 2);

                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;

                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else
                {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;

                    for (var j = 0; j + 2 < points.length; j += 2)
                    {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt((dx * dx) + (dy * dy));

                        if (w < 1e-9)
                        {
                            continue;
                        }

                        rw = ((h / w * dy) + dx) / 2;
                        rh = ((h / w * dx) + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;

                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;

                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        }
        else
        {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }

        var padding = this.boundsPadding;

        this._bounds.minX = minX - padding;
        this._bounds.maxX = maxX + padding;

        this._bounds.minY = minY - padding;
        this._bounds.maxY = maxY + padding;
    };

    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    GraphicsGeometry.prototype.transformPoints = function transformPoints (points, matrix)
    {
        for (var i = 0; i < points.length / 2; i++)
        {
            var x = points[(i * 2)];
            var y = points[(i * 2) + 1];

            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;
            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;
        }
    };

    /**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     */
    GraphicsGeometry.prototype.addColors = function addColors (colors, color, alpha, size)
    {
        // TODO use the premultiply bits Ivan added
        var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);

        var rgba =  (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.premultiplyTint)(rgb, alpha);

        while (size-- > 0)
        {
            colors.push(rgba);
        }
    };

    /**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     */
    GraphicsGeometry.prototype.addTextureIds = function addTextureIds (textureIds, id, size)
    {
        while (size-- > 0)
        {
            textureIds.push(id);
        }
    };

    /**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */
    GraphicsGeometry.prototype.addUvs = function addUvs (verts, uvs, texture, start, size, matrix)
    {
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;

        while (index < size)
        {
            var x = verts[(start + index) * 2];
            var y = verts[((start + index) * 2) + 1];

            if (matrix)
            {
                var nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;

                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;
                x = nx;
            }

            index++;

            uvs.push(x / frame.width, y / frame.height);
        }

        var baseTexture = texture.baseTexture;

        if (frame.width < baseTexture.width
            || frame.height < baseTexture.height)
        {
            this.adjustUvs(uvs, texture, uvsStart, size);
        }
    };

    /**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     * @param {number[]} uvs array
     * @param {PIXI.Texture} texture region
     * @param {number} start starting index for uvs
     * @param {number} size how many points to adjust
     */
    GraphicsGeometry.prototype.adjustUvs = function adjustUvs (uvs, texture, start, size)
    {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + (size * 2);
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.height;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);

        for (var i = start + 2; i < finish; i += 2)
        {
            minX = Math.min(minX, Math.floor(uvs[i] + eps));
            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i$1 = start; i$1 < finish; i$1 += 2)
        {
            uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;
            uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;
        }
    };

    Object.defineProperties( GraphicsGeometry.prototype, prototypeAccessors );

    return GraphicsGeometry;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchGeometry));

/**
 * The maximum number of points to consider an object "batchable",
 * able to be batched by the renderer's batch system.
 *
 * @memberof PIXI.GraphicsGeometry
 * @static
 * @member {number} BATCHABLE_SIZE
 * @default 100
 */
GraphicsGeometry.BATCHABLE_SIZE = 100;

/**
 * Represents the line style for Graphics.
 * @memberof PIXI
 * @class
 * @extends PIXI.FillStyle
 */
var LineStyle = /*@__PURE__*/(function (FillStyle) {
    function LineStyle () {
        FillStyle.apply(this, arguments);
    }

    if ( FillStyle ) LineStyle.__proto__ = FillStyle;
    LineStyle.prototype = Object.create( FillStyle && FillStyle.prototype );
    LineStyle.prototype.constructor = LineStyle;

    LineStyle.prototype.clone = function clone ()
    {
        var obj = new LineStyle();

        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;

        return obj;
    };
    /**
     * Reset the line style to default.
     */
    LineStyle.prototype.reset = function reset ()
    {
        FillStyle.prototype.reset.call(this);

        // Override default line style color
        this.color = 0x0;

        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        this.width = 0;

        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0
         */
        this.alignment = 0.5;

        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         * @default false
         */
        this.native = false;
    };

    return LineStyle;
}(FillStyle));

/**
 * Utilities for bezier curves
 * @class
 * @private
 */
var BezierUtils = function BezierUtils () {};

BezierUtils.curveLength = function curveLength (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)
{
    var n = 10;
    var result = 0.0;
    var t = 0.0;
    var t2 = 0.0;
    var t3 = 0.0;
    var nt = 0.0;
    var nt2 = 0.0;
    var nt3 = 0.0;
    var x = 0.0;
    var y = 0.0;
    var dx = 0.0;
    var dy = 0.0;
    var prevX = fromX;
    var prevY = fromY;

    for (var i = 1; i <= n; ++i)
    {
        t = i / n;
        t2 = t * t;
        t3 = t2 * t;
        nt = (1.0 - t);
        nt2 = nt * nt;
        nt3 = nt2 * nt;

        x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
        y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
        dx = prevX - x;
        dy = prevY - y;
        prevX = x;
        prevY = y;

        result += Math.sqrt((dx * dx) + (dy * dy));
    }

    return result;
};

/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} cpX2 - Second Control point x
 * @param {number} cpY2 - Second Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} points - Path array to push points into
 */
BezierUtils.curveTo = function curveTo (cpX, cpY, cpX2, cpY2, toX, toY, points)
{
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];

    points.length -= 2;

    var n = GRAPHICS_CURVES._segmentsCount(
        BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)
    );

    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;

    points.push(fromX, fromY);

    for (var i = 1, j = 0; i <= n; ++i)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        points.push(
            (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),
            (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)
        );
    }
};

/**
 * Utilities for quadratic curves
 * @class
 * @private
 */
var QuadraticUtils = function QuadraticUtils () {};

QuadraticUtils.curveLength = function curveLength (fromX, fromY, cpX, cpY, toX, toY)
{
    var ax = fromX - (2.0 * cpX) + toX;
    var ay = fromY - (2.0 * cpY) + toY;
    var bx = (2.0 * cpX) - (2.0 * fromX);
    var by = (2.0 * cpY) - (2.0 * fromY);
    var a = 4.0 * ((ax * ax) + (ay * ay));
    var b = 4.0 * ((ax * bx) + (ay * by));
    var c = (bx * bx) + (by * by);

    var s = 2.0 * Math.sqrt(a + b + c);
    var a2 = Math.sqrt(a);
    var a32 = 2.0 * a * a2;
    var c2 = 2.0 * Math.sqrt(c);
    var ba = b / a2;

    return (
        (a32 * s)
            + (a2 * b * (s - c2))
            + (
                ((4.0 * c * a) - (b * b))
               * Math.log(((2.0 * a2) + ba + s) / (ba + c2))
            )
    ) / (4.0 * a32);
};

/**
 * Calculate the points for a quadratic bezier curve and then draws it.
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @private
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} points - Points to add segments to.
 */
QuadraticUtils.curveTo = function curveTo (cpX, cpY, toX, toY, points)
{
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];

    var n = GRAPHICS_CURVES._segmentsCount(
        QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)
    );

    var xa = 0;
    var ya = 0;

    for (var i = 1; i <= n; ++i)
    {
        var j = i / n;

        xa = fromX + ((cpX - fromX) * j);
        ya = fromY + ((cpY - fromY) * j);

        points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),
            ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
    }
};

/**
 * Utilities for arc curves
 * @class
 * @private
 */
var ArcUtils = function ArcUtils () {};

ArcUtils.curveTo = function curveTo (x1, y1, x2, y2, radius, points)
{
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];

    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2 - y1;
    var b2 = x2 - x1;
    var mm = Math.abs((a1 * b2) - (b1 * a2));

    if (mm < 1.0e-8 || radius === 0)
    {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)
        {
            points.push(x1, y1);
        }

        return null;
    }

    var dd = (a1 * a1) + (b1 * b1);
    var cc = (a2 * a2) + (b2 * b2);
    var tt = (a1 * a2) + (b1 * b2);
    var k1 = radius * Math.sqrt(dd) / mm;
    var k2 = radius * Math.sqrt(cc) / mm;
    var j1 = k1 * tt / dd;
    var j2 = k2 * tt / cc;
    var cx = (k1 * b2) + (k2 * b1);
    var cy = (k1 * a2) + (k2 * a1);
    var px = b1 * (k2 + j1);
    var py = a1 * (k2 + j1);
    var qx = b2 * (k1 + j2);
    var qy = a2 * (k1 + j2);
    var startAngle = Math.atan2(py - cy, px - cx);
    var endAngle = Math.atan2(qy - cy, qx - cx);

    return {
        cx: (cx + x1),
        cy: (cy + y1),
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle,
        anticlockwise: (b1 * a2 > b2 * a1),
    };
};

/**
 * The arc method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @private
 * @param {number} startX - Start x location of arc
 * @param {number} startY - Start y location of arc
 * @param {number} cx - The x-coordinate of the center of the circle
 * @param {number} cy - The y-coordinate of the center of the circle
 * @param {number} radius - The radius of the circle
 * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
 *  of the arc's circle)
 * @param {number} endAngle - The ending angle, in radians
 * @param {boolean} anticlockwise - Specifies whether the drawing should be
 *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
 *  indicates counter-clockwise.
 * @param {number} n - Number of segments
 * @param {number[]} points - Collection of points to add to
 */
ArcUtils.arc = function arc (startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points)
{
    var sweep = endAngle - startAngle;
    var n = GRAPHICS_CURVES._segmentsCount(
        Math.abs(sweep) * radius,
        Math.ceil(Math.abs(sweep) / _pixi_math__WEBPACK_IMPORTED_MODULE_1__.PI_2) * 40
    );

    var theta = (sweep) / (n * 2);
    var theta2 = theta * 2;
    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    var segMinus = n - 1;
    var remainder = (segMinus % 1) / segMinus;

    for (var i = 0; i <= segMinus; ++i)
    {
        var real = i + (remainder * i);
        var angle = ((theta) + startAngle + (theta2 * real));
        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(
            (((cTheta * c) + (sTheta * s)) * radius) + cx,
            (((cTheta * -s) + (sTheta * c)) * radius) + cy
        );
    }
};

/**
 * Draw a star shape with an arbitrary number of points.
 *
 * @class
 * @extends PIXI.Polygon
 * @memberof PIXI
 * @param {number} x - Center X position of the star
 * @param {number} y - Center Y position of the star
 * @param {number} points - The number of points of the star, must be > 1
 * @param {number} radius - The outer radius of the star
 * @param {number} [innerRadius] - The inner radius between points, default half `radius`
 * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
 * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
 */
var Star = /*@__PURE__*/(function (Polygon) {
    function Star(x, y, points, radius, innerRadius, rotation)
    {
        innerRadius = innerRadius || radius / 2;

        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = _pixi_math__WEBPACK_IMPORTED_MODULE_1__.PI_2 / len;
        var polygon = [];

        for (var i = 0; i < len; i++)
        {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;

            polygon.push(
                x + (r * Math.cos(angle)),
                y + (r * Math.sin(angle))
            );
        }

        Polygon.call(this, polygon);
    }

    if ( Polygon ) Star.__proto__ = Polygon;
    Star.prototype = Object.create( Polygon && Polygon.prototype );
    Star.prototype.constructor = Star;

    return Star;
}(_pixi_math__WEBPACK_IMPORTED_MODULE_1__.Polygon));

var temp = new Float32Array(3);

// a default shader used by graphics..
var defaultShader = null;

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * Note that because Graphics can share a GraphicsGeometry with other instances,
 * it is necessary to call `destroy()` to properly dereference the underlying
 * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same
 * Graphics instance and call `clear()` between redraws.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */
var Graphics = /*@__PURE__*/(function (Container) {
    function Graphics(geometry)
    {
        if ( geometry === void 0 ) geometry = null;

        Container.call(this);
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */
        this.geometry = geometry || new GraphicsGeometry();

        this.geometry.refCount++;

        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         * @member {PIXI.Shader}
         */
        this.shader = null;

        /**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();

        /**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         * @protected
         */
        this._fillStyle = new FillStyle();

        /**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         * @protected
         */
        this._lineStyle = new LineStyle();

        /**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         * @protected
         */
        this._matrix = null;

        /**
         * Current hole mode is enabled.
         *
         * @member {boolean}
         * @default false
         * @protected
         */
        this._holeMode = false;

        /**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @protected
         */
        this.currentPath = null;

        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */

        /**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @protected
         * @member {object[]}
         */
        this.batches = [];

        /**
         * Update dirty for limiting calculating tints for batches.
         *
         * @protected
         * @member {number}
         * @default -1
         */
        this.batchTint = -1;

        /**
         * Copy of the object vertex data.
         *
         * @protected
         * @member {Float32Array}
         */
        this.vertexData = null;

        this._transformID = -1;
        this.batchDirty = -1;

        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = 'batch';

        // Set default
        this.tint = 0xFFFFFF;
        this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_4__.BLEND_MODES.NORMAL;
    }

    if ( Container ) Graphics.__proto__ = Container;
    Graphics.prototype = Object.create( Container && Container.prototype );
    Graphics.prototype.constructor = Graphics;

    var prototypeAccessors = { blendMode: { configurable: true },tint: { configurable: true },fill: { configurable: true },line: { configurable: true } };

    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */
    Graphics.prototype.clone = function clone ()
    {
        this.finishPoly();

        return new Graphics(this.geometry);
    };

    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    prototypeAccessors.blendMode.set = function (value)
    {
        this.state.blendMode = value;
    };

    prototypeAccessors.blendMode.get = function ()
    {
        return this.state.blendMode;
    };

    /**
     * The tint applied to the graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    prototypeAccessors.tint.get = function ()
    {
        return this._tint;
    };
    prototypeAccessors.tint.set = function (value)
    {
        this._tint = value;
    };

    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    prototypeAccessors.fill.get = function ()
    {
        return this._fillStyle;
    };

    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    prototypeAccessors.line.get = function ()
    {
        return this._lineStyle;
    };

    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.lineStyle = function lineStyle (width, color, alpha, alignment, native)
    {
        if ( width === void 0 ) width = 0;
        if ( color === void 0 ) color = 0;
        if ( alpha === void 0 ) alpha = 1;
        if ( alignment === void 0 ) alignment = 0.5;
        if ( native === void 0 ) native = false;

        this.lineTextureStyle(width, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE, color, alpha, null, alignment, native);

        return this;
    };

    /**
     * Like line style but support texture for line fill.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.lineTextureStyle = function lineTextureStyle (width, texture, color, alpha,
        matrix, alignment, native)
    {
        if ( width === void 0 ) width = 0;
        if ( texture === void 0 ) texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE;
        if ( color === void 0 ) color = 0xFFFFFF;
        if ( alpha === void 0 ) alpha = 1;
        if ( matrix === void 0 ) matrix = null;
        if ( alignment === void 0 ) alignment = 0.5;
        if ( native === void 0 ) native = false;

        if (this.currentPath)
        {
            this.startPoly();
        }

        var visible = width > 0 && alpha > 0;

        if (!visible)
        {
            this._lineStyle.reset();
        }
        else
        {
            if (matrix)
            {
                matrix = matrix.clone();
                matrix.invert();
            }

            Object.assign(this._lineStyle, {
                color: color,
                width: width,
                alpha: alpha,
                matrix: matrix,
                texture: texture,
                alignment: alignment,
                native: native,
                visible: visible,
            });
        }

        return this;
    };

    /**
     * Start a polygon object internally
     * @protected
     */
    Graphics.prototype.startPoly = function startPoly ()
    {
        if (this.currentPath)
        {
            var points = this.currentPath.points;
            var len = this.currentPath.points.length;

            if (len > 2)
            {
                this.drawShape(this.currentPath);
                this.currentPath = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Polygon();
                this.currentPath.closeStroke = false;
                this.currentPath.points.push(points[len - 2], points[len - 1]);
            }
        }
        else
        {
            this.currentPath = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Polygon();
            this.currentPath.closeStroke = false;
        }
    };

    /**
     * Finish the polygon object.
     * @protected
     */
    Graphics.prototype.finishPoly = function finishPoly ()
    {
        if (this.currentPath)
        {
            if (this.currentPath.points.length > 2)
            {
                this.drawShape(this.currentPath);
                this.currentPath = null;
            }
            else
            {
                this.currentPath.points.length = 0;
            }
        }
    };

    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.moveTo = function moveTo (x, y)
    {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;

        return this;
    };

    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.lineTo = function lineTo (x, y)
    {
        if (!this.currentPath)
        {
            this.moveTo(0, 0);
        }

        // remove duplicates..
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];

        if (fromX !== x || fromY !== y)
        {
            points.push(x, y);
        }

        return this;
    };

    /**
     * Initialize the curve
     *
     * @protected
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    Graphics.prototype._initCurve = function _initCurve (x, y)
    {
        if ( x === void 0 ) x = 0;
        if ( y === void 0 ) y = 0;

        if (this.currentPath)
        {
            if (this.currentPath.points.length === 0)
            {
                this.currentPath.points = [x, y];
            }
        }
        else
        {
            this.moveTo(x, y);
        }
    };

    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.quadraticCurveTo = function quadraticCurveTo (cpX, cpY, toX, toY)
    {
        this._initCurve();

        var points = this.currentPath.points;

        if (points.length === 0)
        {
            this.moveTo(0, 0);
        }

        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);

        return this;
    };

    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.bezierCurveTo = function bezierCurveTo (cpX, cpY, cpX2, cpY2, toX, toY)
    {
        this._initCurve();

        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);

        return this;
    };

    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the first tangent point of the arc
     * @param {number} y1 - The y-coordinate of the first tangent point of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.arcTo = function arcTo (x1, y1, x2, y2, radius)
    {
        this._initCurve(x1, y1);

        var points = this.currentPath.points;

        var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);

        if (result)
        {
            var cx = result.cx;
            var cy = result.cy;
            var radius$1 = result.radius;
            var startAngle = result.startAngle;
            var endAngle = result.endAngle;
            var anticlockwise = result.anticlockwise;

            this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);
        }

        return this;
    };

    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.arc = function arc (cx, cy, radius, startAngle, endAngle, anticlockwise)
    {
        if ( anticlockwise === void 0 ) anticlockwise = false;

        if (startAngle === endAngle)
        {
            return this;
        }

        if (!anticlockwise && endAngle <= startAngle)
        {
            endAngle += _pixi_math__WEBPACK_IMPORTED_MODULE_1__.PI_2;
        }
        else if (anticlockwise && startAngle <= endAngle)
        {
            startAngle += _pixi_math__WEBPACK_IMPORTED_MODULE_1__.PI_2;
        }

        var sweep = endAngle - startAngle;

        if (sweep === 0)
        {
            return this;
        }

        var startX = cx + (Math.cos(startAngle) * radius);
        var startY = cy + (Math.sin(startAngle) * radius);
        var eps = this.geometry.closePointEps;

        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.points : null;

        if (points)
        {
            // TODO: make a better fix.

            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);

            if (xDiff < eps && yDiff < eps)
            ;
            else
            {
                points.push(startX, startY);
            }
        }
        else
        {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }

        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);

        return this;
    };

    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.beginFill = function beginFill (color, alpha)
    {
        if ( color === void 0 ) color = 0;
        if ( alpha === void 0 ) alpha = 1;

        return this.beginTextureFill(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE, color, alpha);
    };

    /**
     * Begin the texture fill
     *
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [color=0xffffff] - Background to fill behind texture
     * @param {number} [alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.beginTextureFill = function beginTextureFill (texture, color, alpha, matrix)
    {
        if ( texture === void 0 ) texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE;
        if ( color === void 0 ) color = 0xFFFFFF;
        if ( alpha === void 0 ) alpha = 1;
        if ( matrix === void 0 ) matrix = null;

        if (this.currentPath)
        {
            this.startPoly();
        }

        var visible = alpha > 0;

        if (!visible)
        {
            this._fillStyle.reset();
        }
        else
        {
            if (matrix)
            {
                matrix = matrix.clone();
                matrix.invert();
            }

            Object.assign(this._fillStyle, {
                color: color,
                alpha: alpha,
                texture: texture,
                matrix: matrix,
                visible: visible,
            });
        }

        return this;
    };

    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.endFill = function endFill ()
    {
        this.finishPoly();

        this._fillStyle.reset();

        return this;
    };

    /**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawRect = function drawRect (x, y, width, height)
    {
        return this.drawShape(new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle(x, y, width, height));
    };

    /**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawRoundedRect = function drawRoundedRect (x, y, width, height, radius)
    {
        return this.drawShape(new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.RoundedRectangle(x, y, width, height, radius));
    };

    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawCircle = function drawCircle (x, y, radius)
    {
        return this.drawShape(new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Circle(x, y, radius));
    };

    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawEllipse = function drawEllipse (x, y, width, height)
    {
        return this.drawShape(new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Ellipse(x, y, width, height));
    };

    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawPolygon = function drawPolygon (path)
    {
        var arguments$1 = arguments;

        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;

        var closeStroke = true;// !!this._fillStyle;

        // check if data has points..
        if (points.points)
        {
            closeStroke = points.closeStroke;
            points = points.points;
        }

        if (!Array.isArray(points))
        {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);

            for (var i = 0; i < points.length; ++i)
            {
                points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params
            }
        }

        var shape = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Polygon(points);

        shape.closeStroke = closeStroke;

        this.drawShape(shape);

        return this;
    };

    /**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawShape = function drawShape (shape)
    {
        if (!this._holeMode)
        {
            this.geometry.drawShape(
                shape,
                this._fillStyle.clone(),
                this._lineStyle.clone(),
                this._matrix
            );
        }
        else
        {
            this.geometry.drawHole(shape, this._matrix);
        }

        return this;
    };

    /**
     * Draw a star shape with an arbitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.drawStar = function drawStar (x, y, points, radius, innerRadius, rotation)
    {
        if ( rotation === void 0 ) rotation = 0;

        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));
    };

    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    Graphics.prototype.clear = function clear ()
    {
        this.geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();

        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;

        return this;
    };

    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    Graphics.prototype.isFastRect = function isFastRect ()
    {
        // will fix this!
        return false;
        // this.graphicsData.length === 1
        //  && this.graphicsData[0].shape.type === SHAPES.RECT
        // && !this.graphicsData[0].lineWidth;
    };

    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    Graphics.prototype._render = function _render (renderer)
    {
        this.finishPoly();

        var geometry = this.geometry;

        // batch part..
        // batch it!
        geometry.updateBatches();

        if (geometry.batchable)
        {
            if (this.batchDirty !== geometry.batchDirty)
            {
                this.batches = [];
                this.batchTint = -1;
                this._transformID = -1;
                this.batchDirty = geometry.batchDirty;

                this.vertexData = new Float32Array(geometry.points);

                var blendMode = this.blendMode;

                for (var i = 0; i < geometry.batches.length; i++)
                {
                    var gI = geometry.batches[i];

                    var color = gI.style.color;

                    //        + (alpha * 255 << 24);

                    var vertexData = new Float32Array(this.vertexData.buffer,
                        gI.attribStart * 4 * 2,
                        gI.attribSize * 2);

                    var uvs = new Float32Array(geometry.uvsFloat32.buffer,
                        gI.attribStart * 4 * 2,
                        gI.attribSize * 2);

                    var indices = new Uint16Array(geometry.indicesUint16.buffer,
                        gI.start * 2,
                        gI.size);

                    var batch = {
                        vertexData: vertexData,
                        blendMode: blendMode,
                        indices: indices,
                        uvs: uvs,
                        _batchRGB: (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(color),
                        _tintRGB: color,
                        _texture: gI.style.texture,
                        alpha: gI.style.alpha,
                        worldAlpha: 1 };

                    this.batches[i] = batch;
                }
            }

            if (this.batches.length)
            {
                renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);

                this.calculateVertices();
                this.calculateTints();

                for (var i$1 = 0; i$1 < this.batches.length; i$1++)
                {
                    var batch$1 = this.batches[i$1];

                    batch$1.worldAlpha = this.worldAlpha * batch$1.alpha;

                    renderer.plugins[this.pluginName].render(batch$1);
                }
            }
        }
        else
        {
            // no batching...
            renderer.batch.flush();

            if (!this.shader)
            {
                // if there is no shader here, we can use the default shader.
                // and that only gets created if we actually need it..
                if (!defaultShader)
                {
                    var sampleValues = new Int32Array(16);

                    for (var i$2 = 0; i$2 < 16; i$2++)
                    {
                        sampleValues[i$2] = i$2;
                    }

                    var uniforms = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix(),
                        default: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UniformGroup.from({ uSamplers: sampleValues }, true),
                    };

                    // we can bbase default shader of the batch renderers program
                    var program =  renderer.plugins.batch._shader.program;

                    defaultShader = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader(program, uniforms);
                }

                this.shader = defaultShader;
            }

            var uniforms$1 = this.shader.uniforms;

            // lets set the transfomr
            uniforms$1.translationMatrix = this.transform.worldTransform;

            var tint = this.tint;
            var wa = this.worldAlpha;

            // and then lets set the tint..
            uniforms$1.tint[0] = (((tint >> 16) & 0xFF) / 255) * wa;
            uniforms$1.tint[1] = (((tint >> 8) & 0xFF) / 255) * wa;
            uniforms$1.tint[2] = ((tint & 0xFF) / 255) * wa;
            uniforms$1.tint[3] = wa;

            // the first draw call, we can set the uniforms of the shader directly here.

            // this means that we can tack advantage of the sync function of pixi!
            // bind and sync uniforms..
            // there is a way to optimise this..
            renderer.shader.bind(this.shader);

            // then render it
            renderer.geometry.bind(geometry, this.shader);

            // set state..
            renderer.state.set(this.state);

            // then render the rest of them...
            for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++)
            {
                var drawCall = geometry.drawCalls[i$3];

                var groupTextureCount = drawCall.textureCount;

                for (var j = 0; j < groupTextureCount; j++)
                {
                    renderer.texture.bind(drawCall.textures[j], j);
                }

                // bind the geometry...
                renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);
            }
        }
    };

    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @protected
     */
    Graphics.prototype._calculateBounds = function _calculateBounds ()
    {
        this.finishPoly();
        var lb = this.geometry.bounds;

        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    };

    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    Graphics.prototype.containsPoint = function containsPoint (point)
    {
        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);

        return this.geometry.containsPoint(Graphics._TEMP_POINT);
    };

    /**
     * Recalcuate the tint by applying tin to batches using Graphics tint.
     * @protected
     */
    Graphics.prototype.calculateTints = function calculateTints ()
    {
        if (this.batchTint !== this.tint)
        {
            this.batchTint = this.tint;

            var tintRGB = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.hex2rgb)(this.tint, temp);

            for (var i = 0; i < this.batches.length; i++)
            {
                var batch = this.batches[i];

                var batchTint = batch._batchRGB;

                var r = (tintRGB[0] * batchTint[0]) * 255;
                var g = (tintRGB[1] * batchTint[1]) * 255;
                var b = (tintRGB[2] * batchTint[2]) * 255;

                // TODO Ivan, can this be done in one go?
                var color = (r << 16) + (g << 8) + (b | 0);

                batch._tintRGB = (color >> 16)
                        + (color & 0xff00)
                        + ((color & 0xff) << 16);
            }
        }
    };

    /**
     * If there's a transform update or a change to the shape of the
     * geometry, recaculate the vertices.
     * @protected
     */
    Graphics.prototype.calculateVertices = function calculateVertices ()
    {
        if (this._transformID === this.transform._worldID)
        {
            return;
        }

        this._transformID = this.transform._worldID;

        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;

        var data = this.geometry.points;// batch.vertexDataOriginal;
        var vertexData = this.vertexData;

        var count = 0;

        for (var i = 0; i < data.length; i += 2)
        {
            var x = data[i];
            var y = data[i + 1];

            vertexData[count++] = (a * x) + (c * y) + tx;
            vertexData[count++] = (d * y) + (b * x) + ty;
        }
    };

    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */
    Graphics.prototype.closePath = function closePath ()
    {
        var currentPath = this.currentPath;

        if (currentPath)
        {
            // we don't need to add extra point in the end because buildLine will take care of that
            currentPath.closeStroke = true;
        }

        return this;
    };

    /**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */
    Graphics.prototype.setMatrix = function setMatrix (matrix)
    {
        this._matrix = matrix;

        return this;
    };

    /**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */
    Graphics.prototype.beginHole = function beginHole ()
    {
        this.finishPoly();
        this._holeMode = true;

        return this;
    };

    /**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */
    Graphics.prototype.endHole = function endHole ()
    {
        this.finishPoly();
        this._holeMode = false;

        return this;
    };

    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    Graphics.prototype.destroy = function destroy (options)
    {
        Container.prototype.destroy.call(this, options);

        this.geometry.refCount--;
        if (this.geometry.refCount === 0)
        {
            this.geometry.dispose();
        }

        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this.geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;

        Container.prototype.destroy.call(this, options);
    };

    Object.defineProperties( Graphics.prototype, prototypeAccessors );

    return Graphics;
}(_pixi_display__WEBPACK_IMPORTED_MODULE_3__.Container));

/**
 * Temporary point to use for containsPoint
 *
 * @static
 * @private
 * @member {PIXI.Point}
 */
Graphics._TEMP_POINT = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point();


//# sourceMappingURL=graphics.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/interaction/lib/interaction.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/interaction/lib/interaction.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InteractionData": () => (/* binding */ InteractionData),
/* harmony export */   "InteractionEvent": () => (/* binding */ InteractionEvent),
/* harmony export */   "InteractionManager": () => (/* binding */ InteractionManager),
/* harmony export */   "InteractionTrackingData": () => (/* binding */ InteractionTrackingData),
/* harmony export */   "interactiveTarget": () => (/* binding */ interactiveTarget)
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/ticker.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/*!
 * @pixi/interaction - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */





/**
 * Holds all information related to an Interaction event
 *
 * @class
 * @memberof PIXI.interaction
 */
var InteractionData = function InteractionData()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {PIXI.Point}
     */
    this.global = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Point();

    /**
     * The target Sprite that was interacted with
     *
     * @member {PIXI.Sprite}
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
     * @member {MouseEvent|TouchEvent|PointerEvent}
     */
    this.originalEvent = null;

    /**
     * Unique identifier for this interaction
     *
     * @member {number}
     */
    this.identifier = null;

    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     * @type {Boolean}
     */
    this.isPrimary = false;

    /**
     * Indicates which button was pressed on the mouse or pointer device to trigger the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
     * @type {number}
     */
    this.button = 0;

    /**
     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
     * @type {number}
     */
    this.buttons = 0;

    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     * @type {number}
     */
    this.width = 0;

    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     * @type {number}
     */
    this.height = 0;

    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
     * @type {number}
     */
    this.tiltX = 0;

    /**
     * The angle, in degrees, between the pointer device and the screen.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
     * @type {number}
     */
    this.tiltY = 0;

    /**
     * The type of pointer that triggered the event.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
     * @type {string}
     */
    this.pointerType = null;

    /**
     * Pressure applied by the pointing device during the event. A Touch's force property
     * will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
     * @type {number}
     */
    this.pressure = 0;

    /**
     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
     * @type {number}
     */
    this.rotationAngle = 0;

    /**
     * Twist of a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */
    this.twist = 0;

    /**
     * Barrel pressure on a stylus pointer.
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     * @type {number}
     */
    this.tangentialPressure = 0;
};

var prototypeAccessors = { pointerId: { configurable: true } };

/**
 * The unique identifier of the pointer. It will be the same as `identifier`.
 * @readonly
 * @member {number}
 * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
 */
prototypeAccessors.pointerId.get = function ()
{
    return this.identifier;
};

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
 *  coords off
 * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise
 *  will create a new point)
 * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional
 *  (otherwise will use the current global coords)
 * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative
 *  to the DisplayObject
 */
InteractionData.prototype.getLocalPosition = function getLocalPosition (displayObject, point, globalPos)
{
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
};

/**
 * Copies properties from normalized event data.
 *
 * @param {Touch|MouseEvent|PointerEvent} event The normalized event data
 */
InteractionData.prototype.copyEvent = function copyEvent (event)
{
    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite
    // it with "false" on later events when our shim for it on touch events might not be
    // accurate
    if (event.isPrimary)
    {
        this.isPrimary = true;
    }
    this.button = event.button;
    // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard
    // event.which property instead, which conveys the same information.
    this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
    this.width = event.width;
    this.height = event.height;
    this.tiltX = event.tiltX;
    this.tiltY = event.tiltY;
    this.pointerType = event.pointerType;
    this.pressure = event.pressure;
    this.rotationAngle = event.rotationAngle;
    this.twist = event.twist || 0;
    this.tangentialPressure = event.tangentialPressure || 0;
};

/**
 * Resets the data for pooling.
 */
InteractionData.prototype.reset = function reset ()
{
    // isPrimary is the only property that we really need to reset - everything else is
    // guaranteed to be overwritten
    this.isPrimary = false;
};

Object.defineProperties( InteractionData.prototype, prototypeAccessors );

/**
 * Event class that mimics native DOM events.
 *
 * @class
 * @memberof PIXI.interaction
 */
var InteractionEvent = function InteractionEvent()
{
    /**
     * Whether this event will continue propagating in the tree
     *
     * @member {boolean}
     */
    this.stopped = false;

    /**
     * The object which caused this event to be dispatched.
     * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.
     *
     * @member {PIXI.DisplayObject}
     */
    this.target = null;

    /**
     * The object whose event listener’s callback is currently being invoked.
     *
     * @member {PIXI.DisplayObject}
     */
    this.currentTarget = null;

    /**
     * Type of the event
     *
     * @member {string}
     */
    this.type = null;

    /**
     * InteractionData related to this event
     *
     * @member {PIXI.interaction.InteractionData}
     */
    this.data = null;
};

/**
 * Prevents event from reaching any objects other than the current object.
 *
 */
InteractionEvent.prototype.stopPropagation = function stopPropagation ()
{
    this.stopped = true;
};

/**
 * Resets the event.
 */
InteractionEvent.prototype.reset = function reset ()
{
    this.stopped = false;
    this.currentTarget = null;
    this.target = null;
};

/**
 * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions
 *
 * @class
 * @private
 * @memberof PIXI.interaction
 */
var InteractionTrackingData = function InteractionTrackingData(pointerId)
{
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData.FLAGS.NONE;
};

var prototypeAccessors$1 = { pointerId: { configurable: true },flags: { configurable: true },none: { configurable: true },over: { configurable: true },rightDown: { configurable: true },leftDown: { configurable: true } };

/**
 *
 * @private
 * @param {number} flag - The interaction flag to set
 * @param {boolean} yn - Should the flag be set or unset
 */
InteractionTrackingData.prototype._doSet = function _doSet (flag, yn)
{
    if (yn)
    {
        this._flags = this._flags | flag;
    }
    else
    {
        this._flags = this._flags & (~flag);
    }
};

/**
 * Unique pointer id of the event
 *
 * @readonly
 * @private
 * @member {number}
 */
prototypeAccessors$1.pointerId.get = function ()
{
    return this._pointerId;
};

/**
 * State of the tracking data, expressed as bit flags
 *
 * @private
 * @member {number}
 */
prototypeAccessors$1.flags.get = function ()
{
    return this._flags;
};

prototypeAccessors$1.flags.set = function (flags) // eslint-disable-line require-jsdoc
{
    this._flags = flags;
};

/**
 * Is the tracked event inactive (not over or down)?
 *
 * @private
 * @member {number}
 */
prototypeAccessors$1.none.get = function ()
{
    return this._flags === this.constructor.FLAGS.NONE;
};

/**
 * Is the tracked event over the DisplayObject?
 *
 * @private
 * @member {boolean}
 */
prototypeAccessors$1.over.get = function ()
{
    return (this._flags & this.constructor.FLAGS.OVER) !== 0;
};

prototypeAccessors$1.over.set = function (yn) // eslint-disable-line require-jsdoc
{
    this._doSet(this.constructor.FLAGS.OVER, yn);
};

/**
 * Did the right mouse button come down in the DisplayObject?
 *
 * @private
 * @member {boolean}
 */
prototypeAccessors$1.rightDown.get = function ()
{
    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
};

prototypeAccessors$1.rightDown.set = function (yn) // eslint-disable-line require-jsdoc
{
    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
};

/**
 * Did the left mouse button come down in the DisplayObject?
 *
 * @private
 * @member {boolean}
 */
prototypeAccessors$1.leftDown.get = function ()
{
    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
};

prototypeAccessors$1.leftDown.set = function (yn) // eslint-disable-line require-jsdoc
{
    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
};

Object.defineProperties( InteractionTrackingData.prototype, prototypeAccessors$1 );

InteractionTrackingData.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2,
});

/**
 * Interface for classes that represent a hit area.
 *
 * It is implemented by the following classes:
 * - {@link PIXI.Circle}
 * - {@link PIXI.Ellipse}
 * - {@link PIXI.Polygon}
 * - {@link PIXI.RoundedRectangle}
 *
 * @interface IHitArea
 * @memberof PIXI
 */

/**
 * Checks whether the x and y coordinates given are contained within this area
 *
 * @method
 * @name contains
 * @memberof PIXI.IHitArea#
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this area
 */

/**
 * Default property values of interactive objects
 * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties
 *
 * @private
 * @name interactiveTarget
 * @type {Object}
 * @memberof PIXI.interaction
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          DisplayObject.prototype,
 *          PIXI.interaction.interactiveTarget
 *      );
 */
var interactiveTarget = {

    /**
     * Enable interaction events for the DisplayObject. Touch, pointer and mouse
     * events will not be emitted unless `interactive` is set to `true`.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.on('tap', (event) => {
     *    //handle event
     * });
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    interactive: false,

    /**
     * Determines if the children to the displayObject can be clicked/touched
     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
     *
     * @member {boolean}
     * @memberof PIXI.Container#
     */
    interactiveChildren: true,

    /**
     * Interaction shape. Children will be hit first, then this shape will be checked.
     * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
     * @member {PIXI.IHitArea}
     * @memberof PIXI.DisplayObject#
     */
    hitArea: null,

    /**
     * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
     * Setting this changes the 'cursor' property to `'pointer'`.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.buttonMode = true;
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    get buttonMode()
    {
        return this.cursor === 'pointer';
    },
    set buttonMode(value)
    {
        if (value)
        {
            this.cursor = 'pointer';
        }
        else if (this.cursor === 'pointer')
        {
            this.cursor = null;
        }
    },

    /**
     * This defines what cursor mode is used when the mouse cursor
     * is hovered over the displayObject.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.cursor = 'wait';
     * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     */
    cursor: null,

    /**
     * Internal set of all active pointers, by identifier
     *
     * @member {Map<number, InteractionTrackingData>}
     * @memberof PIXI.DisplayObject#
     * @private
     */
    get trackedPointers()
    {
        if (this._trackedPointers === undefined) { this._trackedPointers = {}; }

        return this._trackedPointers;
    },

    /**
     * Map of all tracked pointers, by identifier. Use trackedPointers to access.
     *
     * @private
     * @type {Map<number, InteractionTrackingData>}
     */
    _trackedPointers: undefined,
};

// Mix interactiveTarget into DisplayObject.prototype,
// after deprecation has been handled
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.mixin(interactiveTarget);

var MOUSE_POINTER_ID = 1;

// helpers for hitTest() - only used inside hitTest()
var hitTestEvent = {
    target: null,
    data: {
        global: null,
    },
};

/**
 * The interaction manager deals with mouse, touch and pointer events.
 *
 * Any DisplayObject can be interactive if its `interactive` property is set to true.
 *
 * This manager also supports multitouch.
 *
 * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`
 *
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI.interaction
 */
var InteractionManager = /*@__PURE__*/(function (EventEmitter) {
    function InteractionManager(renderer, options)
    {
        EventEmitter.call(this);

        options = options || {};

        /**
         * The renderer this interaction manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */
        this.renderer = renderer;

        /**
         * Should default browser actions automatically be prevented.
         * Does not apply to pointer events for backwards compatibility
         * preventDefault on pointer events stops mouse events from firing
         * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

        /**
         * Frequency in milliseconds that the mousemove, mouseover & mouseout interaction events will be checked.
         *
         * @member {number}
         * @default 10
         */
        this.interactionFrequency = options.interactionFrequency || 10;

        /**
         * The mouse data
         *
         * @member {PIXI.interaction.InteractionData}
         */
        this.mouse = new InteractionData();
        this.mouse.identifier = MOUSE_POINTER_ID;

        // setting the mouse to start off far off screen will mean that mouse over does
        //  not get called before we even move the mouse.
        this.mouse.global.set(-999999);

        /**
         * Actively tracked InteractionData
         *
         * @private
         * @member {Object.<number,PIXI.interaction.InteractionData>}
         */
        this.activeInteractionData = {};
        this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;

        /**
         * Pool of unused InteractionData
         *
         * @private
         * @member {PIXI.interaction.InteractionData[]}
         */
        this.interactionDataPool = [];

        /**
         * An event data object to handle all the event tracking/dispatching
         *
         * @member {object}
         */
        this.eventData = new InteractionEvent();

        /**
         * The DOM element to bind to.
         *
         * @protected
         * @member {HTMLElement}
         */
        this.interactionDOMElement = null;

        /**
         * This property determines if mousemove and touchmove events are fired only when the cursor
         * is over the object.
         * Setting to true will make things work more in line with how the DOM version works.
         * Setting to false can make things easier for things like dragging
         * It is currently set to false as this is how PixiJS used to work. This will be set to true in
         * future versions of pixi.
         *
         * @member {boolean}
         * @default false
         */
        this.moveWhenInside = false;

        /**
         * Have events been attached to the dom element?
         *
         * @protected
         * @member {boolean}
         */
        this.eventsAdded = false;

        /**
         * Is the mouse hovering over the renderer?
         *
         * @protected
         * @member {boolean}
         */
        this.mouseOverRenderer = false;

        /**
         * Does the device support touch events
         * https://www.w3.org/TR/touch-events/
         *
         * @readonly
         * @member {boolean}
         */
        this.supportsTouchEvents = 'ontouchstart' in window;

        /**
         * Does the device support pointer events
         * https://www.w3.org/Submission/pointer-events/
         *
         * @readonly
         * @member {boolean}
         */
        this.supportsPointerEvents = !!window.PointerEvent;

        // this will make it so that you don't have to call bind all the time

        /**
         * @private
         * @member {Function}
         */
        this.onPointerUp = this.onPointerUp.bind(this);
        this.processPointerUp = this.processPointerUp.bind(this);

        /**
         * @private
         * @member {Function}
         */
        this.onPointerCancel = this.onPointerCancel.bind(this);
        this.processPointerCancel = this.processPointerCancel.bind(this);

        /**
         * @private
         * @member {Function}
         */
        this.onPointerDown = this.onPointerDown.bind(this);
        this.processPointerDown = this.processPointerDown.bind(this);

        /**
         * @private
         * @member {Function}
         */
        this.onPointerMove = this.onPointerMove.bind(this);
        this.processPointerMove = this.processPointerMove.bind(this);

        /**
         * @private
         * @member {Function}
         */
        this.onPointerOut = this.onPointerOut.bind(this);
        this.processPointerOverOut = this.processPointerOverOut.bind(this);

        /**
         * @private
         * @member {Function}
         */
        this.onPointerOver = this.onPointerOver.bind(this);

        /**
         * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
         * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
         * and functions are called instead of changing the CSS.
         * Default CSS cursor values are provided for 'default' and 'pointer' modes.
         * @member {Object.<string, Object>}
         */
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer',
        };

        /**
         * The mode of the cursor that is being used.
         * The value of this is a key from the cursorStyles dictionary.
         *
         * @member {string}
         */
        this.currentCursorMode = null;

        /**
         * Internal cached let.
         *
         * @private
         * @member {string}
         */
        this.cursor = null;

        /**
         * Internal cached let.
         *
         * @private
         * @member {PIXI.Point}
         */
        this._tempPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Point();

        /**
         * The current resolution / device pixel ratio.
         *
         * @member {number}
         * @default 1
         */
        this.resolution = 1;

        /**
         * Delayed pointer events. Used to guarantee correct ordering of over/out events.
         *
         * @private
         * @member {Array}
         */
        this.delayedEvents = [];

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
         * object.
         *
         * @event PIXI.interaction.InteractionManager#mousedown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object.
         *
         * @event PIXI.interaction.InteractionManager#mouseup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object.
         *
         * @event PIXI.interaction.InteractionManager#click
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object.
         *
         * @event PIXI.interaction.InteractionManager#rightclick
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.
         *
         * @event PIXI.interaction.InteractionManager#mouseupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.
         *
         * @event PIXI.interaction.InteractionManager#rightupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved while over the display object
         *
         * @event PIXI.interaction.InteractionManager#mousemove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved onto the display object
         *
         * @event PIXI.interaction.InteractionManager#mouseover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved off the display object
         *
         * @event PIXI.interaction.InteractionManager#mouseout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed on the display object.
         *
         * @event PIXI.interaction.InteractionManager#pointerdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released over the display object.
         * Not always fired when some buttons are held down while others are released. In those cases,
         * use [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown} and
         * [mouseup]{@link PIXI.interaction.InteractionManager#event:mouseup} instead.
         *
         * @event PIXI.interaction.InteractionManager#pointerup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a pointer event
         *
         * @event PIXI.interaction.InteractionManager#pointercancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed and released on the display object.
         *
         * @event PIXI.interaction.InteractionManager#pointertap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.
         *
         * @event PIXI.interaction.InteractionManager#pointerupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved while over the display object
         *
         * @event PIXI.interaction.InteractionManager#pointermove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved onto the display object
         *
         * @event PIXI.interaction.InteractionManager#pointerover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved off the display object
         *
         * @event PIXI.interaction.InteractionManager#pointerout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed on the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchstart
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed from the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchend
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a touch
         *
         * @event PIXI.interaction.InteractionManager#touchcancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed and removed from the display object.
         *
         * @event PIXI.interaction.InteractionManager#tap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.
         *
         * @event PIXI.interaction.InteractionManager#touchendoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is moved along the display object.
         *
         * @event PIXI.interaction.InteractionManager#touchmove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mousedown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#click
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightclick
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#rightupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mousemove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device (usually a mouse) is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#mouseout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerdown
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerup
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a pointer event.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointercancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is pressed and released on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointertap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerupoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointermove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerover
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a pointer device is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#pointerout
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchstart
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchend
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when the operating system cancels a touch.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchcancel
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is placed and removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#tap
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchendoutside
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        /**
         * Fired when a touch point is moved along the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * @event PIXI.DisplayObject#touchmove
         * @param {PIXI.interaction.InteractionEvent} event - Interaction event
         */

        this.setTargetElement(this.renderer.view, this.renderer.resolution);
    }

    if ( EventEmitter ) InteractionManager.__proto__ = EventEmitter;
    InteractionManager.prototype = Object.create( EventEmitter && EventEmitter.prototype );
    InteractionManager.prototype.constructor = InteractionManager;

    /**
     * Hit tests a point against the display tree, returning the first interactive object that is hit.
     *
     * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.
     * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults
     * to the last rendered root of the associated renderer.
     * @return {PIXI.DisplayObject} The hit display object, if any.
     */
    InteractionManager.prototype.hitTest = function hitTest (globalPoint, root)
    {
        // clear the target for our hit test
        hitTestEvent.target = null;
        // assign the global point
        hitTestEvent.data.global = globalPoint;
        // ensure safety of the root
        if (!root)
        {
            root = this.renderer._lastObjectRendered;
        }
        // run the hit test
        this.processInteractive(hitTestEvent, root, null, true);
        // return our found object - it'll be null if we didn't hit anything

        return hitTestEvent.target;
    };

    /**
     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate
     * another DOM element to receive those events.
     *
     * @param {HTMLElement} element - the DOM element which will receive mouse and touch events.
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).
     */
    InteractionManager.prototype.setTargetElement = function setTargetElement (element, resolution)
    {
        if ( resolution === void 0 ) resolution = 1;

        this.removeEvents();

        this.interactionDOMElement = element;

        this.resolution = resolution;

        this.addEvents();
    };

    /**
     * Registers all the DOM events
     *
     * @private
     */
    InteractionManager.prototype.addEvents = function addEvents ()
    {
        if (!this.interactionDOMElement)
        {
            return;
        }

        _pixi_ticker__WEBPACK_IMPORTED_MODULE_1__.Ticker.system.add(this.update, this, _pixi_ticker__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.INTERACTION);

        if (window.navigator.msPointerEnabled)
        {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        else if (this.supportsPointerEvents)
        {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }

        /**
         * These events are added first, so that if pointer events are normalized, they are fired
         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd
         */
        if (this.supportsPointerEvents)
        {
            window.document.addEventListener('pointermove', this.onPointerMove, true);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);
            // pointerout is fired in addition to pointerup (for touch events) and pointercancel
            // we already handle those, so for the purposes of what we do in onPointerOut, we only
            // care about the pointerleave event
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
            window.addEventListener('pointercancel', this.onPointerCancel, true);
            window.addEventListener('pointerup', this.onPointerUp, true);
        }
        else
        {
            window.document.addEventListener('mousemove', this.onPointerMove, true);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
            window.addEventListener('mouseup', this.onPointerUp, true);
        }

        // always look directly for touch events so that we can provide original data
        // In a future version we should change this to being just a fallback and rely solely on
        // PointerEvents whenever available
        if (this.supportsTouchEvents)
        {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
        }

        this.eventsAdded = true;
    };

    /**
     * Removes all the DOM events that were previously registered
     *
     * @private
     */
    InteractionManager.prototype.removeEvents = function removeEvents ()
    {
        if (!this.interactionDOMElement)
        {
            return;
        }

        _pixi_ticker__WEBPACK_IMPORTED_MODULE_1__.Ticker.system.remove(this.update, this);

        if (window.navigator.msPointerEnabled)
        {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        else if (this.supportsPointerEvents)
        {
            this.interactionDOMElement.style['touch-action'] = '';
        }

        if (this.supportsPointerEvents)
        {
            window.document.removeEventListener('pointermove', this.onPointerMove, true);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
            window.removeEventListener('pointercancel', this.onPointerCancel, true);
            window.removeEventListener('pointerup', this.onPointerUp, true);
        }
        else
        {
            window.document.removeEventListener('mousemove', this.onPointerMove, true);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
            window.removeEventListener('mouseup', this.onPointerUp, true);
        }

        if (this.supportsTouchEvents)
        {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
        }

        this.interactionDOMElement = null;

        this.eventsAdded = false;
    };

    /**
     * Updates the state of interactive objects.
     * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.
     *
     * @param {number} deltaTime - time delta since last tick
     */
    InteractionManager.prototype.update = function update (deltaTime)
    {
        this._deltaTime += deltaTime;

        if (this._deltaTime < this.interactionFrequency)
        {
            return;
        }

        this._deltaTime = 0;

        if (!this.interactionDOMElement)
        {
            return;
        }

        // if the user move the mouse this check has already been done using the mouse move!
        if (this.didMove)
        {
            this.didMove = false;

            return;
        }

        this.cursor = null;

        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
        // but there was a scenario of a display object moving under a static mouse cursor.
        // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function
        for (var k in this.activeInteractionData)
        {
            // eslint-disable-next-line no-prototype-builtins
            if (this.activeInteractionData.hasOwnProperty(k))
            {
                var interactionData = this.activeInteractionData[k];

                if (interactionData.originalEvent && interactionData.pointerType !== 'touch')
                {
                    var interactionEvent = this.configureInteractionEventForDOMEvent(
                        this.eventData,
                        interactionData.originalEvent,
                        interactionData
                    );

                    this.processInteractive(
                        interactionEvent,
                        this.renderer._lastObjectRendered,
                        this.processPointerOverOut,
                        true
                    );
                }
            }
        }

        this.setCursorMode(this.cursor);
    };

    /**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
     */
    InteractionManager.prototype.setCursorMode = function setCursorMode (mode)
    {
        mode = mode || 'default';
        // if the mode didn't actually change, bail early
        if (this.currentCursorMode === mode)
        {
            return;
        }
        this.currentCursorMode = mode;
        var style = this.cursorStyles[mode];

        // only do things if there is a cursor style for it
        if (style)
        {
            switch (typeof style)
            {
                case 'string':
                    // string styles are handled as cursor CSS
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    // functions are just called, and passed the cursor mode
                    style(mode);
                    break;
                case 'object':
                    // if it is an object, assume that it is a dictionary of CSS styles,
                    // apply it to the interactionDOMElement
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        }
        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))
        {
            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry
            // for the mode, then assume that the dev wants it to be CSS for the cursor.
            this.interactionDOMElement.style.cursor = mode;
        }
    };

    /**
     * Dispatches an event on the display object that was interacted with
     *
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */
    InteractionManager.prototype.dispatchEvent = function dispatchEvent (displayObject, eventString, eventData)
    {
        if (!eventData.stopped)
        {
            eventData.currentTarget = displayObject;
            eventData.type = eventString;

            displayObject.emit(eventString, eventData);

            if (displayObject[eventString])
            {
                displayObject[eventString](eventData);
            }
        }
    };

    /**
     * Puts a event on a queue to be dispatched later. This is used to guarantee correct
     * ordering of over/out events.
     *
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */
    InteractionManager.prototype.delayDispatchEvent = function delayDispatchEvent (displayObject, eventString, eventData)
    {
        this.delayedEvents.push({ displayObject: displayObject, eventString: eventString, eventData: eventData });
    };

    /**
     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {PIXI.Point} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */
    InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint (point, x, y)
    {
        var rect;

        // IE 11 fix
        if (!this.interactionDOMElement.parentElement)
        {
            rect = { x: 0, y: 0, width: 0, height: 0 };
        }
        else
        {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }

        var resolutionMultiplier = 1.0 / this.resolution;

        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;
    };

    /**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @protected
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @param {boolean} [interactive] - Whether the displayObject is interactive
     * @param {boolean} [skipDelayed] - Whether to process delayed events before returning. This is
     *  used to avoid processing them too early during recursive calls.
     * @return {boolean} returns true if the displayObject hit the point
     */
    InteractionManager.prototype.processInteractive = function processInteractive (interactionEvent, displayObject, func, hitTest, interactive, skipDelayed)
    {
        if (!displayObject || !displayObject.visible)
        {
            return false;
        }

        var point = interactionEvent.data.global;

        // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^
        //
        // This function will now loop through all objects and then only hit test the objects it HAS
        // to, not all of them. MUCH faster..
        // An object will be hit test if the following is true:
        //
        // 1: It is interactive.
        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
        //
        // As another little optimization once an interactive object has been hit we can carry on
        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
        // A final optimization is that an object is not hit test directly if a child has already been hit.

        interactive = displayObject.interactive || interactive;

        var hit = false;
        var interactiveParent = interactive;

        // Flag here can set to false if the event is outside the parents hitArea or mask
        var hitTestChildren = true;

        // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea
        // There is also no longer a need to hitTest children.
        if (displayObject.hitArea)
        {
            if (hitTest)
            {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y))
                {
                    hitTest = false;
                    hitTestChildren = false;
                }
                else
                {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.
        // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.
        // https://github.com/pixijs/pixi.js/issues/5135
        else if (displayObject._mask)
        {
            if (hitTest)
            {
                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point)))
                {
                    hitTest = false;
                }
            }
        }

        // ** FREE TIP **! If an object is not interactive or has no buttons in it
        // (such as a game scene!) set interactiveChildren to false for that displayObject.
        // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.
        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children)
        {
            var children = displayObject.children;

            for (var i = children.length - 1; i >= 0; i--)
            {
                var child = children[i];

                // time to get recursive.. if this function will return if something is hit..
                var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent, true);

                if (childHit)
                {
                    // its a good idea to check if a child has lost its parent.
                    // this means it has been removed whilst looping so its best
                    if (!child.parent)
                    {
                        continue;
                    }

                    // we no longer need to hit test any more objects in this container as we we
                    // now know the parent has been hit
                    interactiveParent = false;

                    // If the child is interactive , that means that the object hit was actually
                    // interactive and not just the child of an interactive object.
                    // This means we no longer need to hit test anything else. We still need to run
                    // through all objects, but we don't need to perform any hit tests.

                    if (childHit)
                    {
                        if (interactionEvent.target)
                        {
                            hitTest = false;
                        }
                        hit = true;
                    }
                }
            }
        }

        // no point running this if the item is not interactive or does not have an interactive parent.
        if (interactive)
        {
            // if we are hit testing (as in we have no hit any objects yet)
            // We also don't need to worry about hit testing if once of the displayObjects children
            // has already been hit - but only if it was interactive, otherwise we need to keep
            // looking for an interactive child, just in case we hit one
            if (hitTest && !interactionEvent.target)
            {
                // already tested against hitArea if it is defined
                if (!displayObject.hitArea && displayObject.containsPoint)
                {
                    if (displayObject.containsPoint(point))
                    {
                        hit = true;
                    }
                }
            }

            if (displayObject.interactive)
            {
                if (hit && !interactionEvent.target)
                {
                    interactionEvent.target = displayObject;
                }

                if (func)
                {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }

        var delayedEvents = this.delayedEvents;

        if (delayedEvents.length && !skipDelayed)
        {
            var delayedLen = delayedEvents.length;

            this.delayedEvents = [];

            for (var i$1 = 0; i$1 < delayedLen; i$1++)
            {
                var delayed = delayedEvents[i$1];

                this.dispatchEvent(delayed.displayObject, delayed.eventString, delayed.eventData);
            }
        }

        return hit;
    };

    /**
     * Is called when the pointer button is pressed down on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
     */
    InteractionManager.prototype.onPointerDown = function onPointerDown (originalEvent)
    {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') { return; }

        var events = this.normalizeToPointerData(originalEvent);

        /**
         * No need to prevent default on natural pointer events, as there are no side effects
         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
         * so still need to be prevented.
         */

        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type

        if (this.autoPreventDefault && events[0].isNormalized)
        {
            var cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);

            if (cancelable)
            {
                originalEvent.preventDefault();
            }
        }

        var eventLen = events.length;

        for (var i = 0; i < eventLen; i++)
        {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);

            this.emit('pointerdown', interactionEvent);
            if (event.pointerType === 'touch')
            {
                this.emit('touchstart', interactionEvent);
            }
            // emit a mouse event for "pen" pointers, the way a browser would emit a fallback event
            else if (event.pointerType === 'mouse' || event.pointerType === 'pen')
            {
                var isRightButton = event.button === 2;

                this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
            }
        }
    };

    /**
     * Processes the result of the pointer down check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */
    InteractionManager.prototype.processPointerDown = function processPointerDown (interactionEvent, displayObject, hit)
    {
        var data = interactionEvent.data;
        var id = interactionEvent.data.identifier;

        if (hit)
        {
            if (!displayObject.trackedPointers[id])
            {
                displayObject.trackedPointers[id] = new InteractionTrackingData(id);
            }
            this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);

            if (data.pointerType === 'touch')
            {
                this.dispatchEvent(displayObject, 'touchstart', interactionEvent);
            }
            else if (data.pointerType === 'mouse' || data.pointerType === 'pen')
            {
                var isRightButton = data.button === 2;

                if (isRightButton)
                {
                    displayObject.trackedPointers[id].rightDown = true;
                }
                else
                {
                    displayObject.trackedPointers[id].leftDown = true;
                }

                this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
            }
        }
    };

    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
     * @param {boolean} cancelled - true if the pointer is cancelled
     * @param {Function} func - Function passed to {@link processInteractive}
     */
    InteractionManager.prototype.onPointerComplete = function onPointerComplete (originalEvent, cancelled, func)
    {
        var events = this.normalizeToPointerData(originalEvent);

        var eventLen = events.length;

        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside
        // in all cases (unless it was a pointercancel)
        var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';

        for (var i = 0; i < eventLen; i++)
        {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            // perform hit testing for events targeting our canvas or cancel events
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);

            this.emit(cancelled ? 'pointercancel' : ("pointerup" + eventAppend), interactionEvent);

            if (event.pointerType === 'mouse' || event.pointerType === 'pen')
            {
                var isRightButton = event.button === 2;

                this.emit(isRightButton ? ("rightup" + eventAppend) : ("mouseup" + eventAppend), interactionEvent);
            }
            else if (event.pointerType === 'touch')
            {
                this.emit(cancelled ? 'touchcancel' : ("touchend" + eventAppend), interactionEvent);
                this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
            }
        }
    };

    /**
     * Is called when the pointer button is cancelled
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */
    InteractionManager.prototype.onPointerCancel = function onPointerCancel (event)
    {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && event.pointerType === 'touch') { return; }

        this.onPointerComplete(event, true, this.processPointerCancel);
    };

    /**
     * Processes the result of the pointer cancel check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     */
    InteractionManager.prototype.processPointerCancel = function processPointerCancel (interactionEvent, displayObject)
    {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        if (displayObject.trackedPointers[id] !== undefined)
        {
            delete displayObject.trackedPointers[id];
            this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);

            if (data.pointerType === 'touch')
            {
                this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);
            }
        }
    };

    /**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */
    InteractionManager.prototype.onPointerUp = function onPointerUp (event)
    {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && event.pointerType === 'touch') { return; }

        this.onPointerComplete(event, false, this.processPointerUp);
    };

    /**
     * Processes the result of the pointer up check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */
    InteractionManager.prototype.processPointerUp = function processPointerUp (interactionEvent, displayObject, hit)
    {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        var trackingData = displayObject.trackedPointers[id];

        var isTouch = data.pointerType === 'touch';

        var isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
        // need to track mouse down status in the mouse block so that we can emit
        // event in a later block
        var isMouseTap = false;

        // Mouse only
        if (isMouse)
        {
            var isRightButton = data.button === 2;

            var flags = InteractionTrackingData.FLAGS;

            var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;

            var isDown = trackingData !== undefined && (trackingData.flags & test);

            if (hit)
            {
                this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);

                if (isDown)
                {
                    this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);
                    // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap
                    isMouseTap = true;
                }
            }
            else if (isDown)
            {
                this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);
            }
            // update the down state of the tracking data
            if (trackingData)
            {
                if (isRightButton)
                {
                    trackingData.rightDown = false;
                }
                else
                {
                    trackingData.leftDown = false;
                }
            }
        }

        // Pointers and Touches, and Mouse
        if (hit)
        {
            this.dispatchEvent(displayObject, 'pointerup', interactionEvent);
            if (isTouch) { this.dispatchEvent(displayObject, 'touchend', interactionEvent); }

            if (trackingData)
            {
                // emit pointertap if not a mouse, or if the mouse block decided it was a tap
                if (!isMouse || isMouseTap)
                {
                    this.dispatchEvent(displayObject, 'pointertap', interactionEvent);
                }
                if (isTouch)
                {
                    this.dispatchEvent(displayObject, 'tap', interactionEvent);
                    // touches are no longer over (if they ever were) when we get the touchend
                    // so we should ensure that we don't keep pretending that they are
                    trackingData.over = false;
                }
            }
        }
        else if (trackingData)
        {
            this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);
            if (isTouch) { this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent); }
        }
        // Only remove the tracking data if there is no over/down state still associated with it
        if (trackingData && trackingData.none)
        {
            delete displayObject.trackedPointers[id];
        }
    };

    /**
     * Is called when the pointer moves across the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
     */
    InteractionManager.prototype.onPointerMove = function onPointerMove (originalEvent)
    {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') { return; }

        var events = this.normalizeToPointerData(originalEvent);

        if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen')
        {
            this.didMove = true;

            this.cursor = null;
        }

        var eventLen = events.length;

        for (var i = 0; i < eventLen; i++)
        {
            var event = events[i];

            var interactionData = this.getInteractionDataForPointerId(event);

            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

            interactionEvent.data.originalEvent = originalEvent;

            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, true);

            this.emit('pointermove', interactionEvent);
            if (event.pointerType === 'touch') { this.emit('touchmove', interactionEvent); }
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') { this.emit('mousemove', interactionEvent); }
        }

        if (events[0].pointerType === 'mouse')
        {
            this.setCursorMode(this.cursor);

            // TODO BUG for parents interactive object (border order issue)
        }
    };

    /**
     * Processes the result of the pointer move check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */
    InteractionManager.prototype.processPointerMove = function processPointerMove (interactionEvent, displayObject, hit)
    {
        var data = interactionEvent.data;

        var isTouch = data.pointerType === 'touch';

        var isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');

        if (isMouse)
        {
            this.processPointerOverOut(interactionEvent, displayObject, hit);
        }

        if (!this.moveWhenInside || hit)
        {
            this.dispatchEvent(displayObject, 'pointermove', interactionEvent);
            if (isTouch) { this.dispatchEvent(displayObject, 'touchmove', interactionEvent); }
            if (isMouse) { this.dispatchEvent(displayObject, 'mousemove', interactionEvent); }
        }
    };

    /**
     * Is called when the pointer is moved out of the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
     */
    InteractionManager.prototype.onPointerOut = function onPointerOut (originalEvent)
    {
        // if we support touch events, then only use those for touch events, not pointer events
        if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') { return; }

        var events = this.normalizeToPointerData(originalEvent);

        // Only mouse and pointer can call onPointerOut, so events will always be length 1
        var event = events[0];

        if (event.pointerType === 'mouse')
        {
            this.mouseOverRenderer = false;
            this.setCursorMode(null);
        }

        var interactionData = this.getInteractionDataForPointerId(event);

        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

        interactionEvent.data.originalEvent = event;

        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);

        this.emit('pointerout', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen')
        {
            this.emit('mouseout', interactionEvent);
        }
        else
        {
            // we can get touchleave events after touchend, so we want to make sure we don't
            // introduce memory leaks
            this.releaseInteractionDataForPointerId(interactionData.identifier);
        }
    };

    /**
     * Processes the result of the pointer over/out check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */
    InteractionManager.prototype.processPointerOverOut = function processPointerOverOut (interactionEvent, displayObject, hit)
    {
        var data = interactionEvent.data;

        var id = interactionEvent.data.identifier;

        var isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');

        var trackingData = displayObject.trackedPointers[id];

        // if we just moused over the display object, then we need to track that state
        if (hit && !trackingData)
        {
            trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }

        if (trackingData === undefined) { return; }

        if (hit && this.mouseOverRenderer)
        {
            if (!trackingData.over)
            {
                trackingData.over = true;
                this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);
                if (isMouse)
                {
                    this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);
                }
            }

            // only change the cursor if it has not already been changed (by something deeper in the
            // display tree)
            if (isMouse && this.cursor === null)
            {
                this.cursor = displayObject.cursor;
            }
        }
        else if (trackingData.over)
        {
            trackingData.over = false;
            this.dispatchEvent(displayObject, 'pointerout', this.eventData);
            if (isMouse)
            {
                this.dispatchEvent(displayObject, 'mouseout', interactionEvent);
            }
            // if there is no mouse down information for the pointer, then it is safe to delete
            if (trackingData.none)
            {
                delete displayObject.trackedPointers[id];
            }
        }
    };

    /**
     * Is called when the pointer is moved into the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
     */
    InteractionManager.prototype.onPointerOver = function onPointerOver (originalEvent)
    {
        var events = this.normalizeToPointerData(originalEvent);

        // Only mouse and pointer can call onPointerOver, so events will always be length 1
        var event = events[0];

        var interactionData = this.getInteractionDataForPointerId(event);

        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);

        interactionEvent.data.originalEvent = event;

        if (event.pointerType === 'mouse')
        {
            this.mouseOverRenderer = true;
        }

        this.emit('pointerover', interactionEvent);
        if (event.pointerType === 'mouse' || event.pointerType === 'pen')
        {
            this.emit('mouseover', interactionEvent);
        }
    };

    /**
     * Get InteractionData for a given pointerId. Store that data as well
     *
     * @private
     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
     * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier
     */
    InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId (event)
    {
        var pointerId = event.pointerId;

        var interactionData;

        if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse')
        {
            interactionData = this.mouse;
        }
        else if (this.activeInteractionData[pointerId])
        {
            interactionData = this.activeInteractionData[pointerId];
        }
        else
        {
            interactionData = this.interactionDataPool.pop() || new InteractionData();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        // copy properties from the event, so that we can make sure that touch/pointer specific
        // data is available
        interactionData.copyEvent(event);

        return interactionData;
    };

    /**
     * Return unused InteractionData to the pool, for a given pointerId
     *
     * @private
     * @param {number} pointerId - Identifier from a pointer event
     */
    InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId (pointerId)
    {
        var interactionData = this.activeInteractionData[pointerId];

        if (interactionData)
        {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    };

    /**
     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
     *
     * @private
     * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured
     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
     * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired
     *        with the InteractionEvent
     * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in
     */
    InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent (interactionEvent, pointerEvent, interactionData)
    {
        interactionEvent.data = interactionData;

        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);

        // Not really sure why this is happening, but it's how a previous version handled things
        if (pointerEvent.pointerType === 'touch')
        {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }

        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();

        return interactionEvent;
    };

    /**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @private
     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */
    InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData (event)
    {
        var normalizedEvents = [];

        if (this.supportsTouchEvents && event instanceof TouchEvent)
        {
            for (var i = 0, li = event.changedTouches.length; i < li; i++)
            {
                var touch = event.changedTouches[i];

                if (typeof touch.button === 'undefined') { touch.button = event.touches.length ? 1 : 0; }
                if (typeof touch.buttons === 'undefined') { touch.buttons = event.touches.length ? 1 : 0; }
                if (typeof touch.isPrimary === 'undefined')
                {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') { touch.width = touch.radiusX || 1; }
                if (typeof touch.height === 'undefined') { touch.height = touch.radiusY || 1; }
                if (typeof touch.tiltX === 'undefined') { touch.tiltX = 0; }
                if (typeof touch.tiltY === 'undefined') { touch.tiltY = 0; }
                if (typeof touch.pointerType === 'undefined') { touch.pointerType = 'touch'; }
                if (typeof touch.pointerId === 'undefined') { touch.pointerId = touch.identifier || 0; }
                if (typeof touch.pressure === 'undefined') { touch.pressure = touch.force || 0.5; }
                if (typeof touch.twist === 'undefined') { touch.twist = 0; }
                if (typeof touch.tangentialPressure === 'undefined') { touch.tangentialPressure = 0; }
                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven
                // support, and the fill ins are not quite the same
                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top
                // left is not 0,0 on the page
                if (typeof touch.layerX === 'undefined') { touch.layerX = touch.offsetX = touch.clientX; }
                if (typeof touch.layerY === 'undefined') { touch.layerY = touch.offsetY = touch.clientY; }

                // mark the touch as normalized, just so that we know we did it
                touch.isNormalized = true;

                normalizedEvents.push(touch);
            }
        }
        // apparently PointerEvent subclasses MouseEvent, so yay
        else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent)))
        {
            if (typeof event.isPrimary === 'undefined') { event.isPrimary = true; }
            if (typeof event.width === 'undefined') { event.width = 1; }
            if (typeof event.height === 'undefined') { event.height = 1; }
            if (typeof event.tiltX === 'undefined') { event.tiltX = 0; }
            if (typeof event.tiltY === 'undefined') { event.tiltY = 0; }
            if (typeof event.pointerType === 'undefined') { event.pointerType = 'mouse'; }
            if (typeof event.pointerId === 'undefined') { event.pointerId = MOUSE_POINTER_ID; }
            if (typeof event.pressure === 'undefined') { event.pressure = 0.5; }
            if (typeof event.twist === 'undefined') { event.twist = 0; }
            if (typeof event.tangentialPressure === 'undefined') { event.tangentialPressure = 0; }

            // mark the mouse event as normalized, just so that we know we did it
            event.isNormalized = true;

            normalizedEvents.push(event);
        }
        else
        {
            normalizedEvents.push(event);
        }

        return normalizedEvents;
    };

    /**
     * Destroys the interaction manager
     *
     */
    InteractionManager.prototype.destroy = function destroy ()
    {
        this.removeEvents();

        this.removeAllListeners();

        this.renderer = null;

        this.mouse = null;

        this.eventData = null;

        this.interactionDOMElement = null;

        this.onPointerDown = null;
        this.processPointerDown = null;

        this.onPointerUp = null;
        this.processPointerUp = null;

        this.onPointerCancel = null;
        this.processPointerCancel = null;

        this.onPointerMove = null;
        this.processPointerMove = null;

        this.onPointerOut = null;
        this.processPointerOverOut = null;

        this.onPointerOver = null;

        this._tempPoint = null;
    };

    return InteractionManager;
}(_pixi_utils__WEBPACK_IMPORTED_MODULE_3__.EventEmitter));

/**
 * This namespace contains a renderer plugin for handling mouse, pointer, and touch events.
 *
 * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.
 * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.
 * @namespace PIXI.interaction
 */


//# sourceMappingURL=interaction.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/loaders/lib/loaders.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/loaders/lib/loaders.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppLoaderPlugin": () => (/* binding */ AppLoaderPlugin),
/* harmony export */   "Loader": () => (/* binding */ Loader),
/* harmony export */   "LoaderResource": () => (/* binding */ LoaderResource),
/* harmony export */   "TextureLoader": () => (/* binding */ TextureLoader)
/* harmony export */ });
/* harmony import */ var resource_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource-loader */ "./node_modules/resource-loader/dist/resource-loader.esm.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/loaders - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */




/**
 * Loader plugin for handling Texture resources.
 * @class
 * @memberof PIXI
 * @implements PIXI.ILoaderPlugin
 */
var TextureLoader = function TextureLoader () {};

TextureLoader.use = function use (resource, next)
{
    // create a new texture if the data is an Image object
    if (resource.data && resource.type === resource_loader__WEBPACK_IMPORTED_MODULE_0__.Resource.TYPE.IMAGE)
    {
        resource.texture = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.Texture.fromLoader(
            resource.data,
            resource.url,
            resource.name
        );
    }
    next();
};

/**
 * The new loader, extends Resource Loader by Chad Engler: https://github.com/englercj/resource-loader
 *
 * ```js
 * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.
 * //or
 * const loader = new PIXI.Loader(); // you can also create your own if you want
 *
 * const sprites = {};
 *
 * // Chainable `add` to enqueue a resource
 * loader.add('bunny', 'data/bunny.png')
 *       .add('spaceship', 'assets/spritesheet.json');
 * loader.add('scoreFont', 'assets/score.fnt');
 *
 * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.
 * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).
 * loader.pre(cachingMiddleware);
 *
 * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.
 * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).
 * loader.use(parsingMiddleware);
 *
 * // The `load` method loads the queue of resources, and calls the passed in callback called once all
 * // resources have loaded.
 * loader.load((loader, resources) => {
 *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.
 *     // They have a couple default properties:
 *     // - `url`: The URL that the resource was loaded from
 *     // - `error`: The error that happened when trying to load (if any)
 *     // - `data`: The raw data that was loaded
 *     // also may contain other properties based on the middleware that runs.
 *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);
 *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);
 *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);
 * });
 *
 * // throughout the process multiple signals can be dispatched.
 * loader.onProgress.add(() => {}); // called once per loaded/errored file
 * loader.onError.add(() => {}); // called once per errored file
 * loader.onLoad.add(() => {}); // called once per loaded file
 * loader.onComplete.add(() => {}); // called once when the queued resources all load.
 * ```
 *
 * @see https://github.com/englercj/resource-loader
 *
 * @class Loader
 * @memberof PIXI
 * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
 * @param {number} [concurrency=10] - The number of resources to load concurrently.
 */
var Loader = /*@__PURE__*/(function (ResourceLoader) {
    function Loader(baseUrl, concurrency)
    {
        var this$1 = this;

        ResourceLoader.call(this, baseUrl, concurrency);
        _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter.call(this);

        for (var i = 0; i < Loader._plugins.length; ++i)
        {
            var plugin = Loader._plugins[i];
            var pre = plugin.pre;
            var use = plugin.use;

            if (pre)
            {
                this.pre(pre);
            }

            if (use)
            {
                this.use(use);
            }
        }

        // Compat layer, translate the new v2 signals into old v1 events.
        this.onStart.add(function (l) { return this$1.emit('start', l); });
        this.onProgress.add(function (l, r) { return this$1.emit('progress', l, r); });
        this.onError.add(function (e, l, r) { return this$1.emit('error', e, l, r); });
        this.onLoad.add(function (l, r) { return this$1.emit('load', l, r); });
        this.onComplete.add(function (l, r) { return this$1.emit('complete', l, r); });

        /**
         * If this loader cannot be destroyed.
         * @member {boolean}
         * @default false
         * @private
         */
        this._protected = false;
    }

    if ( ResourceLoader ) Loader.__proto__ = ResourceLoader;
    Loader.prototype = Object.create( ResourceLoader && ResourceLoader.prototype );
    Loader.prototype.constructor = Loader;

    var staticAccessors = { shared: { configurable: true } };

    /**
     * Destroy the loader, removes references.
     * @private
     */
    Loader.prototype.destroy = function destroy ()
    {
        if (!this._protected)
        {
            this.removeAllListeners();
            this.reset();
        }
    };

    /**
     * A premade instance of the loader that can be used to load resources.
     * @name shared
     * @type {PIXI.Loader}
     * @static
     * @memberof PIXI.Loader
     */
    staticAccessors.shared.get = function ()
    {
        var shared = Loader._shared;

        if (!shared)
        {
            shared = new Loader();
            shared._protected = true;
            Loader._shared = shared;
        }

        return shared;
    };

    Object.defineProperties( Loader, staticAccessors );

    return Loader;
}(resource_loader__WEBPACK_IMPORTED_MODULE_0__.Loader));

// Copy EE3 prototype (mixin)
Object.assign(Loader.prototype, _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter.prototype);

/**
 * Collection of all installed `use` middleware for Loader.
 *
 * @static
 * @member {Array<PIXI.ILoaderPlugin>} _plugins
 * @memberof PIXI.Loader
 * @private
 */
Loader._plugins = [];

/**
 * Adds a Loader plugin for the global shared loader and all
 * new Loader instances created.
 *
 * @static
 * @method registerPlugin
 * @memberof PIXI.Loader
 * @param {PIXI.ILoaderPlugin} plugin - The plugin to add
 * @return {PIXI.Loader} Reference to PIXI.Loader for chaining
 */
Loader.registerPlugin = function registerPlugin(plugin)
{
    Loader._plugins.push(plugin);

    if (plugin.add)
    {
        plugin.add();
    }

    return Loader;
};

// parse any blob into more usable objects (e.g. Image)
Loader.registerPlugin({ use: resource_loader__WEBPACK_IMPORTED_MODULE_0__.middleware.parsing });

// parse any Image objects into textures
Loader.registerPlugin(TextureLoader);

/**
 * Plugin to be installed for handling specific Loader resources.
 *
 * @memberof PIXI
 * @typedef ILoaderPlugin
 * @property {function} [add] - Function to call immediate after registering plugin.
 * @property {PIXI.Loader.loaderMiddleware} [pre] - Middleware function to run before load, the
 *           arguments for this are `(resource, next)`
 * @property {PIXI.Loader.loaderMiddleware} [use] - Middleware function to run after load, the
 *           arguments for this are `(resource, next)`
 */

/**
 * @memberof PIXI.Loader
 * @callback loaderMiddleware
 * @param {PIXI.LoaderResource} resource
 * @param {function} next
 */

/**
 * @memberof PIXI.Loader#
 * @member {object} onStart
 */

/**
 * @memberof PIXI.Loader#
 * @member {object} onProgress
 */

/**
 * @memberof PIXI.Loader#
 * @member {object} onError
 */

/**
 * @memberof PIXI.Loader#
 * @member {object} onLoad
 */

/**
 * @memberof PIXI.Loader#
 * @member {object} onComplete
 */

/**
 * Application plugin for supporting loader option. Installing the LoaderPlugin
 * is not necessary if using **pixi.js** or **pixi.js-legacy**.
 * @example
 * import {AppLoaderPlugin} from '@pixi/loaders';
 * import {Application} from '@pixi/app';
 * Application.registerPlugin(AppLoaderPlugin);
 * @class
 * @memberof PIXI
 */
var AppLoaderPlugin = function AppLoaderPlugin () {};

AppLoaderPlugin.init = function init (options)
{
    options = Object.assign({
        sharedLoader: false,
    }, options);

    /**
     * Loader instance to help with asset loading.
     * @name PIXI.Application#loader
     * @type {PIXI.Loader}
     * @readonly
     */
    this.loader = options.sharedLoader ? Loader.shared : new Loader();
};

/**
 * Called when application destroyed
 * @private
 */
AppLoaderPlugin.destroy = function destroy ()
{
    if (this.loader)
    {
        this.loader.destroy();
        this.loader = null;
    }
};

/**
 * Reference to **{@link https://github.com/englercj/resource-loader
 * resource-loader}**'s Resource class.
 * @see http://englercj.github.io/resource-loader/Resource.html
 * @class LoaderResource
 * @memberof PIXI
 */
var LoaderResource = resource_loader__WEBPACK_IMPORTED_MODULE_0__.Resource;


//# sourceMappingURL=loaders.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/math.es.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/math/lib/math.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* binding */ Circle),
/* harmony export */   "DEG_TO_RAD": () => (/* binding */ DEG_TO_RAD),
/* harmony export */   "Ellipse": () => (/* binding */ Ellipse),
/* harmony export */   "GroupD8": () => (/* binding */ GroupD8),
/* harmony export */   "Matrix": () => (/* binding */ Matrix),
/* harmony export */   "ObservablePoint": () => (/* binding */ ObservablePoint),
/* harmony export */   "PI_2": () => (/* binding */ PI_2),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "Polygon": () => (/* binding */ Polygon),
/* harmony export */   "RAD_TO_DEG": () => (/* binding */ RAD_TO_DEG),
/* harmony export */   "Rectangle": () => (/* binding */ Rectangle),
/* harmony export */   "RoundedRectangle": () => (/* binding */ RoundedRectangle),
/* harmony export */   "SHAPES": () => (/* binding */ SHAPES),
/* harmony export */   "Transform": () => (/* binding */ Transform)
/* harmony export */ });
/*!
 * @pixi/math - v5.1.0
 * Compiled Fri, 19 Jul 2019 21:54:36 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 */
var Point = function Point(x, y)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;
};

/**
 * Creates a clone of this point
 *
 * @return {PIXI.Point} a copy of the point
 */
Point.prototype.clone = function clone ()
{
    return new Point(this.x, this.y);
};

/**
 * Copies x and y from the given point
 *
 * @param {PIXI.IPoint} p - The point to copy from
 * @returns {PIXI.IPoint} Returns itself.
 */
Point.prototype.copyFrom = function copyFrom (p)
{
    this.set(p.x, p.y);

    return this;
};

/**
 * Copies x and y into the given point
 *
 * @param {PIXI.IPoint} p - The point to copy.
 * @returns {PIXI.IPoint} Given point with values updated
 */
Point.prototype.copyTo = function copyTo (p)
{
    p.set(this.x, this.y);

    return p;
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param {PIXI.IPoint} p - The point to check
 * @returns {boolean} Whether the given point equal to this point
 */
Point.prototype.equals = function equals (p)
{
    return (p.x === this.x) && (p.y === this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param {number} [x=0] - position of the point on the x axis
 * @param {number} [y=0] - position of the point on the y axis
 */
Point.prototype.set = function set (x, y)
{
    this.x = x || 0;
    this.y = y || ((y !== 0) ? this.x : 0);
};

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * An ObservablePoint is a point that triggers a callback when the point's position is changed.
 *
 * @class
 * @memberof PIXI
 */
var ObservablePoint = function ObservablePoint(cb, scope, x, y)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;

    this._x = x;
    this._y = y;

    this.cb = cb;
    this.scope = scope;
};

var prototypeAccessors = { x: { configurable: true },y: { configurable: true } };

/**
 * Creates a clone of this point.
 * The callback and scope params can be overidden otherwise they will default
 * to the clone object's values.
 *
 * @override
 * @param {Function} [cb=null] - callback when changed
 * @param {object} [scope=null] - owner of callback
 * @return {PIXI.ObservablePoint} a copy of the point
 */
ObservablePoint.prototype.clone = function clone (cb, scope)
{
        if ( cb === void 0 ) cb = null;
        if ( scope === void 0 ) scope = null;

    var _cb = cb || this.cb;
    var _scope = scope || this.scope;

    return new ObservablePoint(_cb, _scope, this._x, this._y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param {number} [x=0] - position of the point on the x axis
 * @param {number} [y=0] - position of the point on the y axis
 */
ObservablePoint.prototype.set = function set (x, y)
{
    var _x = x || 0;
    var _y = y || ((y !== 0) ? _x : 0);

    if (this._x !== _x || this._y !== _y)
    {
        this._x = _x;
        this._y = _y;
        this.cb.call(this.scope);
    }
};

/**
 * Copies x and y from the given point
 *
 * @param {PIXI.IPoint} p - The point to copy from.
 * @returns {PIXI.IPoint} Returns itself.
 */
ObservablePoint.prototype.copyFrom = function copyFrom (p)
{
    if (this._x !== p.x || this._y !== p.y)
    {
        this._x = p.x;
        this._y = p.y;
        this.cb.call(this.scope);
    }

    return this;
};

/**
 * Copies x and y into the given point
 *
 * @param {PIXI.IPoint} p - The point to copy.
 * @returns {PIXI.IPoint} Given point with values updated
 */
ObservablePoint.prototype.copyTo = function copyTo (p)
{
    p.set(this._x, this._y);

    return p;
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param {PIXI.IPoint} p - The point to check
 * @returns {boolean} Whether the given point equal to this point
 */
ObservablePoint.prototype.equals = function equals (p)
{
    return (p.x === this._x) && (p.y === this._y);
};

/**
 * The position of the displayObject on the x axis relative to the local coordinates of the parent.
 *
 * @member {number}
 */
prototypeAccessors.x.get = function ()
{
    return this._x;
};

prototypeAccessors.x.set = function (value) // eslint-disable-line require-jsdoc
{
    if (this._x !== value)
    {
        this._x = value;
        this.cb.call(this.scope);
    }
};

/**
 * The position of the displayObject on the x axis relative to the local coordinates of the parent.
 *
 * @member {number}
 */
prototypeAccessors.y.get = function ()
{
    return this._y;
};

prototypeAccessors.y.set = function (value) // eslint-disable-line require-jsdoc
{
    if (this._y !== value)
    {
        this._y = value;
        this.cb.call(this.scope);
    }
};

Object.defineProperties( ObservablePoint.prototype, prototypeAccessors );

/**
 * A number, or a string containing a number.
 * @memberof PIXI
 * @typedef {(PIXI.Point|PIXI.ObservablePoint)} IPoint
 */

/**
 * Two Pi.
 *
 * @static
 * @constant {number} PI_2
 * @memberof PIXI
 */
var PI_2 = Math.PI * 2;

/**
 * Conversion factor for converting radians to degrees.
 *
 * @static
 * @constant {number} RAD_TO_DEG
 * @memberof PIXI
 */
var RAD_TO_DEG = 180 / Math.PI;

/**
 * Conversion factor for converting degrees to radians.
 *
 * @static
 * @constant {number} DEG_TO_RAD
 * @memberof PIXI
 */
var DEG_TO_RAD = Math.PI / 180;

/**
 * Constants that identify shapes, mainly to prevent `instanceof` calls.
 *
 * @static
 * @constant
 * @name SHAPES
 * @memberof PIXI
 * @type {object}
 * @property {number} POLY Polygon
 * @property {number} RECT Rectangle
 * @property {number} CIRC Circle
 * @property {number} ELIP Ellipse
 * @property {number} RREC Rounded Rectangle
 */
var SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4,
};

/**
 * The PixiJS Matrix as a class makes it a lot faster.
 *
 * Here is a representation of it:
 * ```js
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 * ```
 * @class
 * @memberof PIXI
 */
var Matrix = function Matrix(a, b, c, d, tx, ty)
{
    if ( a === void 0 ) a = 1;
    if ( b === void 0 ) b = 0;
    if ( c === void 0 ) c = 0;
    if ( d === void 0 ) d = 1;
    if ( tx === void 0 ) tx = 0;
    if ( ty === void 0 ) ty = 0;

    /**
     * @member {number}
     * @default 1
     */
    this.a = a;

    /**
     * @member {number}
     * @default 0
     */
    this.b = b;

    /**
     * @member {number}
     * @default 0
     */
    this.c = c;

    /**
     * @member {number}
     * @default 1
     */
    this.d = d;

    /**
     * @member {number}
     * @default 0
     */
    this.tx = tx;

    /**
     * @member {number}
     * @default 0
     */
    this.ty = ty;

    this.array = null;
};

var staticAccessors = { IDENTITY: { configurable: true },TEMP_MATRIX: { configurable: true } };

/**
 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
 *
 * a = array[0]
 * b = array[1]
 * c = array[3]
 * d = array[4]
 * tx = array[2]
 * ty = array[5]
 *
 * @param {number[]} array - The array that the matrix will be populated from.
 */
Matrix.prototype.fromArray = function fromArray (array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};

/**
 * sets the matrix properties
 *
 * @param {number} a - Matrix component
 * @param {number} b - Matrix component
 * @param {number} c - Matrix component
 * @param {number} d - Matrix component
 * @param {number} tx - Matrix component
 * @param {number} ty - Matrix component
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.set = function set (a, b, c, d, tx, ty)
{
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;

    return this;
};

/**
 * Creates an array from the current Matrix object.
 *
 * @param {boolean} transpose - Whether we need to transpose the matrix or not
 * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
 * @return {number[]} the newly created array which contains the matrix
 */
Matrix.prototype.toArray = function toArray (transpose, out)
{
    if (!this.array)
    {
        this.array = new Float32Array(9);
    }

    var array = out || this.array;

    if (transpose)
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

/**
 * Get a new position with the current transformation applied.
 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
 *
 * @param {PIXI.Point} pos - The origin
 * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, transformed through this matrix
 */
Matrix.prototype.apply = function apply (pos, newPos)
{
    newPos = newPos || new Point();

    var x = pos.x;
    var y = pos.y;

    newPos.x = (this.a * x) + (this.c * y) + this.tx;
    newPos.y = (this.b * x) + (this.d * y) + this.ty;

    return newPos;
};

/**
 * Get a new position with the inverse of the current transformation applied.
 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
 *
 * @param {PIXI.Point} pos - The origin
 * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
 * @return {PIXI.Point} The new point, inverse-transformed through this matrix
 */
Matrix.prototype.applyInverse = function applyInverse (pos, newPos)
{
    newPos = newPos || new Point();

    var id = 1 / ((this.a * this.d) + (this.c * -this.b));

    var x = pos.x;
    var y = pos.y;

    newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);
    newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);

    return newPos;
};

/**
 * Translates the matrix on the x and y.
 *
 * @param {number} x How much to translate x by
 * @param {number} y How much to translate y by
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.translate = function translate (x, y)
{
    this.tx += x;
    this.ty += y;

    return this;
};

/**
 * Applies a scale transformation to the matrix.
 *
 * @param {number} x The amount to scale horizontally
 * @param {number} y The amount to scale vertically
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.scale = function scale (x, y)
{
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;

    return this;
};

/**
 * Applies a rotation transformation to the matrix.
 *
 * @param {number} angle - The angle in radians.
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.rotate = function rotate (angle)
{
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);

    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;

    this.a = (a1 * cos) - (this.b * sin);
    this.b = (a1 * sin) + (this.b * cos);
    this.c = (c1 * cos) - (this.d * sin);
    this.d = (c1 * sin) + (this.d * cos);
    this.tx = (tx1 * cos) - (this.ty * sin);
    this.ty = (tx1 * sin) + (this.ty * cos);

    return this;
};

/**
 * Appends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix - The matrix to append.
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.append = function append (matrix)
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;

    this.a = (matrix.a * a1) + (matrix.b * c1);
    this.b = (matrix.a * b1) + (matrix.b * d1);
    this.c = (matrix.c * a1) + (matrix.d * c1);
    this.d = (matrix.c * b1) + (matrix.d * d1);

    this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
    this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;

    return this;
};

/**
 * Sets the matrix based on all the available properties
 *
 * @param {number} x - Position on the x axis
 * @param {number} y - Position on the y axis
 * @param {number} pivotX - Pivot on the x axis
 * @param {number} pivotY - Pivot on the y axis
 * @param {number} scaleX - Scale on the x axis
 * @param {number} scaleY - Scale on the y axis
 * @param {number} rotation - Rotation in radians
 * @param {number} skewX - Skew on the x axis
 * @param {number} skewY - Skew on the y axis
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.setTransform = function setTransform (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)
{
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;

    this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
    this.ty = y - ((pivotX * this.b) + (pivotY * this.d));

    return this;
};

/**
 * Prepends the given Matrix to this Matrix.
 *
 * @param {PIXI.Matrix} matrix - The matrix to prepend
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.prepend = function prepend (matrix)
{
    var tx1 = this.tx;

    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
    {
        var a1 = this.a;
        var c1 = this.c;

        this.a = (a1 * matrix.a) + (this.b * matrix.c);
        this.b = (a1 * matrix.b) + (this.b * matrix.d);
        this.c = (c1 * matrix.a) + (this.d * matrix.c);
        this.d = (c1 * matrix.b) + (this.d * matrix.d);
    }

    this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
    this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;

    return this;
};

/**
 * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
 *
 * @param {PIXI.Transform} transform - The transform to apply the properties to.
 * @return {PIXI.Transform} The transform with the newly applied properties
 */
Matrix.prototype.decompose = function decompose (transform)
{
    // sort out rotation / skew..
    var a = this.a;
    var b = this.b;
    var c = this.c;
    var d = this.d;

    var skewX = -Math.atan2(-c, d);
    var skewY = Math.atan2(b, a);

    var delta = Math.abs(skewX + skewY);

    if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)
    {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
    }
    else
    {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
    }

    // next set scale
    transform.scale.x = Math.sqrt((a * a) + (b * b));
    transform.scale.y = Math.sqrt((c * c) + (d * d));

    // next set position
    transform.position.x = this.tx;
    transform.position.y = this.ty;

    return transform;
};

/**
 * Inverts this matrix
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.invert = function invert ()
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = (a1 * d1) - (b1 * c1);

    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;
    this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;

    return this;
};

/**
 * Resets this Matrix to an identity (default) matrix.
 *
 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.identity = function identity ()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;

    return this;
};

/**
 * Creates a new Matrix object with the same values as this one.
 *
 * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
 */
Matrix.prototype.clone = function clone ()
{
    var matrix = new Matrix();

    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the given matrix to be the same as the ones in this matrix
 *
 * @param {PIXI.Matrix} matrix - The matrix to copy to.
 * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
 */
Matrix.prototype.copyTo = function copyTo (matrix)
{
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the matrix to be the same as the ones in given matrix
 *
 * @param {PIXI.Matrix} matrix - The matrix to copy from.
 * @return {PIXI.Matrix} this
 */
Matrix.prototype.copyFrom = function copyFrom (matrix)
{
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;

    return this;
};

/**
 * A default (identity) matrix
 *
 * @static
 * @const
 * @member {PIXI.Matrix}
 */
staticAccessors.IDENTITY.get = function ()
{
    return new Matrix();
};

/**
 * A temp matrix
 *
 * @static
 * @const
 * @member {PIXI.Matrix}
 */
staticAccessors.TEMP_MATRIX.get = function ()
{
    return new Matrix();
};

Object.defineProperties( Matrix, staticAccessors );

// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group

/*
 * Transform matrix for operation n is:
 * | ux | vx |
 * | uy | vy |
 */

var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];

/**
 * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}
 * for the composition of each rotation in the dihederal group D8.
 *
 * @type number[][]
 * @private
 */
var rotationCayley = [];

/**
 * Matrices for each `GD8Symmetry` rotation.
 *
 * @type Matrix[]
 * @private
 */
var rotationMatrices = [];

/*
 * Alias for {@code Math.sign}.
 */
var signum = Math.sign;

/*
 * Initializes `rotationCayley` and `rotationMatrices`. It is called
 * only once below.
 */
function init()
{
    for (var i = 0; i < 16; i++)
    {
        var row = [];

        rotationCayley.push(row);

        for (var j = 0; j < 16; j++)
        {
            /* Multiplies rotation matrices i and j. */
            var _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));
            var _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));
            var _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));
            var _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));

            /* Finds rotation matrix matching the product and pushes it. */
            for (var k = 0; k < 16; k++)
            {
                if (ux[k] === _ux && uy[k] === _uy
                      && vx[k] === _vx && vy[k] === _vy)
                {
                    row.push(k);
                    break;
                }
            }
        }
    }

    for (var i$1 = 0; i$1 < 16; i$1++)
    {
        var mat = new Matrix();

        mat.set(ux[i$1], uy[i$1], vx[i$1], vy[i$1], 0, 0);
        rotationMatrices.push(mat);
    }
}

init();

/**
 * @memberof PIXI
 * @typedef {number} GD8Symmetry
 * @see PIXI.GroupD8
 */

/**
 * Implements the dihedral group D8, which is similar to
 * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};
 * D8 is the same but with diagonals, and it is used for texture
 * rotations.
 *
 * The directions the U- and V- axes after rotation
 * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`
 * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.
 *
 * **Origin:**<br>
 *  This is the small part of gameofbombs.com portal system. It works.
 *
 * @see PIXI.GroupD8.E
 * @see PIXI.GroupD8.SE
 * @see PIXI.GroupD8.S
 * @see PIXI.GroupD8.SW
 * @see PIXI.GroupD8.W
 * @see PIXI.GroupD8.NW
 * @see PIXI.GroupD8.N
 * @see PIXI.GroupD8.NE
 * @author Ivan @ivanpopelyshev
 * @class
 * @memberof PIXI
 */
var GroupD8 = {
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0°       | East      |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    E: 0,

    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45°↻     | Southeast |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    SE: 1,

    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90°↻     | South     |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    S: 2,

    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135°↻    | Southwest |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    SW: 3,

    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180°     | West      |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    W: 4,

    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135°/225°↻ | Northwest    |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    NW: 5,

    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90°/270°↻  | North        |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    N: 6,

    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45°/315°↻  | Northeast    |
     *
     * @constant {PIXI.GD8Symmetry}
     */
    NE: 7,

    /**
     * Reflection about Y-axis.
     *
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_VERTICAL: 8,

    /**
     * Reflection about the main diagonal.
     *
     * @constant {PIXI.GD8Symmetry}
     */
    MAIN_DIAGONAL: 10,

    /**
     * Reflection about X-axis.
     *
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_HORIZONTAL: 12,

    /**
     * Reflection about reverse diagonal.
     *
     * @constant {PIXI.GD8Symmetry}
     */
    REVERSE_DIAGONAL: 14,

    /**
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */
    uX: function (ind) { return ux[ind]; },

    /**
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */
    uY: function (ind) { return uy[ind]; },

    /**
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */
    vX: function (ind) { return vx[ind]; },

    /**
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */
    vY: function (ind) { return vy[ind]; },

    /**
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
     */
    inv: function (rotation) {
        if (rotation & 8)// true only if between 8 & 15 (reflections)
        {
            return rotation & 15;// or rotation % 16
        }

        return (-rotation) & 7;// or (8 - rotation) % 8
    },

    /**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @return {PIXI.GD8Symmetry} Composed operation
     */
    add: function (rotationSecond, rotationFirst) { return (
        rotationCayley[rotationSecond][rotationFirst]
    ); },

    /**
     * Reverse of `add`.
     *
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation
     * @return {PIXI.GD8Symmetry} Result
     */
    sub: function (rotationSecond, rotationFirst) { return (
        rotationCayley[rotationSecond][GroupD8.inv(rotationFirst)]
    ); },

    /**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     *
     * @memberof PIXI.GroupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */
    rotate180: function (rotation) { return rotation ^ 4; },

    /**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     *
     * @memberof PIXI.GroupD8
     * @param {PIXI.GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */
    isVertical: function (rotation) { return (rotation & 3) === 2; }, // rotation % 4 === 2

    /**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `GroupD8`.
     *
     * @memberof PIXI.GroupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @return {PIXI.GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */
    byDirection: function (dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy))
        {
            if (dy >= 0)
            {
                return GroupD8.S;
            }

            return GroupD8.N;
        }
        else if (Math.abs(dy) * 2 <= Math.abs(dx))
        {
            if (dx > 0)
            {
                return GroupD8.E;
            }

            return GroupD8.W;
        }
        else if (dy > 0)
        {
            if (dx > 0)
            {
                return GroupD8.SE;
            }

            return GroupD8.SW;
        }
        else if (dx > 0)
        {
            return GroupD8.NE;
        }

        return GroupD8.NW;
    },

    /**
     * Helps sprite to compensate texture packer rotation.
     *
     * @memberof PIXI.GroupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: function (matrix, rotation, tx, ty) {
        if ( tx === void 0 ) tx = 0;
        if ( ty === void 0 ) ty = 0;

        // Packer used "rotation", we use "inv(rotation)"
        var mat = rotationMatrices[GroupD8.inv(rotation)];

        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    },
};

/**
 * Transform that takes care about its versions
 *
 * @class
 * @memberof PIXI
 */
var Transform = function Transform()
{
    /**
     * The world transformation matrix.
     *
     * @member {PIXI.Matrix}
     */
    this.worldTransform = new Matrix();

    /**
     * The local transformation matrix.
     *
     * @member {PIXI.Matrix}
     */
    this.localTransform = new Matrix();

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @member {PIXI.ObservablePoint}
     */
    this.position = new ObservablePoint(this.onChange, this, 0, 0);

    /**
     * The scale factor of the object.
     *
     * @member {PIXI.ObservablePoint}
     */
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);

    /**
     * The pivot point of the displayObject that it rotates around.
     *
     * @member {PIXI.ObservablePoint}
     */
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);

    /**
     * The skew amount, on the x and y axis.
     *
     * @member {PIXI.ObservablePoint}
     */
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);

    /**
     * The rotation amount.
     *
     * @protected
     * @member {number}
     */
    this._rotation = 0;

    /**
     * The X-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     *
     * @protected
     * @member {number}
     */
    this._cx = 1;

    /**
     * The Y-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     *
     * @protected
     * @member {number}
     */
    this._sx = 0;

    /**
     * The X-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     *
     * @protected
     * @member {number}
     */
    this._cy = 0;

    /**
     * The Y-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     *
     * @protected
     * @member {number}
     */
    this._sy = 1;

    /**
     * The locally unique ID of the local transform.
     *
     * @protected
     * @member {number}
     */
    this._localID = 0;

    /**
     * The locally unique ID of the local transform
     * used to calculate the current local transformation matrix.
     *
     * @protected
     * @member {number}
     */
    this._currentLocalID = 0;

    /**
     * The locally unique ID of the world transform.
     *
     * @protected
     * @member {number}
     */
    this._worldID = 0;

    /**
     * The locally unique ID of the parent's world transform
     * used to calculate the current world transformation matrix.
     *
     * @protected
     * @member {number}
     */
    this._parentID = 0;
};

var prototypeAccessors$1 = { rotation: { configurable: true } };

/**
 * Called when a value changes.
 *
 * @protected
 */
Transform.prototype.onChange = function onChange ()
{
    this._localID++;
};

/**
 * Called when the skew or the rotation changes.
 *
 * @protected
 */
Transform.prototype.updateSkew = function updateSkew ()
{
    this._cx = Math.cos(this._rotation + this.skew._y);
    this._sx = Math.sin(this._rotation + this.skew._y);
    this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
    this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2

    this._localID++;
};

/**
 * Updates the local transformation matrix.
 */
Transform.prototype.updateLocalTransform = function updateLocalTransform ()
{
    var lt = this.localTransform;

    if (this._localID !== this._currentLocalID)
    {
        // get the matrix values of the displayobject based on its transform properties..
        lt.a = this._cx * this.scale._x;
        lt.b = this._sx * this.scale._x;
        lt.c = this._cy * this.scale._y;
        lt.d = this._sy * this.scale._y;

        lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
        lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
        this._currentLocalID = this._localID;

        // force an update..
        this._parentID = -1;
    }
};

/**
 * Updates the local and the world transformation matrices.
 *
 * @param {PIXI.Transform} parentTransform - The parent transform
 */
Transform.prototype.updateTransform = function updateTransform (parentTransform)
{
    var lt = this.localTransform;

    if (this._localID !== this._currentLocalID)
    {
        // get the matrix values of the displayobject based on its transform properties..
        lt.a = this._cx * this.scale._x;
        lt.b = this._sx * this.scale._x;
        lt.c = this._cy * this.scale._y;
        lt.d = this._sy * this.scale._y;

        lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
        lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
        this._currentLocalID = this._localID;

        // force an update..
        this._parentID = -1;
    }

    if (this._parentID !== parentTransform._worldID)
    {
        // concat the parent matrix with the objects transform.
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;

        wt.a = (lt.a * pt.a) + (lt.b * pt.c);
        wt.b = (lt.a * pt.b) + (lt.b * pt.d);
        wt.c = (lt.c * pt.a) + (lt.d * pt.c);
        wt.d = (lt.c * pt.b) + (lt.d * pt.d);
        wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;
        wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;

        this._parentID = parentTransform._worldID;

        // update the id of the transform..
        this._worldID++;
    }
};

/**
 * Decomposes a matrix and sets the transforms properties based on it.
 *
 * @param {PIXI.Matrix} matrix - The matrix to decompose
 */
Transform.prototype.setFromMatrix = function setFromMatrix (matrix)
{
    matrix.decompose(this);
    this._localID++;
};

/**
 * The rotation of the object in radians.
 *
 * @member {number}
 */
prototypeAccessors$1.rotation.get = function ()
{
    return this._rotation;
};

prototypeAccessors$1.rotation.set = function (value) // eslint-disable-line require-jsdoc
{
    if (this._rotation !== value)
    {
        this._rotation = value;
        this.updateSkew();
    }
};

Object.defineProperties( Transform.prototype, prototypeAccessors$1 );

/**
 * A default (identity) transform
 *
 * @static
 * @constant
 * @member {PIXI.Transform}
 */
Transform.IDENTITY = new Transform();

/**
 * Size object, contains width and height
 *
 * @memberof PIXI
 * @typedef {object} ISize
 * @property {number} width - Width component
 * @property {number} height - Height component
 */

/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */
var Rectangle = function Rectangle(x, y, width, height)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( width === void 0 ) width = 0;
    if ( height === void 0 ) height = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.x = Number(x);

    /**
     * @member {number}
     * @default 0
     */
    this.y = Number(y);

    /**
     * @member {number}
     * @default 0
     */
    this.width = Number(width);

    /**
     * @member {number}
     * @default 0
     */
    this.height = Number(height);

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.RECT
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.RECT;
};

var prototypeAccessors$2 = { left: { configurable: true },right: { configurable: true },top: { configurable: true },bottom: { configurable: true } };
var staticAccessors$1 = { EMPTY: { configurable: true } };

/**
 * returns the left edge of the rectangle
 *
 * @member {number}
 */
prototypeAccessors$2.left.get = function ()
{
    return this.x;
};

/**
 * returns the right edge of the rectangle
 *
 * @member {number}
 */
prototypeAccessors$2.right.get = function ()
{
    return this.x + this.width;
};

/**
 * returns the top edge of the rectangle
 *
 * @member {number}
 */
prototypeAccessors$2.top.get = function ()
{
    return this.y;
};

/**
 * returns the bottom edge of the rectangle
 *
 * @member {number}
 */
prototypeAccessors$2.bottom.get = function ()
{
    return this.y + this.height;
};

/**
 * A constant empty rectangle.
 *
 * @static
 * @constant
 * @member {PIXI.Rectangle}
 */
staticAccessors$1.EMPTY.get = function ()
{
    return new Rectangle(0, 0, 0, 0);
};

/**
 * Creates a clone of this Rectangle
 *
 * @return {PIXI.Rectangle} a copy of the rectangle
 */
Rectangle.prototype.clone = function clone ()
{
    return new Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Copies another rectangle to this one.
 *
 * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
 * @return {PIXI.Rectangle} Returns itself.
 */
Rectangle.prototype.copyFrom = function copyFrom (rectangle)
{
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;

    return this;
};

/**
 * Copies this rectangle to another one.
 *
 * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
 * @return {PIXI.Rectangle} Returns given parameter.
 */
Rectangle.prototype.copyTo = function copyTo (rectangle)
{
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;

    return rectangle;
};

/**
 * Checks whether the x and y coordinates given are contained within this Rectangle
 *
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rectangle
 */
Rectangle.prototype.contains = function contains (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x < this.x + this.width)
    {
        if (y >= this.y && y < this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

/**
 * Pads the rectangle making it grow in all directions.
 *
 * @param {number} paddingX - The horizontal padding amount.
 * @param {number} paddingY - The vertical padding amount.
 */
Rectangle.prototype.pad = function pad (paddingX, paddingY)
{
    paddingX = paddingX || 0;
    paddingY = paddingY || ((paddingY !== 0) ? paddingX : 0);

    this.x -= paddingX;
    this.y -= paddingY;

    this.width += paddingX * 2;
    this.height += paddingY * 2;
};

/**
 * Fits this rectangle around the passed one.
 *
 * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
 */
Rectangle.prototype.fit = function fit (rectangle)
{
    var x1 = Math.max(this.x, rectangle.x);
    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.max(this.y, rectangle.y);
    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);

    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
};

/**
 * Enlarges rectangle that way its corners lie on grid
 *
 * @param {number} [resolution=1] resolution
 * @param {number} [eps=0.001] precision
 */
Rectangle.prototype.ceil = function ceil (resolution, eps)
{
        if ( resolution === void 0 ) resolution = 1;
        if ( eps === void 0 ) eps = 0.001;

    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;

    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;

    this.width = x2 - this.x;
    this.height = y2 - this.y;
};

/**
 * Enlarges this rectangle to include the passed rectangle.
 *
 * @param {PIXI.Rectangle} rectangle - The rectangle to include.
 */
Rectangle.prototype.enlarge = function enlarge (rectangle)
{
    var x1 = Math.min(this.x, rectangle.x);
    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.min(this.y, rectangle.y);
    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
};

Object.defineProperties( Rectangle.prototype, prototypeAccessors$2 );
Object.defineProperties( Rectangle, staticAccessors$1 );

/**
 * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.
 *
 * @class
 * @memberof PIXI
 */
var Circle = function Circle(x, y, radius)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( radius === void 0 ) radius = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.CIRC
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.CIRC;
};

/**
 * Creates a clone of this Circle instance
 *
 * @return {PIXI.Circle} a copy of the Circle
 */
Circle.prototype.clone = function clone ()
{
    return new Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this circle
 *
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Circle
 */
Circle.prototype.contains = function contains (x, y)
{
    if (this.radius <= 0)
    {
        return false;
    }

    var r2 = this.radius * this.radius;
    var dx = (this.x - x);
    var dy = (this.y - y);

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a Rectangle object
*
* @return {PIXI.Rectangle} the framing rectangle
*/
Circle.prototype.getBounds = function getBounds ()
{
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
};

/**
 * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for displayObjects.
 *
 * @class
 * @memberof PIXI
 */
var Ellipse = function Ellipse(x, y, halfWidth, halfHeight)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( halfWidth === void 0 ) halfWidth = 0;
    if ( halfHeight === void 0 ) halfHeight = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = halfWidth;

    /**
     * @member {number}
     * @default 0
     */
    this.height = halfHeight;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.ELIP
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.ELIP;
};

/**
 * Creates a clone of this Ellipse instance
 *
 * @return {PIXI.Ellipse} a copy of the ellipse
 */
Ellipse.prototype.clone = function clone ()
{
    return new Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this ellipse
 *
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coords are within this ellipse
 */
Ellipse.prototype.contains = function contains (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    // normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width);
    var normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
 * Returns the framing rectangle of the ellipse as a Rectangle object
 *
 * @return {PIXI.Rectangle} the framing rectangle
 */
Ellipse.prototype.getBounds = function getBounds ()
{
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

/**
 * A class to define a shape via user defined co-orinates.
 *
 * @class
 * @memberof PIXI
 */
var Polygon = function Polygon()
{
    var points = [], len = arguments.length;
    while ( len-- ) points[ len ] = arguments[ len ];

    if (Array.isArray(points[0]))
    {
        points = points[0];
    }

    // if this is an array of points, convert it to a flat array of numbers
    if (points[0] instanceof Point)
    {
        var p = [];

        for (var i = 0, il = points.length; i < il; i++)
        {
            p.push(points[i].x, points[i].y);
        }

        points = p;
    }

    /**
     * An array of the points of this polygon
     *
     * @member {number[]}
     */
    this.points = points;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.POLY
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.POLY;

    /**
     * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
     * @member {boolean}
     * @default true
     */
    this.closeStroke = true;
};

/**
 * Creates a clone of this polygon
 *
 * @return {PIXI.Polygon} a copy of the polygon
 */
Polygon.prototype.clone = function clone ()
{
    var polygon = new Polygon(this.points.slice());

    polygon.closeStroke = this.closeStroke;

    return polygon;
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this polygon
 */
Polygon.prototype.contains = function contains (x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    var length = this.points.length / 2;

    for (var i = 0, j = length - 1; i < length; j = i++)
    {
        var xi = this.points[i * 2];
        var yi = this.points[(i * 2) + 1];
        var xj = this.points[j * 2];
        var yj = this.points[(j * 2) + 1];
        var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);

        if (intersect)
        {
            inside = !inside;
        }
    }

    return inside;
};

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
 * top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 */
var RoundedRectangle = function RoundedRectangle(x, y, width, height, radius)
{
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( width === void 0 ) width = 0;
    if ( height === void 0 ) height = 0;
    if ( radius === void 0 ) radius = 20;

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height;

    /**
     * @member {number}
     * @default 20
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readonly
     * @default PIXI.SHAPES.RREC
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.RREC;
};

/**
 * Creates a clone of this Rounded Rectangle
 *
 * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
 */
RoundedRectangle.prototype.clone = function clone ()
{
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
 *
 * @param {number} x - The X coordinate of the point to test
 * @param {number} y - The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
 */
RoundedRectangle.prototype.contains = function contains (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }
    if (x >= this.x && x <= this.x + this.width)
    {
        if (y >= this.y && y <= this.y + this.height)
        {
            if ((y >= this.y + this.radius && y <= this.y + this.height - this.radius)
            || (x >= this.x + this.radius && x <= this.x + this.width - this.radius))
            {
                return true;
            }
            var dx = x - (this.x + this.radius);
            var dy = y - (this.y + this.radius);
            var radius2 = this.radius * this.radius;

            if ((dx * dx) + (dy * dy) <= radius2)
            {
                return true;
            }
            dx = x - (this.x + this.width - this.radius);
            if ((dx * dx) + (dy * dy) <= radius2)
            {
                return true;
            }
            dy = y - (this.y + this.height - this.radius);
            if ((dx * dx) + (dy * dy) <= radius2)
            {
                return true;
            }
            dx = x - (this.x + this.radius);
            if ((dx * dx) + (dy * dy) <= radius2)
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Math classes and utilities mixed into PIXI namespace.
 *
 * @lends PIXI
 */


//# sourceMappingURL=math.es.js.map


/***/ }),

/***/ "./node_modules/parse-uri/index.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-uri/index.js ***!
  \*****************************************/
/***/ ((module) => {



module.exports = function parseURI (str, opts) {
  opts = opts || {}

  var o = {
    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
    q: {
      name: 'queryKey',
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }

  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
  var uri = {}
  var i = 14

  while (i--) uri[o.key[i]] = m[i] || ''

  uri[o.q.name] = {}
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2
  })

  return uri
}


/***/ }),

/***/ "./node_modules/pixi.js/lib/pixi.es.js":
/*!*********************************************!*\
  !*** ./node_modules/pixi.js/lib/pixi.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractBatchRenderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.AbstractBatchRenderer),
/* harmony export */   "AbstractRenderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.AbstractRenderer),
/* harmony export */   "AnimatedSprite": () => (/* reexport safe */ _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_31__.AnimatedSprite),
/* harmony export */   "AppLoaderPlugin": () => (/* reexport safe */ _pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.AppLoaderPlugin),
/* harmony export */   "Application": () => (/* reexport safe */ _pixi_app__WEBPACK_IMPORTED_MODULE_6__.Application),
/* harmony export */   "Attribute": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Attribute),
/* harmony export */   "BLEND_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.BLEND_MODES),
/* harmony export */   "BaseRenderTexture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BaseRenderTexture),
/* harmony export */   "BaseTexture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BaseTexture),
/* harmony export */   "BatchDrawCall": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchDrawCall),
/* harmony export */   "BatchGeometry": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchGeometry),
/* harmony export */   "BatchPluginFactory": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchPluginFactory),
/* harmony export */   "BatchRenderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchRenderer),
/* harmony export */   "BatchShaderGenerator": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchShaderGenerator),
/* harmony export */   "BitmapFontLoader": () => (/* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_12__.BitmapFontLoader),
/* harmony export */   "BitmapText": () => (/* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_12__.BitmapText),
/* harmony export */   "Bounds": () => (/* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_24__.Bounds),
/* harmony export */   "Buffer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Buffer),
/* harmony export */   "Circle": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Circle),
/* harmony export */   "Container": () => (/* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_24__.Container),
/* harmony export */   "CubeTexture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.CubeTexture),
/* harmony export */   "DEG_TO_RAD": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.DEG_TO_RAD),
/* harmony export */   "DRAW_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.DRAW_MODES),
/* harmony export */   "DisplayObject": () => (/* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_24__.DisplayObject),
/* harmony export */   "ENV": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.ENV),
/* harmony export */   "Ellipse": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Ellipse),
/* harmony export */   "FORMATS": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.FORMATS),
/* harmony export */   "FillStyle": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.FillStyle),
/* harmony export */   "Filter": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Filter),
/* harmony export */   "Framebuffer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Framebuffer),
/* harmony export */   "GC_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.GC_MODES),
/* harmony export */   "GLProgram": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.GLProgram),
/* harmony export */   "GLTexture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.GLTexture),
/* harmony export */   "GRAPHICS_CURVES": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.GRAPHICS_CURVES),
/* harmony export */   "Geometry": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Geometry),
/* harmony export */   "Graphics": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.Graphics),
/* harmony export */   "GraphicsData": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.GraphicsData),
/* harmony export */   "GraphicsGeometry": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.GraphicsGeometry),
/* harmony export */   "GroupD8": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.GroupD8),
/* harmony export */   "LineStyle": () => (/* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__.LineStyle),
/* harmony export */   "Loader": () => (/* reexport safe */ _pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.Loader),
/* harmony export */   "LoaderResource": () => (/* reexport safe */ _pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.LoaderResource),
/* harmony export */   "MIPMAP_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.MIPMAP_MODES),
/* harmony export */   "Matrix": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Matrix),
/* harmony export */   "Mesh": () => (/* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_27__.Mesh),
/* harmony export */   "MeshBatchUvs": () => (/* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_27__.MeshBatchUvs),
/* harmony export */   "MeshGeometry": () => (/* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_27__.MeshGeometry),
/* harmony export */   "MeshMaterial": () => (/* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_27__.MeshMaterial),
/* harmony export */   "NineSlicePlane": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.NineSlicePlane),
/* harmony export */   "ObjectRenderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.ObjectRenderer),
/* harmony export */   "ObservablePoint": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.ObservablePoint),
/* harmony export */   "PI_2": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.PI_2),
/* harmony export */   "PRECISION": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.PRECISION),
/* harmony export */   "ParticleContainer": () => (/* reexport safe */ _pixi_particles__WEBPACK_IMPORTED_MODULE_9__.ParticleContainer),
/* harmony export */   "ParticleRenderer": () => (/* reexport safe */ _pixi_particles__WEBPACK_IMPORTED_MODULE_9__.ParticleRenderer),
/* harmony export */   "PlaneGeometry": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.PlaneGeometry),
/* harmony export */   "Point": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Point),
/* harmony export */   "Polygon": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Polygon),
/* harmony export */   "Program": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Program),
/* harmony export */   "Quad": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Quad),
/* harmony export */   "QuadUv": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.QuadUv),
/* harmony export */   "RAD_TO_DEG": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.RAD_TO_DEG),
/* harmony export */   "RENDERER_TYPE": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.RENDERER_TYPE),
/* harmony export */   "Rectangle": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Rectangle),
/* harmony export */   "RenderTexture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.RenderTexture),
/* harmony export */   "RenderTexturePool": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.RenderTexturePool),
/* harmony export */   "Renderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer),
/* harmony export */   "RopeGeometry": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.RopeGeometry),
/* harmony export */   "RoundedRectangle": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.RoundedRectangle),
/* harmony export */   "Runner": () => (/* reexport safe */ _pixi_runner__WEBPACK_IMPORTED_MODULE_29__.Runner),
/* harmony export */   "SCALE_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.SCALE_MODES),
/* harmony export */   "SHAPES": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.SHAPES),
/* harmony export */   "Shader": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Shader),
/* harmony export */   "SimpleMesh": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.SimpleMesh),
/* harmony export */   "SimplePlane": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.SimplePlane),
/* harmony export */   "SimpleRope": () => (/* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__.SimpleRope),
/* harmony export */   "Sprite": () => (/* reexport safe */ _pixi_sprite__WEBPACK_IMPORTED_MODULE_30__.Sprite),
/* harmony export */   "SpriteMaskFilter": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.SpriteMaskFilter),
/* harmony export */   "Spritesheet": () => (/* reexport safe */ _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_10__.Spritesheet),
/* harmony export */   "SpritesheetLoader": () => (/* reexport safe */ _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_10__.SpritesheetLoader),
/* harmony export */   "State": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.State),
/* harmony export */   "System": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.System),
/* harmony export */   "TARGETS": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.TARGETS),
/* harmony export */   "TEXT_GRADIENT": () => (/* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_32__.TEXT_GRADIENT),
/* harmony export */   "TYPES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.TYPES),
/* harmony export */   "Text": () => (/* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_32__.Text),
/* harmony export */   "TextMetrics": () => (/* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_32__.TextMetrics),
/* harmony export */   "TextStyle": () => (/* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_32__.TextStyle),
/* harmony export */   "Texture": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.Texture),
/* harmony export */   "TextureLoader": () => (/* reexport safe */ _pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.TextureLoader),
/* harmony export */   "TextureMatrix": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.TextureMatrix),
/* harmony export */   "TextureUvs": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.TextureUvs),
/* harmony export */   "Ticker": () => (/* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_13__.Ticker),
/* harmony export */   "TickerPlugin": () => (/* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_13__.TickerPlugin),
/* harmony export */   "TilingSprite": () => (/* reexport safe */ _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_11__.TilingSprite),
/* harmony export */   "TilingSpriteRenderer": () => (/* reexport safe */ _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_11__.TilingSpriteRenderer),
/* harmony export */   "Transform": () => (/* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_26__.Transform),
/* harmony export */   "UPDATE_PRIORITY": () => (/* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_13__.UPDATE_PRIORITY),
/* harmony export */   "UniformGroup": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.UniformGroup),
/* harmony export */   "VERSION": () => (/* binding */ VERSION),
/* harmony export */   "ViewableBuffer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.ViewableBuffer),
/* harmony export */   "WRAP_MODES": () => (/* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_23__.WRAP_MODES),
/* harmony export */   "accessibility": () => (/* reexport module object */ _pixi_accessibility__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   "autoDetectRenderer": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.autoDetectRenderer),
/* harmony export */   "checkMaxIfStatementsInShader": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.checkMaxIfStatementsInShader),
/* harmony export */   "defaultFilterVertex": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.defaultFilterVertex),
/* harmony export */   "defaultVertex": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.defaultVertex),
/* harmony export */   "extract": () => (/* reexport module object */ _pixi_extract__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   "filters": () => (/* binding */ filters),
/* harmony export */   "interaction": () => (/* reexport module object */ _pixi_interaction__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   "isMobile": () => (/* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_33__.isMobile),
/* harmony export */   "prepare": () => (/* reexport module object */ _pixi_prepare__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "resources": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.resources),
/* harmony export */   "settings": () => (/* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_33__.settings),
/* harmony export */   "systems": () => (/* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_7__.systems),
/* harmony export */   "useDeprecated": () => (/* binding */ useDeprecated),
/* harmony export */   "utils": () => (/* reexport module object */ _pixi_utils__WEBPACK_IMPORTED_MODULE_5__)
/* harmony export */ });
/* harmony import */ var _pixi_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/polyfill */ "./node_modules/@pixi/polyfill/lib/polyfill.es.js");
/* harmony import */ var _pixi_accessibility__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/accessibility */ "./node_modules/@pixi/accessibility/lib/accessibility.es.js");
/* harmony import */ var _pixi_extract__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/extract */ "./node_modules/@pixi/extract/lib/extract.es.js");
/* harmony import */ var _pixi_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/interaction */ "./node_modules/@pixi/interaction/lib/interaction.es.js");
/* harmony import */ var _pixi_prepare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/prepare */ "./node_modules/@pixi/prepare/lib/prepare.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_app__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/app */ "./node_modules/@pixi/app/lib/app.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_loaders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pixi/loaders */ "./node_modules/@pixi/loaders/lib/loaders.es.js");
/* harmony import */ var _pixi_particles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @pixi/particles */ "./node_modules/@pixi/particles/lib/particles.es.js");
/* harmony import */ var _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi/spritesheet */ "./node_modules/@pixi/spritesheet/lib/spritesheet.es.js");
/* harmony import */ var _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/sprite-tiling */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.es.js");
/* harmony import */ var _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @pixi/text-bitmap */ "./node_modules/@pixi/text-bitmap/lib/text-bitmap.es.js");
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/ticker.es.js");
/* harmony import */ var _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/@pixi/filter-alpha/lib/filter-alpha.es.js");
/* harmony import */ var _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/@pixi/filter-blur/lib/filter-blur.es.js");
/* harmony import */ var _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/@pixi/filter-color-matrix/lib/filter-color-matrix.es.js");
/* harmony import */ var _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/@pixi/filter-displacement/lib/filter-displacement.es.js");
/* harmony import */ var _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/@pixi/filter-fxaa/lib/filter-fxaa.es.js");
/* harmony import */ var _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/@pixi/filter-noise/lib/filter-noise.es.js");
/* harmony import */ var _pixi_mixin_cache_as_bitmap__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @pixi/mixin-cache-as-bitmap */ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/mixin-cache-as-bitmap.es.js");
/* harmony import */ var _pixi_mixin_get_child_by_name__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @pixi/mixin-get-child-by-name */ "./node_modules/@pixi/mixin-get-child-by-name/lib/mixin-get-child-by-name.es.js");
/* harmony import */ var _pixi_mixin_get_global_position__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @pixi/mixin-get-global-position */ "./node_modules/@pixi/mixin-get-global-position/lib/mixin-get-global-position.es.js");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/constants.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/graphics.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/mesh.es.js");
/* harmony import */ var _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @pixi/mesh-extras */ "./node_modules/@pixi/mesh-extras/lib/mesh-extras.es.js");
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/runner.es.js");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/sprite.es.js");
/* harmony import */ var _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @pixi/sprite-animated */ "./node_modules/@pixi/sprite-animated/lib/sprite-animated.es.js");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/text.es.js");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/*!
 * pixi.js - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */





















































var v5 = '5.0.0';

/**
 * Deprecations (backward compatibilities) are automatically applied for browser bundles
 * in the UMD module format. If using Webpack or Rollup, you'll need to apply these
 * deprecations manually by doing something like this:
 * @example
 * import * as PIXI from 'pixi.js';
 * PIXI.useDeprecated(); // MUST be bound to namespace
 * @memberof PIXI
 * @function useDeprecated
 */
function useDeprecated()
{
    var PIXI = this;

    Object.defineProperties(PIXI, {
        /**
         * @constant {RegExp|string} SVG_SIZE
         * @memberof PIXI
         * @see PIXI.resources.SVGResource.SVG_SIZE
         * @deprecated since 5.0.0
         */
        SVG_SIZE: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE');

                return PIXI.SVGResource.SVG_SIZE;
            },
        },

        /**
         * @class PIXI.TransformStatic
         * @deprecated since 5.0.0
         * @see PIXI.Transform
         */
        TransformStatic: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.TransformStatic class has been removed, use PIXI.Transform');

                return PIXI.Transform;
            },
        },

        /**
         * @class PIXI.TransformBase
         * @deprecated since 5.0.0
         * @see PIXI.Transform
         */
        TransformBase: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.TransformBase class has been removed, use PIXI.Transform');

                return PIXI.Transform;
            },
        },

        /**
         * Constants that specify the transform type.
         *
         * @static
         * @constant
         * @name TRANSFORM_MODE
         * @memberof PIXI
         * @enum {number}
         * @deprecated since 5.0.0
         * @property {number} STATIC
         * @property {number} DYNAMIC
         */
        TRANSFORM_MODE: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.TRANSFORM_MODE property has been removed');

                return { STATIC: 0, DYNAMIC: 1 };
            },
        },

        /**
         * @class PIXI.WebGLRenderer
         * @see PIXI.Renderer
         * @deprecated since 5.0.0
         */
        WebGLRenderer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.WebGLRenderer class has moved to PIXI.Renderer');

                return PIXI.Renderer;
            },
        },

        /**
         * @class PIXI.CanvasRenderTarget
         * @see PIXI.utils.CanvasRenderTarget
         * @deprecated since 5.0.0
         */
        CanvasRenderTarget: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget');

                return PIXI.utils.CanvasRenderTarget;
            },
        },

        /**
         * @memberof PIXI
         * @name loader
         * @type {PIXI.Loader}
         * @see PIXI.Loader.shared
         * @deprecated since 5.0.0
         */
        loader: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loader instance has moved to PIXI.Loader.shared');

                return PIXI.Loader.shared;
            },
        },

        /**
         * @class PIXI.FilterManager
         * @see PIXI.systems.FilterSystem
         * @deprecated since 5.0.0
         */
        FilterManager: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.FilterManager class has moved to PIXI.systems.FilterSystem');

                return PIXI.systems.FilterSystem;
            },
        },
    });

    /**
     * This namespace has been removed. All classes previous nested
     * under this namespace have been moved to the top-level `PIXI` object.
     * @namespace PIXI.extras
     * @deprecated since 5.0.0
     */
    PIXI.extras = {};

    Object.defineProperties(PIXI.extras, {
        /**
         * @class PIXI.extras.TilingSprite
         * @see PIXI.TilingSprite
         * @deprecated since 5.0.0
         */
        TilingSprite: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite');

                return PIXI.TilingSprite;
            },
        },
        /**
         * @class PIXI.extras.TilingSpriteRenderer
         * @see PIXI.TilingSpriteRenderer
         * @deprecated since 5.0.0
         */
        TilingSpriteRenderer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer');

                return PIXI.TilingSpriteRenderer;
            },
        },
        /**
         * @class PIXI.extras.AnimatedSprite
         * @see PIXI.AnimatedSprite
         * @deprecated since 5.0.0
         */
        AnimatedSprite: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite');

                return PIXI.AnimatedSprite;
            },
        },
        /**
         * @class PIXI.extras.BitmapText
         * @see PIXI.BitmapText
         * @deprecated since 5.0.0
         */
        BitmapText: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.extras.BitmapText class has moved to PIXI.BitmapText');

                return PIXI.BitmapText;
            },
        },
    });

    Object.defineProperties(PIXI.utils, {
        /**
         * @function PIXI.utils.getSvgSize
         * @see PIXI.resources.SVGResource.getSize
         * @deprecated since 5.0.0
         */
        getSvgSize: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize');

                return PIXI.SVGResource.getSize;
            },
        },
    });

    /**
     * All classes on this namespace have moved to the high-level `PIXI` object.
     * @namespace PIXI.mesh
     * @deprecated since 5.0.0
     */
    PIXI.mesh = {};

    Object.defineProperties(PIXI.mesh, {
        /**
         * @class PIXI.mesh.Mesh
         * @see PIXI.SimpleMesh
         * @deprecated since 5.0.0
         */
        Mesh: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh');

                return PIXI.SimpleMesh;
            },
        },
        /**
         * @class PIXI.mesh.NineSlicePlane
         * @see PIXI.NineSlicePlane
         * @deprecated since 5.0.0
         */
        NineSlicePlane: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane');

                return PIXI.NineSlicePlane;
            },
        },
        /**
         * @class PIXI.mesh.Plane
         * @see PIXI.SimplePlane
         * @deprecated since 5.0.0
         */
        Plane: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.Plane class has moved to PIXI.SimplePlane');

                return PIXI.SimplePlane;
            },
        },
        /**
         * @class PIXI.mesh.Rope
         * @see PIXI.SimpleRope
         * @deprecated since 5.0.0
         */
        Rope: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.Rope class has moved to PIXI.SimpleRope');

                return PIXI.SimpleRope;
            },
        },
        /**
         * @class PIXI.mesh.RawMesh
         * @see PIXI.Mesh
         * @deprecated since 5.0.0
         */
        RawMesh: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.RawMesh class has moved to PIXI.Mesh');

                return PIXI.Mesh;
            },
        },
        /**
         * @class PIXI.mesh.CanvasMeshRenderer
         * @see PIXI.CanvasMeshRenderer
         * @deprecated since 5.0.0
         */
        CanvasMeshRenderer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer');

                return PIXI.CanvasMeshRenderer;
            },
        },
        /**
         * @class PIXI.mesh.MeshRenderer
         * @see PIXI.MeshRenderer
         * @deprecated since 5.0.0
         */
        MeshRenderer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer');

                return PIXI.MeshRenderer;
            },
        },
    });

    /**
     * This namespace has been removed and items have been moved to
     * the top-level `PIXI` object.
     * @namespace PIXI.particles
     * @deprecated since 5.0.0
     */
    PIXI.particles = {};

    Object.defineProperties(PIXI.particles, {
        /**
         * @class PIXI.particles.ParticleContainer
         * @deprecated since 5.0.0
         * @see PIXI.ParticleContainer
         */
        ParticleContainer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer');

                return PIXI.ParticleContainer;
            },
        },
        /**
         * @class PIXI.particles.ParticleRenderer
         * @deprecated since 5.0.0
         * @see PIXI.ParticleRenderer
         */
        ParticleRenderer: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer');

                return PIXI.ParticleRenderer;
            },
        },
    });

    /**
     * This namespace has been removed and items have been moved to
     * the top-level `PIXI` object.
     * @namespace PIXI.ticker
     * @deprecated since 5.0.0
     */
    PIXI.ticker = {};

    Object.defineProperties(PIXI.ticker, {
        /**
         * @class PIXI.ticker.Ticker
         * @deprecated since 5.0.0
         * @see PIXI.Ticker
         */
        Ticker: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.ticker.Ticker class has moved to PIXI.Ticker');

                return PIXI.Ticker;
            },
        },
        /**
         * @name PIXI.ticker.shared
         * @type {PIXI.Ticker}
         * @deprecated since 5.0.0
         * @see PIXI.Ticker.shared
         */
        shared: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.ticker.shared instance has moved to PIXI.Ticker.shared');

                return PIXI.Ticker.shared;
            },
        },
    });

    /**
     * All classes on this namespace have moved to the high-level `PIXI` object.
     * @namespace PIXI.loaders
     * @deprecated since 5.0.0
     */
    PIXI.loaders = {};

    Object.defineProperties(PIXI.loaders, {
        /**
         * @class PIXI.loaders.Loader
         * @see PIXI.Loader
         * @deprecated since 5.0.0
         */
        Loader: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.Loader class has moved to PIXI.Loader');

                return PIXI.Loader;
            },
        },
        /**
         * @class PIXI.loaders.Resource
         * @see PIXI.LoaderResource
         * @deprecated since 5.0.0
         */
        Resource: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.Resource class has moved to PIXI.LoaderResource');

                return PIXI.LoaderResource;
            },
        },
        /**
         * @function PIXI.loaders.bitmapFontParser
         * @see PIXI.BitmapFontLoader.use
         * @deprecated since 5.0.0
         */
        bitmapFontParser: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use');

                return PIXI.BitmapFontLoader.use;
            },
        },
        /**
         * @function PIXI.loaders.parseBitmapFontData
         * @see PIXI.BitmapFontLoader.parse
         * @deprecated since 5.0.0
         */
        parseBitmapFontData: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.parseBitmapFontData function has moved to PIXI.BitmapFontLoader.parse');

                return PIXI.BitmapFontLoader.parse;
            },
        },
        /**
         * @function PIXI.loaders.spritesheetParser
         * @see PIXI.SpritesheetLoader.use
         * @deprecated since 5.0.0
         */
        spritesheetParser: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use');

                return PIXI.SpritesheetLoader.use;
            },
        },
        /**
         * @function PIXI.loaders.getResourcePath
         * @see PIXI.SpritesheetLoader.getResourcePath
         * @deprecated since 5.0.0
         */
        getResourcePath: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath');

                return PIXI.SpritesheetLoader.getResourcePath;
            },
        },
    });

    /**
     * @function PIXI.loaders.Loader.addPixiMiddleware
     * @see PIXI.Loader.registerPlugin
     * @deprecated since 5.0.0
     * @param {function} middleware
     */
    PIXI.Loader.addPixiMiddleware = function addPixiMiddleware(middleware)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5,
            'PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin'
        );

        return PIXI.loaders.Loader.registerPlugin({ use: middleware() });
    };

    /**
     * @class PIXI.extract.WebGLExtract
     * @deprecated since 5.0.0
     * @see PIXI.extract.Extract
     */
    Object.defineProperty(PIXI.extract, 'WebGLExtract', {
        get: function get()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.extract.WebGLExtract method has moved to PIXI.extract.Extract');

            return PIXI.extract.Extract;
        },
    });

    /**
     * @class PIXI.prepare.WebGLPrepare
     * @deprecated since 5.0.0
     * @see PIXI.prepare.Prepare
     */
    Object.defineProperty(PIXI.prepare, 'WebGLPrepare', {
        get: function get()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.prepare.WebGLPrepare class has moved to PIXI.prepare.Prepare');

            return PIXI.prepare.Prepare;
        },
    });

    /**
     * @method PIXI.Container#_renderWebGL
     * @private
     * @deprecated since 5.0.0
     * @see PIXI.Container#render
     * @param {PIXI.Renderer} renderer Instance of renderer
     */
    PIXI.Container.prototype._renderWebGL = function _renderWebGL(renderer)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Container._renderWebGL method has moved to PIXI.Container._render');

        this._render(renderer);
    };

    /**
     * @method PIXI.Container#renderWebGL
     * @deprecated since 5.0.0
     * @see PIXI.Container#render
     * @param {PIXI.Renderer} renderer Instance of renderer
     */
    PIXI.Container.prototype.renderWebGL = function renderWebGL(renderer)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Container.renderWebGL method has moved to PIXI.Container.render');

        this.render(renderer);
    };

    /**
     * @method PIXI.DisplayObject#renderWebGL
     * @deprecated since 5.0.0
     * @see PIXI.DisplayObject#render
     * @param {PIXI.Renderer} renderer Instance of renderer
     */
    PIXI.DisplayObject.prototype.renderWebGL = function renderWebGL(renderer)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render');

        this.render(renderer);
    };

    /**
     * @method PIXI.Container#renderAdvancedWebGL
     * @deprecated since 5.0.0
     * @see PIXI.Container#renderAdvanced
     * @param {PIXI.Renderer} renderer Instance of renderer
     */
    PIXI.Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced');

        this.renderAdvanced(renderer);
    };

    Object.defineProperties(PIXI.settings, {
        /**
         * Default transform type.
         *
         * @static
         * @deprecated since 5.0.0
         * @memberof PIXI.settings
         * @type {PIXI.TRANSFORM_MODE}
         * @default PIXI.TRANSFORM_MODE.STATIC
         */
        TRANSFORM_MODE: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.settings.TRANSFORM_MODE property has been removed');

                return 0;
            },
            set: function set()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.settings.TRANSFORM_MODE property has been removed');
            },
        },
    });

    var BaseTexture = PIXI.BaseTexture;

    /**
     * @method loadSource
     * @memberof PIXI.BaseTexture#
     * @deprecated since 5.0.0
     */
    BaseTexture.prototype.loadSource = function loadSource(image)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.loadSource method has been deprecated');

        var resource = PIXI.resources.autoDetectResource(image);

        resource.internal = true;

        this.setResource(resource);
        this.update();
    };

    Object.defineProperties(BaseTexture.prototype, {
        /**
         * @name PIXI.BaseTexture#hasLoaded
         * @type {boolean}
         * @deprecated since 5.0.0
         * @readonly
         * @see PIXI.BaseTexture#valid
         */
        hasLoaded: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid');

                return this.valid;
            },
        },
        /**
         * @name PIXI.BaseTexture#imageUrl
         * @type {string}
         * @deprecated since 5.0.0
         * @see PIXI.resource.ImageResource#url
         */
        imageUrl: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url');

                return this.resource && this.resource.url;
            },

            set: function set(imageUrl)
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url');

                if (this.resource)
                {
                    this.resource.url = imageUrl;
                }
            },
        },
        /**
         * @name PIXI.BaseTexture#source
         * @type {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement}
         * @deprecated since 5.0.0
         * @readonly
         * @see PIXI.resources.BaseImageResource#source
         */
        source: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source`');

                return this.resource && this.resource.source;
            },
            set: function set(source)
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source` '
                    + 'if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture.');

                if (this.resource)
                {
                    this.resource.source = source;
                }
            },
        },
    });

    /**
     * @method fromImage
     * @static
     * @memberof PIXI.BaseTexture
     * @deprecated since 5.0.0
     * @see PIXI.BaseTexture.from
     */
    BaseTexture.fromImage = function fromImage(canvas, crossorigin, scaleMode, scale)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from');

        var resourceOptions = { scale: scale, crossorigin: crossorigin };

        return BaseTexture.from(canvas, { scaleMode: scaleMode, resourceOptions: resourceOptions });
    };

    /**
     * @method fromCanvas
     * @static
     * @memberof PIXI.BaseTexture
     * @deprecated since 5.0.0
     * @see PIXI.BaseTexture.from
     */
    BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from');

        return BaseTexture.from(canvas, { scaleMode: scaleMode });
    };

    /**
     * @method fromSVG
     * @static
     * @memberof PIXI.BaseTexture
     * @deprecated since 5.0.0
     * @see PIXI.BaseTexture.from
     */
    BaseTexture.fromSVG = function fromSVG(canvas, crossorigin, scaleMode, scale)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from');

        var resourceOptions = { scale: scale, crossorigin: crossorigin };

        return BaseTexture.from(canvas, { scaleMode: scaleMode, resourceOptions: resourceOptions });
    };

    /**
     * @method PIXI.Point#copy
     * @deprecated since 5.0.0
     * @see PIXI.Point#copyFrom
     */
    PIXI.Point.prototype.copy = function copy(p)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom');

        return this.copyFrom(p);
    };

    /**
     * @method PIXI.ObservablePoint#copy
     * @deprecated since 5.0.0
     * @see PIXI.ObservablePoint#copyFrom
     */
    PIXI.ObservablePoint.prototype.copy = function copy(p)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom');

        return this.copyFrom(p);
    };

    /**
     * @method PIXI.Rectangle#copy
     * @deprecated since 5.0.0
     * @see PIXI.Rectangle#copyFrom
     */
    PIXI.Rectangle.prototype.copy = function copy(p)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom');

        return this.copyFrom(p);
    };

    /**
     * @method PIXI.Matrix#copy
     * @deprecated since 5.0.0
     * @see PIXI.Matrix#copyTo
     */
    PIXI.Matrix.prototype.copy = function copy(p)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo');

        return this.copyTo(p);
    };

    /**
     * @method PIXI.systems.StateSystem#setState
     * @deprecated since 5.1.0
     * @see PIXI.systems.StateSystem#set
     */
    PIXI.systems.StateSystem.prototype.setState = function setState(s)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)('v5.1.0', 'StateSystem.setState has been renamed to StateSystem.set');

        return this.set(s);
    };

    Object.assign(PIXI.systems.FilterSystem.prototype, {
        /**
         * @method PIXI.FilterManager#getRenderTarget
         * @deprecated since 5.0.0
         * @see PIXI.systems.FilterSystem#getFilterTexture
         */
        getRenderTarget: function getRenderTarget(clear, resolution)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5,
                'PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture'
            );

            return this.getFilterTexture(resolution);
        },

        /**
         * @method PIXI.FilterManager#returnRenderTarget
         * @deprecated since 5.0.0
         * @see PIXI.systems.FilterSystem#returnFilterTexture
         */
        returnRenderTarget: function returnRenderTarget(renderTexture)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5,
                'PIXI.FilterManager.returnRenderTarget method has been replaced with '
                + 'PIXI.systems.FilterSystem.returnFilterTexture'
            );

            this.returnFilterTexture(renderTexture);
        },

        /**
         * @method PIXI.systems.FilterSystem#calculateScreenSpaceMatrix
         * @deprecated since 5.0.0
         * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */
        calculateScreenSpaceMatrix: function calculateScreenSpaceMatrix(outputMatrix)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, '
                + 'use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead');

            var mappedMatrix = outputMatrix.identity();
            var ref = this.activeState;
            var sourceFrame = ref.sourceFrame;
            var destinationFrame = ref.destinationFrame;

            mappedMatrix.translate(sourceFrame.x / destinationFrame.width, sourceFrame.y / destinationFrame.height);
            mappedMatrix.scale(destinationFrame.width, destinationFrame.height);

            return mappedMatrix;
        },

        /**
         * @method PIXI.systems.FilterSystem#calculateNormalizedScreenSpaceMatrix
         * @deprecated since 5.0.0
         * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */
        calculateNormalizedScreenSpaceMatrix: function calculateNormalizedScreenSpaceMatrix(outputMatrix)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, '
                + 'use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead.');

            var ref = this.activeState;
            var sourceFrame = ref.sourceFrame;
            var destinationFrame = ref.destinationFrame;
            var mappedMatrix = outputMatrix.identity();

            mappedMatrix.translate(sourceFrame.x / destinationFrame.width, sourceFrame.y / destinationFrame.height);

            var translateScaleX = (destinationFrame.width / sourceFrame.width);
            var translateScaleY = (destinationFrame.height / sourceFrame.height);

            mappedMatrix.scale(translateScaleX, translateScaleY);

            return mappedMatrix;
        },
    });

    Object.defineProperties(PIXI.RenderTexture.prototype, {
        /**
         * @name PIXI.RenderTexture#sourceFrame
         * @type {PIXI.Rectangle}
         * @deprecated since 5.0.0
         * @readonly
         */
        sourceFrame: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.RenderTexture.sourceFrame property has been removed');

                return this.filterFrame;
            },
        },
        /**
         * @name PIXI.RenderTexture#size
         * @type {PIXI.Rectangle}
         * @deprecated since 5.0.0
         * @readonly
         */
        size: {
            get: function get()
            {
                (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.RenderTexture.size property has been removed');

                return this._frame;
            },
        },
    });

    /**
     * @class BlurXFilter
     * @memberof PIXI.filters
     * @deprecated since 5.0.0
     * @see PIXI.filters.BlurFilterPass
     */
    var BlurXFilter = /*@__PURE__*/(function (superclass) {
        function BlurXFilter(strength, quality, resolution, kernelSize)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass');

            superclass.call(this, true, strength, quality, resolution, kernelSize);
        }

        if ( superclass ) BlurXFilter.__proto__ = superclass;
        BlurXFilter.prototype = Object.create( superclass && superclass.prototype );
        BlurXFilter.prototype.constructor = BlurXFilter;

        return BlurXFilter;
    }(PIXI.filters.BlurFilterPass));

    /**
     * @class BlurYFilter
     * @memberof PIXI.filters
     * @deprecated since 5.0.0
     * @see PIXI.filters.BlurFilterPass
     */
    var BlurYFilter = /*@__PURE__*/(function (superclass) {
        function BlurYFilter(strength, quality, resolution, kernelSize)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass');

            superclass.call(this, false, strength, quality, resolution, kernelSize);
        }

        if ( superclass ) BlurYFilter.__proto__ = superclass;
        BlurYFilter.prototype = Object.create( superclass && superclass.prototype );
        BlurYFilter.prototype.constructor = BlurYFilter;

        return BlurYFilter;
    }(PIXI.filters.BlurFilterPass));

    Object.assign(PIXI.filters, {
        BlurXFilter: BlurXFilter,
        BlurYFilter: BlurYFilter,
    });

    var Sprite = PIXI.Sprite;
    var Texture = PIXI.Texture;
    var Graphics = PIXI.Graphics;

    // Support for pixi.js-legacy bifurcation
    // give users a friendly assist to use legacy
    if (!Graphics.prototype.generateCanvasTexture)
    {
        Graphics.prototype.generateCanvasTexture = function generateCanvasTexture()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"');
        };
    }

    /**
     * @deprecated since 5.0.0
     * @member {PIXI.Graphics} PIXI.Graphics#graphicsData
     * @see PIXI.Graphics#geometry
     * @readonly
     */
    Object.defineProperty(PIXI.Graphics.prototype, 'graphicsData', {
        get: function get()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Graphics.graphicsData property is deprecated, use PIXI.Graphics.geometry.graphicsData');

            return this.geometry.graphicsData;
        },
    });

    // Use these to deprecate all the Sprite from* methods
    function spriteFrom(name, source, crossorigin, scaleMode)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, ("PIXI.Sprite." + name + " method is deprecated, use PIXI.Sprite.from"));

        return Sprite.from(source, {
            resourceOptions: {
                scale: scaleMode,
                crossorigin: crossorigin,
            },
        });
    }

    /**
     * @deprecated since 5.0.0
     * @see PIXI.Sprite.from
     * @method PIXI.Sprite.fromImage
     * @return {PIXI.Sprite}
     */
    Sprite.fromImage = spriteFrom.bind(null, 'fromImage');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Sprite.fromSVG
     * @see PIXI.Sprite.from
     * @return {PIXI.Sprite}
     */
    Sprite.fromSVG = spriteFrom.bind(null, 'fromSVG');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Sprite.fromCanvas
     * @see PIXI.Sprite.from
     * @return {PIXI.Sprite}
     */
    Sprite.fromCanvas = spriteFrom.bind(null, 'fromCanvas');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Sprite.fromVideo
     * @see PIXI.Sprite.from
     * @return {PIXI.Sprite}
     */
    Sprite.fromVideo = spriteFrom.bind(null, 'fromVideo');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Sprite.fromFrame
     * @see PIXI.Sprite.from
     * @return {PIXI.Sprite}
     */
    Sprite.fromFrame = spriteFrom.bind(null, 'fromFrame');

    // Use these to deprecate all the Texture from* methods
    function textureFrom(name, source, crossorigin, scaleMode)
    {
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, ("PIXI.Texture." + name + " method is deprecated, use PIXI.Texture.from"));

        return Texture.from(source, {
            resourceOptions: {
                scale: scaleMode,
                crossorigin: crossorigin,
            },
        });
    }

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Texture.fromImage
     * @see PIXI.Texture.from
     * @return {PIXI.Texture}
     */
    Texture.fromImage = textureFrom.bind(null, 'fromImage');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Texture.fromSVG
     * @see PIXI.Texture.from
     * @return {PIXI.Texture}
     */
    Texture.fromSVG = textureFrom.bind(null, 'fromSVG');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Texture.fromCanvas
     * @see PIXI.Texture.from
     * @return {PIXI.Texture}
     */
    Texture.fromCanvas = textureFrom.bind(null, 'fromCanvas');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Texture.fromVideo
     * @see PIXI.Texture.from
     * @return {PIXI.Texture}
     */
    Texture.fromVideo = textureFrom.bind(null, 'fromVideo');

    /**
     * @deprecated since 5.0.0
     * @method PIXI.Texture.fromFrame
     * @see PIXI.Texture.from
     * @return {PIXI.Texture}
     */
    Texture.fromFrame = textureFrom.bind(null, 'fromFrame');

    /**
     * @deprecated since 5.0.0
     * @member {boolean} PIXI.AbstractRenderer#autoResize
     * @see PIXI.AbstractRenderer#autoDensity
     */
    Object.defineProperty(PIXI.AbstractRenderer.prototype, 'autoResize', {
        get: function get()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.AbstractRenderer.autoResize property is deprecated, '
                + 'use PIXI.AbstractRenderer.autoDensity');

            return this.autoDensity;
        },
        set: function set(value)
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.AbstractRenderer.autoResize property is deprecated, '
                + 'use PIXI.AbstractRenderer.autoDensity');

            this.autoDensity = value;
        },
    });

    /**
     * @deprecated since 5.0.0
     * @member {PIXI.systems.TextureSystem} PIXI.Renderer#textureManager
     * @see PIXI.Renderer#texture
     */
    Object.defineProperty(PIXI.Renderer.prototype, 'textureManager', {
        get: function get()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.Renderer.textureManager property is deprecated, use PIXI.Renderer.texture');

            return this.texture;
        },
    });

    /**
     * @namespace PIXI.utils.mixins
     * @deprecated since 5.0.0
     */
    PIXI.utils.mixins = {
        /**
         * @memberof PIXI.utils.mixins
         * @function mixin
         * @deprecated since 5.0.0
         */
        mixin: function mixin()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.utils.mixins.mixin function is no longer available');
        },
        /**
         * @memberof PIXI.utils.mixins
         * @function delayMixin
         * @deprecated since 5.0.0
         */
        delayMixin: function delayMixin()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.utils.mixins.delayMixin function is no longer available');
        },
        /**
         * @memberof PIXI.utils.mixins
         * @function performMixins
         * @deprecated since 5.0.0
         */
        performMixins: function performMixins()
        {
            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.deprecation)(v5, 'PIXI.utils.mixins.performMixins function is no longer available');
        },
    };
}

// Install renderer plugins
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('accessibility', _pixi_accessibility__WEBPACK_IMPORTED_MODULE_1__.AccessibilityManager);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('extract', _pixi_extract__WEBPACK_IMPORTED_MODULE_2__.Extract);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('interaction', _pixi_interaction__WEBPACK_IMPORTED_MODULE_3__.InteractionManager);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('particle', _pixi_particles__WEBPACK_IMPORTED_MODULE_9__.ParticleRenderer);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('prepare', _pixi_prepare__WEBPACK_IMPORTED_MODULE_4__.Prepare);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('batch', _pixi_core__WEBPACK_IMPORTED_MODULE_7__.BatchRenderer);
_pixi_core__WEBPACK_IMPORTED_MODULE_7__.Renderer.registerPlugin('tilingSprite', _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_11__.TilingSpriteRenderer);

_pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.Loader.registerPlugin(_pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_12__.BitmapFontLoader);
_pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.Loader.registerPlugin(_pixi_spritesheet__WEBPACK_IMPORTED_MODULE_10__.SpritesheetLoader);

_pixi_app__WEBPACK_IMPORTED_MODULE_6__.Application.registerPlugin(_pixi_ticker__WEBPACK_IMPORTED_MODULE_13__.TickerPlugin);
_pixi_app__WEBPACK_IMPORTED_MODULE_6__.Application.registerPlugin(_pixi_loaders__WEBPACK_IMPORTED_MODULE_8__.AppLoaderPlugin);

/**
 * String of the current PIXI version.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name VERSION
 * @type {string}
 */
var VERSION = '5.1.2';

/**
 * @namespace PIXI
 */

/**
 * This namespace contains WebGL-only display filters that can be applied
 * to DisplayObjects using the {@link PIXI.DisplayObject#filters filters} property.
 *
 * Since PixiJS only had a handful of built-in filters, additional filters
 * can be downloaded {@link https://github.com/pixijs/pixi-filters here} from the
 * PixiJS Filters repository.
 *
 * All filters must extend {@link PIXI.Filter}.
 *
 * @example
 * // Create a new application
 * const app = new PIXI.Application();
 *
 * // Draw a green rectangle
 * const rect = new PIXI.Graphics()
 *     .beginFill(0x00ff00)
 *     .drawRect(40, 40, 200, 200);
 *
 * // Add a blur filter
 * rect.filters = [new PIXI.filters.BlurFilter()];
 *
 * // Display rectangle
 * app.stage.addChild(rect);
 * document.body.appendChild(app.view);
 * @namespace PIXI.filters
 */
var filters = {
    AlphaFilter: _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_14__.AlphaFilter,
    BlurFilter: _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_15__.BlurFilter,
    BlurFilterPass: _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_15__.BlurFilterPass,
    ColorMatrixFilter: _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_16__.ColorMatrixFilter,
    DisplacementFilter: _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_17__.DisplacementFilter,
    FXAAFilter: _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_18__.FXAAFilter,
    NoiseFilter: _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_19__.NoiseFilter,
};


//# sourceMappingURL=pixi.es.js.map


/***/ })

}]);
//# sourceMappingURL=commons-node_modules_parse-uri_index_js-node_modules_pixi_js_lib_pixi_es_js.f53c6.js.map