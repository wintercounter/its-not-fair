"use strict";
(self["webpackChunkits_not_fair"] = self["webpackChunkits_not_fair"] || []).push([["commons-node_modules_pixi_mesh-extras_lib_mesh-extras_es_js-node_modules_pixi_mixin-cache-as--be79ac"],{

/***/ "./node_modules/@pixi/mesh-extras/lib/mesh-extras.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/mesh-extras.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NineSlicePlane": () => (/* binding */ NineSlicePlane),
/* harmony export */   "PlaneGeometry": () => (/* binding */ PlaneGeometry),
/* harmony export */   "RopeGeometry": () => (/* binding */ RopeGeometry),
/* harmony export */   "SimpleMesh": () => (/* binding */ SimpleMesh),
/* harmony export */   "SimplePlane": () => (/* binding */ SimplePlane),
/* harmony export */   "SimpleRope": () => (/* binding */ SimpleRope)
/* harmony export */ });
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/mesh.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/*!
 * @pixi/mesh-extras - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



var PlaneGeometry = /*@__PURE__*/(function (MeshGeometry) {
    function PlaneGeometry(width, height, segWidth, segHeight)
    {
        if ( width === void 0 ) width = 100;
        if ( height === void 0 ) height = 100;
        if ( segWidth === void 0 ) segWidth = 10;
        if ( segHeight === void 0 ) segHeight = 10;

        MeshGeometry.call(this);

        this.segWidth = segWidth;
        this.segHeight = segHeight;

        this.width = width;
        this.height = height;

        this.build();
    }

    if ( MeshGeometry ) PlaneGeometry.__proto__ = MeshGeometry;
    PlaneGeometry.prototype = Object.create( MeshGeometry && MeshGeometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    /**
     * Refreshes plane coordinates
     * @private
     */
    PlaneGeometry.prototype.build = function build ()
    {
        var total = this.segWidth * this.segHeight;
        var verts = [];
        var uvs = [];
        var indices = [];

        var segmentsX = this.segWidth - 1;
        var segmentsY = this.segHeight - 1;

        var sizeX = (this.width) / segmentsX;
        var sizeY = (this.height) / segmentsY;

        for (var i = 0; i < total; i++)
        {
            var x = (i % this.segWidth);
            var y = ((i / this.segWidth) | 0);

            verts.push(x * sizeX, y * sizeY);
            uvs.push(x / segmentsX, y / segmentsY);
        }

        var totalSub = segmentsX * segmentsY;

        for (var i$1 = 0; i$1 < totalSub; i$1++)
        {
            var xpos = i$1 % segmentsX;
            var ypos = (i$1 / segmentsX) | 0;

            var value = (ypos * this.segWidth) + xpos;
            var value2 = (ypos * this.segWidth) + xpos + 1;
            var value3 = ((ypos + 1) * this.segWidth) + xpos;
            var value4 = ((ypos + 1) * this.segWidth) + xpos + 1;

            indices.push(value, value2, value3,
                value2, value4, value3);
        }

        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices);

        // ensure that the changes are uploaded
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
    };

    return PlaneGeometry;
}(_pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry));

/**
 * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.
 *
 * ```js
 * for (let i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * const rope = new PIXI.RopeGeometry(100, points);
 * ```
 *
 * @class
 * @extends PIXI.MeshGeometry
 * @memberof PIXI
 *
 */
var RopeGeometry = /*@__PURE__*/(function (MeshGeometry) {
    function RopeGeometry(width, points)
    {
        if ( width === void 0 ) width = 200;

        MeshGeometry.call(this, new Float32Array(points.length * 4),
            new Float32Array(points.length * 4),
            new Uint16Array((points.length - 1) * 6));

        /**
         * An array of points that determine the rope
         * @member {PIXI.Point[]}
         */
        this.points = points;

        /**
         * The width (i.e., thickness) of the rope.
         * @member {number}
         * @readOnly
         */
        this.width = width;

        this.build();
    }

    if ( MeshGeometry ) RopeGeometry.__proto__ = MeshGeometry;
    RopeGeometry.prototype = Object.create( MeshGeometry && MeshGeometry.prototype );
    RopeGeometry.prototype.constructor = RopeGeometry;
    /**
     * Refreshes Rope indices and uvs
     * @private
     */
    RopeGeometry.prototype.build = function build ()
    {
        var points = this.points;

        if (!points) { return; }

        var vertexBuffer = this.getBuffer('aVertexPosition');
        var uvBuffer = this.getBuffer('aTextureCoord');
        var indexBuffer = this.getIndex();

        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1)
        {
            return;
        }

        // if the number of points has changed we will need to recreate the arraybuffers
        if (vertexBuffer.data.length / 4 !== points.length)
        {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }

        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;

        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;

        // indices[0] = 0;
        // indices[1] = 1;

        var total = points.length; // - 1;

        for (var i = 0; i < total; i++)
        {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);

            uvs[index] = amount;
            uvs[index + 1] = 0;

            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }

        var indexCount = 0;

        for (var i$1 = 0; i$1 < total - 1; i$1++)
        {
            var index$1 = i$1 * 2;

            indices[indexCount++] = index$1;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 2;

            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 3;
        }

        // ensure that the changes are uploaded
        uvBuffer.update();
        indexBuffer.update();

        this.updateVertices();
    };

    /**
     * refreshes vertices of Rope mesh
     */
    RopeGeometry.prototype.updateVertices = function updateVertices ()
    {
        var points = this.points;

        if (points.length < 1)
        {
            return;
        }

        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;

        // this.count -= 0.2;

        var vertices = this.buffers[0].data;
        var total = points.length;

        for (var i = 0; i < total; i++)
        {
            var point = points[i];
            var index = i * 4;

            if (i < points.length - 1)
            {
                nextPoint = points[i + 1];
            }
            else
            {
                nextPoint = point;
            }

            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;

            var perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));
            var num = this.width / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;

            perpX /= perpLength;
            perpY /= perpLength;

            perpX *= num;
            perpY *= num;

            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;

            lastPoint = point;
        }

        this.buffers[0].update();
    };

    RopeGeometry.prototype.update = function update ()
    {
        this.updateVertices();
    };

    return RopeGeometry;
}(_pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry));

/**
 * The rope allows you to draw a texture across several points and then manipulate these points
 *
 *```js
 * for (let i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * let rope = new PIXI.SimpleRope(PIXI.Texture.from("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.Mesh
 * @memberof PIXI
 *
 */
var SimpleRope = /*@__PURE__*/(function (Mesh) {
    function SimpleRope(texture, points)
    {
        var ropeGeometry = new RopeGeometry(texture.height, points);
        var meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshMaterial(texture);

        Mesh.call(this, ropeGeometry, meshMaterial);

        /**
         * re-calculate vertices by rope points each frame
         *
         * @member {boolean}
         */
        this.autoUpdate = true;
    }

    if ( Mesh ) SimpleRope.__proto__ = Mesh;
    SimpleRope.prototype = Object.create( Mesh && Mesh.prototype );
    SimpleRope.prototype.constructor = SimpleRope;

    SimpleRope.prototype._render = function _render (renderer)
    {
        if (this.autoUpdate
            || this.geometry.width !== this.shader.texture.height)
        {
            this.geometry.width = this.shader.texture.height;
            this.geometry.update();
        }

        Mesh.prototype._render.call(this, renderer);
    };

    return SimpleRope;
}(_pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh));

/**
 * The SimplePlane allows you to draw a texture across several points and then manipulate these points
 *
 *```js
 * for (let i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * let SimplePlane = new PIXI.SimplePlane(PIXI.Texture.from("snake.png"), points);
 *  ```
 *
 * @class
 * @extends PIXI.Mesh
 * @memberof PIXI
 *
 */
var SimplePlane = /*@__PURE__*/(function (Mesh) {
    function SimplePlane(texture, verticesX, verticesY)
    {
        var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        var meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshMaterial(_pixi_core__WEBPACK_IMPORTED_MODULE_1__.Texture.WHITE);

        Mesh.call(this, planeGeometry, meshMaterial);

        // lets call the setter to ensure all necessary updates are performed
        this.texture = texture;
    }

    if ( Mesh ) SimplePlane.__proto__ = Mesh;
    SimplePlane.prototype = Object.create( Mesh && Mesh.prototype );
    SimplePlane.prototype.constructor = SimplePlane;

    var prototypeAccessors = { texture: { configurable: true } };

    /**
     * Method used for overrides, to do something in case texture frame was changed.
     * Meshes based on plane can override it and change more details based on texture.
     */
    SimplePlane.prototype.textureUpdated = function textureUpdated ()
    {
        this._textureID = this.shader.texture._updateID;

        this.geometry.width = this.shader.texture.width;
        this.geometry.height = this.shader.texture.height;

        this.geometry.build();
    };

    prototypeAccessors.texture.set = function (value)
    {
        // Track texture same way sprite does.
        // For generated meshes like NineSlicePlane it can change the geometry.
        // Unfortunately, this method might not work if you directly change texture in material.

        if (this.shader.texture === value)
        {
            return;
        }

        this.shader.texture = value;
        this._textureID = -1;

        if (value.baseTexture.valid)
        {
            this.textureUpdated();
        }
        else
        {
            value.once('update', this.textureUpdated, this);
        }
    };

    prototypeAccessors.texture.get = function ()
    {
        return this.shader.texture;
    };

    SimplePlane.prototype._render = function _render (renderer)
    {
        if (this._textureID !== this.shader.texture._updateID)
        {
            this.textureUpdated();
        }

        Mesh.prototype._render.call(this, renderer);
    };

    Object.defineProperties( SimplePlane.prototype, prototypeAccessors );

    return SimplePlane;
}(_pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh));

/**
 * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.
 * For more robust customization, use {@link PIXI.Mesh}.
 *
 * @class
 * @extends PIXI.Mesh
 * @memberof PIXI
 */
var SimpleMesh = /*@__PURE__*/(function (Mesh) {
    function SimpleMesh(texture, vertices, uvs, indices, drawMode)
    {
        if ( texture === void 0 ) texture = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY;

        var geometry = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry(vertices, uvs, indices);

        geometry.getBuffer('aVertexPosition').static = false;

        var meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshMaterial(texture);

        Mesh.call(this, geometry, meshMaterial, null, drawMode);

        /**
         * upload vertices buffer each frame
         * @member {boolean}
         */
        this.autoUpdate = true;
    }

    if ( Mesh ) SimpleMesh.__proto__ = Mesh;
    SimpleMesh.prototype = Object.create( Mesh && Mesh.prototype );
    SimpleMesh.prototype.constructor = SimpleMesh;

    var prototypeAccessors = { vertices: { configurable: true } };

    /**
     * Collection of vertices data.
     * @member {Float32Array}
     */
    prototypeAccessors.vertices.get = function ()
    {
        return this.geometry.getBuffer('aVertexPosition').data;
    };
    prototypeAccessors.vertices.set = function (value)
    {
        this.geometry.getBuffer('aVertexPosition').data = value;
    };

    SimpleMesh.prototype._render = function _render (renderer)
    {
        if (this.autoUpdate)
        {
            this.geometry.getBuffer('aVertexPosition').update();
        }

        Mesh.prototype._render.call(this, renderer);
    };

    Object.defineProperties( SimpleMesh.prototype, prototypeAccessors );

    return SimpleMesh;
}(_pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh));

var DEFAULT_BORDER_SIZE = 10;

/**
 * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful
 * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically
 *
 *```js
 * let Plane9 = new PIXI.NineSlicePlane(PIXI.Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);
 *  ```
 * <pre>
 *      A                          B
 *    +---+----------------------+---+
 *  C | 1 |          2           | 3 |
 *    +---+----------------------+---+
 *    |   |                      |   |
 *    | 4 |          5           | 6 |
 *    |   |                      |   |
 *    +---+----------------------+---+
 *  D | 7 |          8           | 9 |
 *    +---+----------------------+---+

 *  When changing this objects width and/or height:
 *     areas 1 3 7 and 9 will remain unscaled.
 *     areas 2 and 8 will be stretched horizontally
 *     areas 4 and 6 will be stretched vertically
 *     area 5 will be stretched both horizontally and vertically
 * </pre>
 *
 * @class
 * @extends PIXI.SimplePlane
 * @memberof PIXI
 *
 */
var NineSlicePlane = /*@__PURE__*/(function (SimplePlane) {
    function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight)
    {
        SimplePlane.call(this, _pixi_core__WEBPACK_IMPORTED_MODULE_1__.Texture.WHITE, 4, 4);

        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;

        /**
         * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @override
         */
        this._width = this._origWidth;

        /**
         * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @override
         */
        this._height = this._origHeight;

        /**
         * The width of the left column (a)
         *
         * @member {number}
         * @private
         */
        this._leftWidth = typeof leftWidth !== 'undefined' ? leftWidth : DEFAULT_BORDER_SIZE;

        /**
         * The width of the right column (b)
         *
         * @member {number}
         * @private
         */
        this._rightWidth = typeof rightWidth !== 'undefined' ? rightWidth : DEFAULT_BORDER_SIZE;

        /**
         * The height of the top row (c)
         *
         * @member {number}
         * @private
         */
        this._topHeight = typeof topHeight !== 'undefined' ? topHeight : DEFAULT_BORDER_SIZE;

        /**
         * The height of the bottom row (d)
         *
         * @member {number}
         * @private
         */
        this._bottomHeight = typeof bottomHeight !== 'undefined' ? bottomHeight : DEFAULT_BORDER_SIZE;

        // lets call the setter to ensure all necessary updates are performed
        this.texture = texture;
    }

    if ( SimplePlane ) NineSlicePlane.__proto__ = SimplePlane;
    NineSlicePlane.prototype = Object.create( SimplePlane && SimplePlane.prototype );
    NineSlicePlane.prototype.constructor = NineSlicePlane;

    var prototypeAccessors = { vertices: { configurable: true },width: { configurable: true },height: { configurable: true },leftWidth: { configurable: true },rightWidth: { configurable: true },topHeight: { configurable: true },bottomHeight: { configurable: true } };

    NineSlicePlane.prototype.textureUpdated = function textureUpdated ()
    {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
    };

    prototypeAccessors.vertices.get = function ()
    {
        return this.geometry.getBuffer('aVertexPosition').data;
    };

    prototypeAccessors.vertices.set = function (value)
    {
        this.geometry.getBuffer('aVertexPosition').data = value;
    };

    /**
     * Updates the horizontal vertices.
     *
     */
    NineSlicePlane.prototype.updateHorizontalVertices = function updateHorizontalVertices ()
    {
        var vertices = this.vertices;

        var h = this._topHeight + this._bottomHeight;
        var scale = this._height > h ? 1.0 : this._height / h;

        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - (this._bottomHeight * scale);
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
    };

    /**
     * Updates the vertical vertices.
     *
     */
    NineSlicePlane.prototype.updateVerticalVertices = function updateVerticalVertices ()
    {
        var vertices = this.vertices;

        var w = this._leftWidth + this._rightWidth;
        var scale = this._width > w ? 1.0 : this._width / w;

        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - (this._rightWidth * scale);
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
    };

    /**
     * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
     *
     * @member {number}
     */
    prototypeAccessors.width.get = function ()
    {
        return this._width;
    };

    prototypeAccessors.width.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._width = value;
        this._refresh();
    };

    /**
     * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
     *
     * @member {number}
     */
    prototypeAccessors.height.get = function ()
    {
        return this._height;
    };

    prototypeAccessors.height.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._height = value;
        this._refresh();
    };

    /**
     * The width of the left column
     *
     * @member {number}
     */
    prototypeAccessors.leftWidth.get = function ()
    {
        return this._leftWidth;
    };

    prototypeAccessors.leftWidth.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._leftWidth = value;
        this._refresh();
    };

    /**
     * The width of the right column
     *
     * @member {number}
     */
    prototypeAccessors.rightWidth.get = function ()
    {
        return this._rightWidth;
    };

    prototypeAccessors.rightWidth.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._rightWidth = value;
        this._refresh();
    };

    /**
     * The height of the top row
     *
     * @member {number}
     */
    prototypeAccessors.topHeight.get = function ()
    {
        return this._topHeight;
    };

    prototypeAccessors.topHeight.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._topHeight = value;
        this._refresh();
    };

    /**
     * The height of the bottom row
     *
     * @member {number}
     */
    prototypeAccessors.bottomHeight.get = function ()
    {
        return this._bottomHeight;
    };

    prototypeAccessors.bottomHeight.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._bottomHeight = value;
        this._refresh();
    };

    /**
     * Refreshes NineSlicePlane coords. All of them.
     */
    NineSlicePlane.prototype._refresh = function _refresh ()
    {
        var texture = this.texture;

        var uvs = this.geometry.buffers[1].data;

        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;

        var _uvw = 1.0 / this._origWidth;
        var _uvh = 1.0 / this._origHeight;

        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;

        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);

        this.updateHorizontalVertices();
        this.updateVerticalVertices();

        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
    };

    Object.defineProperties( NineSlicePlane.prototype, prototypeAccessors );

    return NineSlicePlane;
}(SimplePlane));


//# sourceMappingURL=mesh-extras.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/mesh.es.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/mesh.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mesh": () => (/* binding */ Mesh),
/* harmony export */   "MeshBatchUvs": () => (/* binding */ MeshBatchUvs),
/* harmony export */   "MeshGeometry": () => (/* binding */ MeshGeometry),
/* harmony export */   "MeshMaterial": () => (/* binding */ MeshMaterial)
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/constants.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/*!
 * @pixi/mesh - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */







/**
 * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.
 *
 * @class
 * @memberof PIXI
 */
var MeshBatchUvs = function MeshBatchUvs(uvBuffer, uvMatrix)
{
    /**
     * Buffer with normalized UV's
     * @member {PIXI.Buffer}
     */
    this.uvBuffer = uvBuffer;

    /**
     * Material UV matrix
     * @member {PIXI.TextureMatrix}
     */
    this.uvMatrix = uvMatrix;

    /**
     * UV Buffer data
     * @member {Float32Array}
     * @readonly
     */
    this.data = null;

    this._bufferUpdateId = -1;

    this._textureUpdateId = -1;

    this._updateID = 0;
};

/**
 * updates
 *
 * @param {boolean} forceUpdate - force the update
 */
MeshBatchUvs.prototype.update = function update (forceUpdate)
{
    if (!forceUpdate
        && this._bufferUpdateId === this.uvBuffer._updateID
        && this._textureUpdateId === this.uvMatrix._updateID)
    {
        return;
    }

    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;

    var data = this.uvBuffer.data;

    if (!this.data || this.data.length !== data.length)
    {
        this.data = new Float32Array(data.length);
    }

    this.uvMatrix.multiplyUvs(data, this.data);

    this._updateID++;
};

var tempPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point();
var tempPolygon = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Polygon();

/**
 * Base mesh class.
 *
 * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.
 * This class assumes a certain level of WebGL knowledge.
 * If you know a bit this should abstract enough away to make you life easier!
 *
 * Pretty much ALL WebGL can be broken down into the following:
 * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..
 * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)
 * - State - This is the state of WebGL required to render the mesh.
 *
 * Through a combination of the above elements you can render anything you want, 2D or 3D!
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */
var Mesh = /*@__PURE__*/(function (Container) {
    function Mesh(geometry, shader, state, drawMode)// vertices, uvs, indices, drawMode)
    {
        if ( drawMode === void 0 ) drawMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.DRAW_MODES.TRIANGLES;

        Container.call(this);

        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */
        this.geometry = geometry;

        geometry.refCount++;

        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */
        this.shader = shader;

        /**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = state || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();

        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */
        this.drawMode = drawMode;

        /**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */
        this.start = 0;

        /**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */
        this.size = 0;

        /**
         * thease are used as easy access for batching
         * @member {Float32Array}
         * @private
         */
        this.uvs = null;

        /**
         * thease are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */
        this.indices = null;

        /**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */
        this.vertexData = new Float32Array(1);

        /**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */
        this.vertexDirty = 0;

        this._transformID = -1;

        // Inherited from DisplayMode, set defaults
        this.tint = 0xFFFFFF;
        this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.BLEND_MODES.NORMAL;

        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = _pixi_settings__WEBPACK_IMPORTED_MODULE_4__.settings.ROUND_PIXELS;

        /**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */
        this.batchUvs = null;
    }

    if ( Container ) Mesh.__proto__ = Container;
    Mesh.prototype = Object.create( Container && Container.prototype );
    Mesh.prototype.constructor = Mesh;

    var prototypeAccessors = { uvBuffer: { configurable: true },verticesBuffer: { configurable: true },material: { configurable: true },blendMode: { configurable: true },roundPixels: { configurable: true },tint: { configurable: true },texture: { configurable: true } };

    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    prototypeAccessors.uvBuffer.get = function ()
    {
        return this.geometry.buffers[1];
    };

    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    prototypeAccessors.verticesBuffer.get = function ()
    {
        return this.geometry.buffers[0];
    };

    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.Shader|PIXI.MeshMaterial}
     */
    prototypeAccessors.material.set = function (value)
    {
        this.shader = value;
    };

    prototypeAccessors.material.get = function ()
    {
        return this.shader;
    };

    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    prototypeAccessors.blendMode.set = function (value)
    {
        this.state.blendMode = value;
    };

    prototypeAccessors.blendMode.get = function ()
    {
        return this.state.blendMode;
    };

    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    prototypeAccessors.roundPixels.set = function (value)
    {
        if (this._roundPixels !== value)
        {
            this._transformID = -1;
        }
        this._roundPixels = value;
    };

    prototypeAccessors.roundPixels.get = function ()
    {
        return this._roundPixels;
    };

    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    prototypeAccessors.tint.get = function ()
    {
        return this.shader.tint;
    };

    prototypeAccessors.tint.set = function (value)
    {
        this.shader.tint = value;
    };

    /**
     * The texture that the Mesh uses.
     *
     * @member {PIXI.Texture}
     */
    prototypeAccessors.texture.get = function ()
    {
        return this.shader.texture;
    };

    prototypeAccessors.texture.set = function (value)
    {
        this.shader.texture = value;
    };

    /**
     * Standard renderer draw.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    Mesh.prototype._render = function _render (renderer)
    {
        // set properties for batching..
        // TODO could use a different way to grab verts?
        var vertices = this.geometry.buffers[0].data;

        // TODO benchmark check for attribute size..
        if (this.shader.batchable && this.drawMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2)
        {
            this._renderToBatch(renderer);
        }
        else
        {
            this._renderDefault(renderer);
        }
    };

    /**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    Mesh.prototype._renderDefault = function _renderDefault (renderer)
    {
        var shader = this.shader;

        shader.alpha = this.worldAlpha;
        if (shader.update)
        {
            shader.update();
        }

        renderer.batch.flush();

        if (shader.program.uniformData.translationMatrix)
        {
            shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }

        // bind and sync uniforms..
        renderer.shader.bind(shader);

        // set state..
        renderer.state.set(this.state);

        // bind the geometry...
        renderer.geometry.bind(this.geometry, shader);

        // then render it
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    };

    /**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    Mesh.prototype._renderToBatch = function _renderToBatch (renderer)
    {
        var geometry = this.geometry;

        if (this.shader.uvMatrix)
        {
            this.shader.uvMatrix.update();
            this.calculateUvs();
        }

        // set properties for batching..
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;

        var pluginName = this.material.pluginName;

        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
    };

    /**
     * Updates vertexData field based on transform and vertices
     */
    Mesh.prototype.calculateVertices = function calculateVertices ()
    {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;

        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)
        {
            return;
        }

        this._transformID = this.transform._worldID;

        if (this.vertexData.length !== vertices.length)
        {
            this.vertexData = new Float32Array(vertices.length);
        }

        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;

        var vertexData = this.vertexData;

        for (var i = 0; i < vertexData.length / 2; i++)
        {
            var x = vertices[(i * 2)];
            var y = vertices[(i * 2) + 1];

            vertexData[(i * 2)] = (a * x) + (c * y) + tx;
            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;
        }

        if (this._roundPixels)
        {
            for (var i$1 = 0; i$1 < vertexData.length; i$1++)
            {
                vertexData[i$1] = Math.round(vertexData[i$1]);
            }
        }

        this.vertexDirty = geometry.vertexDirtyId;
    };

    /**
     * Updates uv field based on from geometry uv's or batchUvs
     */
    Mesh.prototype.calculateUvs = function calculateUvs ()
    {
        var geomUvs = this.geometry.buffers[1];

        if (!this.shader.uvMatrix.isSimple)
        {
            if (!this.batchUvs)
            {
                this.batchUvs = new MeshBatchUvs(geomUvs, this.shader.uvMatrix);
            }
            this.batchUvs.update();
            this.uvs = this.batchUvs.data;
        }
        else
        {
            this.uvs = geomUvs.data;
        }
    };

    /**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */
    Mesh.prototype._calculateBounds = function _calculateBounds ()
    {
        this.calculateVertices();

        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    };

    /**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.Point} point the point to test
     * @return {boolean} the result of the test
     */
    Mesh.prototype.containsPoint = function containsPoint (point)
    {
        if (!this.getBounds().contains(point.x, point.y))
        {
            return false;
        }

        this.worldTransform.applyInverse(point, tempPoint);

        var vertices = this.geometry.getBuffer('aVertexPosition').data;

        var points = tempPolygon.points;
        var indices =  this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;

        for (var i = 0; i + 2 < len; i += step)
        {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;

            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];

            if (tempPolygon.contains(tempPoint.x, tempPoint.y))
            {
                return true;
            }
        }

        return false;
    };
    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */
    Mesh.prototype.destroy = function destroy (options)
    {
        Container.prototype.destroy.call(this, options);

        this.geometry.refCount--;
        if (this.geometry.refCount === 0)
        {
            this.geometry.dispose();
        }

        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
    };

    Object.defineProperties( Mesh.prototype, prototypeAccessors );

    return Mesh;
}(_pixi_display__WEBPACK_IMPORTED_MODULE_3__.Container));

/**
 * The maximum number of vertices to consider batchable. Generally, the complexity
 * of the geometry.
 * @memberof PIXI.Mesh
 * @static
 * @member {number} BATCHABLE_SIZE
 */
Mesh.BATCHABLE_SIZE = 100;

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";

var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";

/**
 * Slightly opinionated default shader for PixiJS 2D objects.
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */
var MeshMaterial = /*@__PURE__*/(function (Shader) {
    function MeshMaterial(uSampler, options)
    {
        var uniforms = {
            uSampler: uSampler,
            alpha: 1,
            uTextureMatrix: _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        };

        // Set defaults
        options = Object.assign({
            tint: 0xFFFFFF,
            alpha: 1,
            pluginName: 'batch',
        }, options);

        if (options.uniforms)
        {
            Object.assign(uniforms, options.uniforms);
        }

        Shader.call(this, options.program || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Program.from(vertex, fragment), uniforms);

        /**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */
        this._colorDirty = false;

        /**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */
        this.uvMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TextureMatrix(uSampler);

        /**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */
        this.batchable = options.program === undefined;

        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = options.pluginName;

        this.tint = options.tint;
        this.alpha = options.alpha;
    }

    if ( Shader ) MeshMaterial.__proto__ = Shader;
    MeshMaterial.prototype = Object.create( Shader && Shader.prototype );
    MeshMaterial.prototype.constructor = MeshMaterial;

    var prototypeAccessors = { texture: { configurable: true },alpha: { configurable: true },tint: { configurable: true } };

    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    prototypeAccessors.texture.get = function ()
    {
        return this.uniforms.uSampler;
    };
    prototypeAccessors.texture.set = function (value)
    {
        if (this.uniforms.uSampler !== value)
        {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
        }
    };

    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    prototypeAccessors.alpha.set = function (value)
    {
        if (value === this._alpha) { return; }

        this._alpha = value;
        this._colorDirty = true;
    };
    prototypeAccessors.alpha.get = function ()
    {
        return this._alpha;
    };

    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    prototypeAccessors.tint.set = function (value)
    {
        if (value === this._tint) { return; }

        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        this._colorDirty = true;
    };
    prototypeAccessors.tint.get = function ()
    {
        return this._tint;
    };

    /**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */
    MeshMaterial.prototype.update = function update ()
    {
        if (this._colorDirty)
        {
            this._colorDirty = false;
            var baseTexture = this.texture.baseTexture;

            (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_5__.premultiplyTintToRgba)(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha);
        }
        if (this.uvMatrix.update())
        {
            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
    };

    Object.defineProperties( MeshMaterial.prototype, prototypeAccessors );

    return MeshMaterial;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader));

/**
 * Standard 2D geometry used in PixiJS.
 *
 * Geometry can be defined without passing in a style or data if required.
 *
 * ```js
 * const geometry = new PIXI.Geometry();
 *
 * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);
 * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1], 2);
 * geometry.addIndex([0,1,2,1,3,2]);
 *
 * ```
 * @class
 * @memberof PIXI
 * @extends PIXI.Geometry
 */
var MeshGeometry = /*@__PURE__*/(function (Geometry) {
    function MeshGeometry(vertices, uvs, index)
    {
        Geometry.call(this);

        var verticesBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(vertices);
        var uvsBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(uvs, true);
        var indexBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(index, true, true);

        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.TYPES.FLOAT)
            .addAttribute('aTextureCoord', uvsBuffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.TYPES.FLOAT)
            .addIndex(indexBuffer);

        /**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */
        this._updateId = -1;
    }

    if ( Geometry ) MeshGeometry.__proto__ = Geometry;
    MeshGeometry.prototype = Object.create( Geometry && Geometry.prototype );
    MeshGeometry.prototype.constructor = MeshGeometry;

    var prototypeAccessors = { vertexDirtyId: { configurable: true } };

    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    prototypeAccessors.vertexDirtyId.get = function ()
    {
        return this.buffers[0]._updateID;
    };

    Object.defineProperties( MeshGeometry.prototype, prototypeAccessors );

    return MeshGeometry;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Geometry));


//# sourceMappingURL=mesh.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/mixin-cache-as-bitmap.es.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/mixin-cache-as-bitmap/lib/mixin-cache-as-bitmap.es.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/sprite.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/*!
 * @pixi/mixin-cache-as-bitmap - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */







var _tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_3__.Matrix();

_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._cacheAsBitmap = false;
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._cacheData = false;

// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */
var CacheData = function CacheData()
{
    this.textureCacheId = null;

    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;

    this.originalUpdateTransform = null;
    this.originalHitTest = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.sprite = null;
};

Object.defineProperties(_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype, {
    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can
     * provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to `false`
     *
     * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    cacheAsBitmap: {
        get: function get()
        {
            return this._cacheAsBitmap;
        },
        set: function set(value)
        {
            if (this._cacheAsBitmap === value)
            {
                return;
            }

            this._cacheAsBitmap = value;

            var data;

            if (value)
            {
                if (!this._cacheData)
                {
                    this._cacheData = new CacheData();
                }

                data = this._cacheData;

                data.originalRender = this.render;
                data.originalRenderCanvas = this.renderCanvas;

                data.originalUpdateTransform = this.updateTransform;
                data.originalCalculateBounds = this.calculateBounds;
                data.originalGetLocalBounds = this.getLocalBounds;

                data.originalDestroy = this.destroy;

                data.originalContainsPoint = this.containsPoint;

                data.originalMask = this._mask;
                data.originalFilterArea = this.filterArea;

                this.render = this._renderCached;
                this.renderCanvas = this._renderCachedCanvas;

                this.destroy = this._cacheAsBitmapDestroy;
            }
            else
            {
                data = this._cacheData;

                if (data.sprite)
                {
                    this._destroyCachedDisplayObject();
                }

                this.render = data.originalRender;
                this.renderCanvas = data.originalRenderCanvas;
                this.calculateBounds = data.originalCalculateBounds;
                this.getLocalBounds = data.originalGetLocalBounds;

                this.destroy = data.originalDestroy;

                this.updateTransform = data.originalUpdateTransform;
                this.containsPoint = data.originalContainsPoint;

                this._mask = data.originalMask;
                this.filterArea = data.originalFilterArea;
            }
        },
    },
});

/**
 * Renders a cached version of the sprite with WebGL
 *
 * @private
 * @function _renderCached
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._renderCached = function _renderCached(renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObject(renderer);

    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._render(renderer);
};

/**
 * Prepares the WebGL renderer to cache the sprite
 *
 * @private
 * @function _initCachedDisplayObject
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer)
{
    if (this._cacheData && this._cacheData.sprite)
    {
        return;
    }

    // make sure alpha is set to 1 otherwise it will get rendered as invisible!
    var cacheAlpha = this.alpha;

    this.alpha = 1;

    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
    renderer.batch.flush();
    // this.filters= [];

    // next we find the dimensions of the untransformed object
    // this function also calls updatetransform on all its children as part of the measuring.
    // This means we don't need to update the transform again in this function
    // TODO pass an object to clone too? saves having to create a new one each time!
    var bounds = this.getLocalBounds().clone();

    // add some padding!
    if (this.filters)
    {
        var padding = this.filters[0].padding;

        bounds.pad(padding);
    }

    bounds.ceil(_pixi_settings__WEBPACK_IMPORTED_MODULE_5__.settings.RESOLUTION);

    // for now we cache the current renderTarget that the WebGL renderer is currently using.
    // this could be more elegant..
    var cachedRenderTexture = renderer.renderTexture.current;
    var cachedSourceFrame = renderer.renderTexture.sourceFrame;
    var cachedProjectionTransform = renderer.projection.transform;

    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
    // const stack = renderer.filterManager.filterStack;

    // this renderTexture will be used to store the cached DisplayObject
    var renderTexture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture.create(bounds.width, bounds.height);

    var textureCacheId = "cacheAsBitmap_" + ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.uid)());

    this._cacheData.textureCacheId = textureCacheId;

    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(renderTexture, textureCacheId);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;

    // reset
    this.transform.worldTransform.identity();

    // set all properties to there original so we can render to a texture
    this.render = this._cacheData.originalRender;

    renderer.render(this, renderTexture, true, m, true);

    // now restore the state be setting the new properties
    renderer.projection.transform = cachedProjectionTransform;
    renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame);

    // renderer.filterManager.filterStack = stack;

    this.render = this._renderCached;
    // the rest is the same as for Canvas
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;

    this._mask = null;
    this.filterArea = null;

    // create our cached sprite
    var cachedSprite = new _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite(renderTexture);

    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;

    this._cacheData.sprite = cachedSprite;

    this.transform._parentID = -1;
    // restore the transform of the cached sprite to avoid the nasty flicker..
    if (!this.parent)
    {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
    }
    else
    {
        this.updateTransform();
    }

    // map the hit test..
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};

/**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @function _renderCachedCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    this._initCachedDisplayObjectCanvas(renderer);

    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderCanvas(renderer);
};

// TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..
/**
 * Prepares the Canvas renderer to cache the sprite
 *
 * @private
 * @function _initCachedDisplayObjectCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer)
{
    if (this._cacheData && this._cacheData.sprite)
    {
        return;
    }

    // get bounds actually transforms the object for us already!
    var bounds = this.getLocalBounds();

    var cacheAlpha = this.alpha;

    this.alpha = 1;

    var cachedRenderTarget = renderer.context;

    bounds.ceil(_pixi_settings__WEBPACK_IMPORTED_MODULE_5__.settings.RESOLUTION);

    var renderTexture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture.create(bounds.width, bounds.height);

    var textureCacheId = "cacheAsBitmap_" + ((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.uid)());

    this._cacheData.textureCacheId = textureCacheId;

    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(renderTexture, textureCacheId);

    // need to set //
    var m = _tempMatrix;

    this.transform.localTransform.copyTo(m);
    m.invert();

    m.tx -= bounds.x;
    m.ty -= bounds.y;

    // m.append(this.transform.worldTransform.)
    // set all properties to there original so we can render to a texture
    this.renderCanvas = this._cacheData.originalRenderCanvas;

    // renderTexture.render(this, m, true);
    renderer.render(this, renderTexture, true, m, false);

    // now restore the state be setting the new properties
    renderer.context = cachedRenderTarget;

    this.renderCanvas = this._renderCachedCanvas;
    // the rest is the same as for WebGL
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;

    this._mask = null;
    this.filterArea = null;

    // create our cached sprite
    var cachedSprite = new _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite(renderTexture);

    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;

    this._cacheData.sprite = cachedSprite;

    this.transform._parentID = -1;
    // restore the transform of the cached sprite to avoid the nasty flicker..
    if (!this.parent)
    {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
    }
    else
    {
        this.updateTransform();
    }

    // map the hit test..
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};

/**
 * Calculates the bounds of the cached sprite
 *
 * @private
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds()
{
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._lastBoundsID = this._boundsID;
};

/**
 * Gets the bounds of the cached sprite.
 *
 * @private
 * @return {Rectangle} The local bounds.
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds()
{
    return this._cacheData.sprite.getLocalBounds();
};

/**
 * Destroys the cached sprite.
 *
 * @private
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject()
{
    this._cacheData.sprite._texture.destroy(true);
    this._cacheData.sprite = null;

    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.removeFromCache(this._cacheData.textureCacheId);

    this._cacheData.textureCacheId = null;
};

/**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_2__.DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options)
{
    this.cacheAsBitmap = false;
    this.destroy(options);
};
//# sourceMappingURL=mixin-cache-as-bitmap.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-child-by-name/lib/mixin-get-child-by-name.es.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-child-by-name/lib/mixin-get-child-by-name.es.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/*!
 * @pixi/mixin-get-child-by-name - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */


/**
 * The instance name of the object.
 *
 * @memberof PIXI.DisplayObject#
 * @member {string} name
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_0__.DisplayObject.prototype.name = null;

/**
 * Returns the display object in the container.
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - Instance name.
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_0__.Container.prototype.getChildByName = function getChildByName(name)
{
    for (var i = 0; i < this.children.length; i++)
    {
        if (this.children[i].name === name)
        {
            return this.children[i];
        }
    }

    return null;
};
//# sourceMappingURL=mixin-get-child-by-name.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-global-position/lib/mixin-get-global-position.es.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-global-position/lib/mixin-get-global-position.es.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/*!
 * @pixi/mixin-get-global-position - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



/**
 * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
 *
 * @method getGlobalPosition
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Point} [point=new PIXI.Point()] - The point to write the global value to.
 * @param {boolean} [skipUpdate=false] - Setting to true will stop the transforms of the scene graph from
 *  being updated. This means the calculation returned MAY be out of date BUT will give you a
 *  nice performance boost.
 * @return {PIXI.Point} The updated point.
 */
_pixi_display__WEBPACK_IMPORTED_MODULE_0__.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate)
{
    if ( point === void 0 ) point = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point();
    if ( skipUpdate === void 0 ) skipUpdate = false;

    if (this.parent)
    {
        this.parent.toGlobal(this.position, point, skipUpdate);
    }
    else
    {
        point.x = this.position.x;
        point.y = this.position.y;
    }

    return point;
};
//# sourceMappingURL=mixin-get-global-position.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/particles/lib/particles.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/particles/lib/particles.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleContainer": () => (/* binding */ ParticleContainer),
/* harmony export */   "ParticleRenderer": () => (/* binding */ ParticleRenderer)
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/constants.es.js");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/utils.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/math.es.js");
/*!
 * @pixi/particles - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/particles is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */






/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles.
 *
 * The tradeoff of the ParticleContainer is that most advanced functionality will not work.
 * ParticleContainer implements the basic object transform (position, scale, rotation)
 * and some advanced functionality like tint (as of v4.5.6).
 *
 * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use:
 * ```js
 * let container = new ParticleContainer();
 *
 * for (let i = 0; i < 100; ++i)
 * {
 *     let sprite = PIXI.Sprite.from("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be rendered at the speed of light.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */
var ParticleContainer = /*@__PURE__*/(function (Container) {
    function ParticleContainer(maxSize, properties, batchSize, autoResize)
    {
        if ( maxSize === void 0 ) maxSize = 1500;
        if ( batchSize === void 0 ) batchSize = 16384;
        if ( autoResize === void 0 ) autoResize = false;

        Container.call(this);

        // Making sure the batch size is valid
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        var maxBatchSize = 16384;

        if (batchSize > maxBatchSize)
        {
            batchSize = maxBatchSize;
        }

        /**
         * Set properties to be dynamic (true) / static (false)
         *
         * @member {boolean[]}
         * @private
         */
        this._properties = [false, true, false, false, false];

        /**
         * @member {number}
         * @private
         */
        this._maxSize = maxSize;

        /**
         * @member {number}
         * @private
         */
        this._batchSize = batchSize;

        /**
         * @member {Array<PIXI.Buffer>}
         * @private
         */
        this._buffers = null;

        /**
         * for every batch stores _updateID corresponding to the last change in that batch
         * @member {number[]}
         * @private
         */
        this._bufferUpdateIDs = [];

        /**
         * when child inserted, removed or changes position this number goes up
         * @member {number[]}
         * @private
         */
        this._updateID = 0;

        /**
         * @member {boolean}
         *
         */
        this.interactiveChildren = false;

        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`
         * to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;

        /**
         * If true, container allocates more batches in case there are more than `maxSize` particles.
         * @member {boolean}
         * @default false
         */
        this.autoResize = autoResize;

        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * Default to true here as performance is usually the priority for particles.
         *
         * @member {boolean}
         * @default true
         */
        this.roundPixels = true;

        /**
         * The texture used to render the children.
         *
         * @readonly
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = null;

        this.setProperties(properties);

        /**
         * The tint applied to the container.
         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = 0;
        this.tintRgb = new Float32Array(4);
        this.tint = 0xFFFFFF;
    }

    if ( Container ) ParticleContainer.__proto__ = Container;
    ParticleContainer.prototype = Object.create( Container && Container.prototype );
    ParticleContainer.prototype.constructor = ParticleContainer;

    var prototypeAccessors = { tint: { configurable: true } };

    /**
     * Sets the private properties array to dynamic / static based on the passed properties object
     *
     * @param {object} properties - The properties to be uploaded
     */
    ParticleContainer.prototype.setProperties = function setProperties (properties)
    {
        if (properties)
        {
            this._properties[0] = 'vertices' in properties || 'scale' in properties
                ? !!properties.vertices || !!properties.scale : this._properties[0];
            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
            this._properties[4] = 'tint' in properties || 'alpha' in properties
                ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
    };

    /**
     * Updates the object transform for rendering
     *
     * @private
     */
    ParticleContainer.prototype.updateTransform = function updateTransform ()
    {
        // TODO don't need to!
        this.displayObjectUpdateTransform();
        //  PIXI.Container.prototype.updateTransform.call( this );
    };

    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     ** IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @member {number}
     * @default 0xFFFFFF
     */
    prototypeAccessors.tint.get = function ()
    {
        return this._tint;
    };

    prototypeAccessors.tint.set = function (value) // eslint-disable-line require-jsdoc
    {
        this._tint = value;
        (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.hex2rgb)(value, this.tintRgb);
    };

    /**
     * Renders the container using the WebGL renderer
     *
     * @private
     * @param {PIXI.Renderer} renderer - The webgl renderer
     */
    ParticleContainer.prototype.render = function render (renderer)
    {
        var this$1 = this;

        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
        {
            return;
        }

        if (!this.baseTexture)
        {
            this.baseTexture = this.children[0]._texture.baseTexture;
            if (!this.baseTexture.valid)
            {
                this.baseTexture.once('update', function () { return this$1.onChildrenChange(0); });
            }
        }

        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
    };

    /**
     * Set the flag that static data should be updated to true
     *
     * @private
     * @param {number} smallestChildIndex - The smallest child index
     */
    ParticleContainer.prototype.onChildrenChange = function onChildrenChange (smallestChildIndex)
    {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);

        while (this._bufferUpdateIDs.length < bufferIndex)
        {
            this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    };

    ParticleContainer.prototype.dispose = function dispose ()
    {
        if (this._buffers)
        {
            for (var i = 0; i < this._buffers.length; ++i)
            {
                this._buffers[i].destroy();
            }

            this._buffers = null;
        }
    };

    /**
     * Destroys the container
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    ParticleContainer.prototype.destroy = function destroy (options)
    {
        Container.prototype.destroy.call(this, options);

        this.dispose();

        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
    };

    Object.defineProperties( ParticleContainer.prototype, prototypeAccessors );

    return ParticleContainer;
}(_pixi_display__WEBPACK_IMPORTED_MODULE_2__.Container));

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that
 * they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleBuffer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
 */

/**
 * The particle buffer manages the static and dynamic buffers for a particle container.
 *
 * @class
 * @private
 * @memberof PIXI
 */
var ParticleBuffer = function ParticleBuffer(properties, dynamicPropertyFlags, size)
{
    this.geometry = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Geometry();

    this.indexBuffer = null;

    /**
     * The number of particles the buffer can hold
     *
     * @private
     * @member {number}
     */
    this.size = size;

    /**
     * A list of the properties that are dynamic.
     *
     * @private
     * @member {object[]}
     */
    this.dynamicProperties = [];

    /**
     * A list of the properties that are static.
     *
     * @private
     * @member {object[]}
     */
    this.staticProperties = [];

    for (var i = 0; i < properties.length; ++i)
    {
        var property = properties[i];

        // Make copy of properties object so that when we edit the offset it doesn't
        // change all other instances of the object literal
        property = {
            attributeName: property.attributeName,
            size: property.size,
            uploadFunction: property.uploadFunction,
            type: property.type || _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT,
            offset: property.offset,
        };

        if (dynamicPropertyFlags[i])
        {
            this.dynamicProperties.push(property);
        }
        else
        {
            this.staticProperties.push(property);
        }
    }

    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;

    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;

    this._updateID = 0;

    this.initBuffers();
};

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 */
ParticleBuffer.prototype.initBuffers = function initBuffers ()
{
    var geometry = this.geometry;

    var dynamicOffset = 0;

    /**
     * Holds the indices of the geometry (quads) to draw
     *
     * @member {Uint16Array}
     * @private
     */
    this.indexBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Buffer((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.createIndicesForQuads)(this.size), true, true);
    geometry.addIndex(this.indexBuffer);

    this.dynamicStride = 0;

    for (var i = 0; i < this.dynamicProperties.length; ++i)
    {
        var property = this.dynamicProperties[i];

        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
    }

    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);

    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Buffer(this.dynamicData, false, false);

    // static //
    var staticOffset = 0;

    this.staticStride = 0;

    for (var i$1 = 0; i$1 < this.staticProperties.length; ++i$1)
    {
        var property$1 = this.staticProperties[i$1];

        property$1.offset = staticOffset;
        staticOffset += property$1.size;
        this.staticStride += property$1.size;
    }

    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);

    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Buffer(this.staticData, true, false);

    for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2)
    {
        var property$2 = this.dynamicProperties[i$2];

        geometry.addAttribute(
            property$2.attributeName,
            this.dynamicBuffer,
            0,
            property$2.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE,
            property$2.type,
            this.dynamicStride * 4,
            property$2.offset * 4
        );
    }

    for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3)
    {
        var property$3 = this.staticProperties[i$3];

        geometry.addAttribute(
            property$3.attributeName,
            this.staticBuffer,
            0,
            property$3.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE,
            property$3.type,
            this.staticStride * 4,
            property$3.offset * 4
        );
    }
};

/**
 * Uploads the dynamic properties.
 *
 * @private
 * @param {PIXI.DisplayObject[]} children - The children to upload.
 * @param {number} startIndex - The index to start at.
 * @param {number} amount - The number to upload.
 */
ParticleBuffer.prototype.uploadDynamic = function uploadDynamic (children, startIndex, amount)
{
    for (var i = 0; i < this.dynamicProperties.length; i++)
    {
        var property = this.dynamicProperties[i];

        property.uploadFunction(children, startIndex, amount,
            property.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,
            this.dynamicStride, property.offset);
    }

    this.dynamicBuffer._updateID++;
};

/**
 * Uploads the static properties.
 *
 * @private
 * @param {PIXI.DisplayObject[]} children - The children to upload.
 * @param {number} startIndex - The index to start at.
 * @param {number} amount - The number to upload.
 */
ParticleBuffer.prototype.uploadStatic = function uploadStatic (children, startIndex, amount)
{
    for (var i = 0; i < this.staticProperties.length; i++)
    {
        var property = this.staticProperties[i];

        property.uploadFunction(children, startIndex, amount,
            property.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
            this.staticStride, property.offset);
    }

    this.staticBuffer._updateID++;
};

/**
 * Destroys the ParticleBuffer.
 *
 * @private
 */
ParticleBuffer.prototype.destroy = function destroy ()
{
    this.indexBuffer = null;

    this.dynamicProperties = null;
    // this.dynamicBuffer.destroy();
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;

    this.staticProperties = null;
    // this.staticBuffer.destroy();
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    // all buffers are destroyed inside geometry
    this.geometry.destroy();
};

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";

var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original PixiJS version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
 * share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
 */

/**
 * Renderer for Particles that is designer for speed over feature set.
 *
 * @class
 * @memberof PIXI
 */
var ParticleRenderer = /*@__PURE__*/(function (ObjectRenderer) {
    function ParticleRenderer(renderer)
    {
        ObjectRenderer.call(this, renderer);

        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;

        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        this.shader = null;

        this.properties = null;

        this.tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Matrix();

        this.properties = [
            // verticesData
            {
                attributeName: 'aVertexPosition',
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0,
            },
            // positionData
            {
                attributeName: 'aPositionCoord',
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // rotationData
            {
                attributeName: 'aRotation',
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0,
            },
            // uvsData
            {
                attributeName: 'aTextureCoord',
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0,
            },
            // tintData
            {
                attributeName: 'aColor',
                size: 1,
                type: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0,
            } ];

        this.shader = _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Shader.from(vertex, fragment, {});
    }

    if ( ObjectRenderer ) ParticleRenderer.__proto__ = ObjectRenderer;
    ParticleRenderer.prototype = Object.create( ObjectRenderer && ObjectRenderer.prototype );
    ParticleRenderer.prototype.constructor = ParticleRenderer;

    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */
    ParticleRenderer.prototype.render = function render (container)
    {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;

        if (totalChildren === 0)
        {
            return;
        }
        else if (totalChildren > maxSize && !container.autoResize)
        {
            totalChildren = maxSize;
        }

        var buffers = container._buffers;

        if (!buffers)
        {
            buffers = container._buffers = this.generateBuffers(container);
        }

        var baseTexture = children[0]._texture.baseTexture;

        // if the uvs have not updated then no point rendering just yet!
        this.renderer.state.setBlendMode((0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.correctBlendMode)(container.blendMode, baseTexture.premultiplyAlpha));

        var gl = renderer.gl;

        var m = container.worldTransform.copyTo(this.tempMatrix);

        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);

        this.shader.uniforms.translationMatrix = m.toArray(true);

        this.shader.uniforms.uColor = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.premultiplyRgba)(container.tintRgb,
            container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha);

        this.shader.uniforms.uSampler = baseTexture;

        this.renderer.shader.bind(this.shader);

        var updateStatic = false;

        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)
        {
            var amount = (totalChildren - i);

            if (amount > batchSize)
            {
                amount = batchSize;
            }

            if (j >= buffers.length)
            {
                buffers.push(this._generateOneMoreBuffer(container));
            }

            var buffer = buffers[j];

            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);

            var bid = container._bufferUpdateIDs[j] || 0;

            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic)
            {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }

            // bind the buffer
            renderer.geometry.bind(buffer.geometry);
            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
    };

    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */
    ParticleRenderer.prototype.generateBuffers = function generateBuffers (container)
    {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;

        for (var i = 0; i < size; i += batchSize)
        {
            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }

        return buffers;
    };

    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */
    ParticleRenderer.prototype._generateOneMoreBuffer = function _generateOneMoreBuffer (container)
    {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;

        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    };

    /**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    ParticleRenderer.prototype.uploadVertices = function uploadVertices (children, startIndex, amount, array, stride, offset)
    {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;

        for (var i = 0; i < amount; ++i)
        {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;

            if (trim)
            {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (sprite.anchor.x * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (sprite.anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w0 = (orig.width) * (1 - sprite.anchor.x);
                w1 = (orig.width) * -sprite.anchor.x;

                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }

            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;

            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;

            array[offset + (stride * 2)] = w0 * sx;
            array[offset + (stride * 2) + 1] = h0 * sy;

            array[offset + (stride * 3)] = w1 * sx;
            array[offset + (stride * 3) + 1] = h0 * sy;

            offset += stride * 4;
        }
    };

    /**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    ParticleRenderer.prototype.uploadPosition = function uploadPosition (children, startIndex, amount, array, stride, offset)
    {
        for (var i = 0; i < amount; i++)
        {
            var spritePosition = children[startIndex + i].position;

            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;

            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;

            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;

            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;

            offset += stride * 4;
        }
    };

    /**
     * Uploads the rotiation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    ParticleRenderer.prototype.uploadRotation = function uploadRotation (children, startIndex, amount, array, stride, offset)
    {
        for (var i = 0; i < amount; i++)
        {
            var spriteRotation = children[startIndex + i].rotation;

            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + (stride * 2)] = spriteRotation;
            array[offset + (stride * 3)] = spriteRotation;

            offset += stride * 4;
        }
    };

    /**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    ParticleRenderer.prototype.uploadUvs = function uploadUvs (children, startIndex, amount, array, stride, offset)
    {
        for (var i = 0; i < amount; ++i)
        {
            var textureUvs = children[startIndex + i]._texture._uvs;

            if (textureUvs)
            {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;

                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;

                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;

                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;

                offset += stride * 4;
            }
            else
            {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;

                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;

                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;

                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;

                offset += stride * 4;
            }
        }
    };

    /**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    ParticleRenderer.prototype.uploadTint = function uploadTint (children, startIndex, amount, array, stride, offset)
    {
        for (var i = 0; i < amount; ++i)
        {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultiplyAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.premultiplyTint)(sprite._tintRGB, alpha)
                : sprite._tintRGB + (alpha * 255 << 24);

            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + (stride * 2)] = argb;
            array[offset + (stride * 3)] = argb;

            offset += stride * 4;
        }
    };

    /**
     * Destroys the ParticleRenderer.
     */
    ParticleRenderer.prototype.destroy = function destroy ()
    {
        ObjectRenderer.prototype.destroy.call(this);

        if (this.shader)
        {
            this.shader.destroy();
            this.shader = null;
        }

        this.tempMatrix = null;
    };

    return ParticleRenderer;
}(_pixi_core__WEBPACK_IMPORTED_MODULE_3__.ObjectRenderer));


//# sourceMappingURL=particles.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/polyfill/lib/polyfill.es.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/polyfill/lib/polyfill.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var es6_promise_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-promise-polyfill */ "./node_modules/es6-promise-polyfill/promise.js");
/* harmony import */ var es6_promise_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_promise_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! object-assign */ "../../../.nvm/versions/node/v14.16.0/lib/node_modules/mhy/node_modules/object-assign/index.js");
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_1__);
/*!
 * @pixi/polyfill - v5.1.0
 * Compiled Fri, 19 Jul 2019 21:54:36 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */



// Support for IE 9 - 11 which does not include Promises
if (!window.Promise)
{
    window.Promise = es6_promise_polyfill__WEBPACK_IMPORTED_MODULE_0__.Polyfill;
}

// References:

if (!Object.assign)
{
    Object.assign = (object_assign__WEBPACK_IMPORTED_MODULE_1___default());
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

var ONE_FRAME_TIME = 16;

// Date.now
if (!(Date.now && Date.prototype.getTime))
{
    Date.now = function now()
    {
        return new Date().getTime();
    };
}

// performance.now
if (!(commonjsGlobal.performance && commonjsGlobal.performance.now))
{
    var startTime = Date.now();

    if (!commonjsGlobal.performance)
    {
        commonjsGlobal.performance = {};
    }

    commonjsGlobal.performance.now = function () { return Date.now() - startTime; };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for (var x = 0; x < vendors.length && !commonjsGlobal.requestAnimationFrame; ++x)
{
    var p = vendors[x];

    commonjsGlobal.requestAnimationFrame = commonjsGlobal[(p + "RequestAnimationFrame")];
    commonjsGlobal.cancelAnimationFrame = commonjsGlobal[(p + "CancelAnimationFrame")] || commonjsGlobal[(p + "CancelRequestAnimationFrame")];
}

if (!commonjsGlobal.requestAnimationFrame)
{
    commonjsGlobal.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function')
        {
            throw new TypeError((callback + "is not a function"));
        }

        var currentTime = Date.now();
        var delay = ONE_FRAME_TIME + lastTime - currentTime;

        if (delay < 0)
        {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!commonjsGlobal.cancelAnimationFrame)
{
    commonjsGlobal.cancelAnimationFrame = function (id) { return clearTimeout(id); };
}

// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

if (!Math.sign)
{
    Math.sign = function mathSign(x)
    {
        x = Number(x);

        if (x === 0 || isNaN(x))
        {
            return x;
        }

        return x > 0 ? 1 : -1;
    };
}

// References:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

if (!Number.isInteger)
{
    Number.isInteger = function numberIsInteger(value)
    {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };
}

if (!window.ArrayBuffer)
{
    window.ArrayBuffer = Array;
}

if (!window.Float32Array)
{
    window.Float32Array = Array;
}

if (!window.Uint32Array)
{
    window.Uint32Array = Array;
}

if (!window.Uint16Array)
{
    window.Uint16Array = Array;
}

if (!window.Uint8Array)
{
    window.Uint8Array = Array;
}

if (!window.Int32Array)
{
    window.Int32Array = Array;
}
//# sourceMappingURL=polyfill.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/prepare.es.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/prepare.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasePrepare": () => (/* binding */ BasePrepare),
/* harmony export */   "CountLimiter": () => (/* binding */ CountLimiter),
/* harmony export */   "Prepare": () => (/* binding */ Prepare),
/* harmony export */   "TimeLimiter": () => (/* binding */ TimeLimiter)
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/settings.es.js");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/core.es.js");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/graphics.es.js");
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/ticker.es.js");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/display.es.js");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/text.es.js");
/*!
 * @pixi/prepare - v5.1.2
 * Compiled Sat, 24 Aug 2019 01:06:18 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */







/**
 * Default number of uploads per frame using prepare plugin.
 *
 * @static
 * @memberof PIXI.settings
 * @name UPLOADS_PER_FRAME
 * @type {number}
 * @default 4
 */
_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.UPLOADS_PER_FRAME = 4;

/**
 * CountLimiter limits the number of items handled by a {@link PIXI.prepare.BasePrepare} to a specified
 * number of items per frame.
 *
 * @class
 * @memberof PIXI.prepare
 */
var CountLimiter = function CountLimiter(maxItemsPerFrame)
{
    /**
     * The maximum number of items that can be prepared each frame.
     * @type {number}
     * @private
     */
    this.maxItemsPerFrame = maxItemsPerFrame;
    /**
     * The number of items that can be prepared in the current frame.
     * @type {number}
     * @private
     */
    this.itemsLeft = 0;
};

/**
 * Resets any counting properties to start fresh on a new frame.
 */
CountLimiter.prototype.beginFrame = function beginFrame ()
{
    this.itemsLeft = this.maxItemsPerFrame;
};

/**
 * Checks to see if another item can be uploaded. This should only be called once per item.
 * @return {boolean} If the item is allowed to be uploaded.
 */
CountLimiter.prototype.allowedToUpload = function allowedToUpload ()
{
    return this.itemsLeft-- > 0;
};

/**
 * The prepare manager provides functionality to upload content to the GPU.
 *
 * BasePrepare handles basic queuing functionality and is extended by
 * {@link PIXI.prepare.Prepare} and {@link PIXI.prepare.CanvasPrepare}
 * to provide preparation capabilities specific to their respective renderers.
 *
 * @example
 * // Create a sprite
 * const sprite = PIXI.Sprite.from('something.png');
 *
 * // Load object into GPU
 * app.renderer.plugins.prepare.upload(sprite, () => {
 *
 *     //Texture(s) has been uploaded to GPU
 *     app.stage.addChild(sprite);
 *
 * })
 *
 * @abstract
 * @class
 * @memberof PIXI.prepare
 */
var BasePrepare = function BasePrepare(renderer)
{
    var this$1 = this;

    /**
     * The limiter to be used to control how quickly items are prepared.
     * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
     */
    this.limiter = new CountLimiter(_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.UPLOADS_PER_FRAME);

    /**
     * Reference to the renderer.
     * @type {PIXI.AbstractRenderer}
     * @protected
     */
    this.renderer = renderer;

    /**
     * The only real difference between CanvasPrepare and Prepare is what they pass
     * to upload hooks. That different parameter is stored here.
     * @type {PIXI.prepare.CanvasPrepare|PIXI.Renderer}
     * @protected
     */
    this.uploadHookHelper = null;

    /**
     * Collection of items to uploads at once.
     * @type {Array<*>}
     * @private
     */
    this.queue = [];

    /**
     * Collection of additional hooks for finding assets.
     * @type {Array<Function>}
     * @private
     */
    this.addHooks = [];

    /**
     * Collection of additional hooks for processing assets.
     * @type {Array<Function>}
     * @private
     */
    this.uploadHooks = [];

    /**
     * Callback to call after completed.
     * @type {Array<Function>}
     * @private
     */
    this.completes = [];

    /**
     * If prepare is ticking (running).
     * @type {boolean}
     * @private
     */
    this.ticking = false;

    /**
     * 'bound' call for prepareItems().
     * @type {Function}
     * @private
     */
    this.delayedTick = function () {
        // unlikely, but in case we were destroyed between tick() and delayedTick()
        if (!this$1.queue)
        {
            return;
        }
        this$1.prepareItems();
    };

    // hooks to find the correct texture
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);

    // upload hooks
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
};

/**
 * Upload all the textures and graphics to the GPU.
 *
 * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
 *    Either the container or display object to search for items to upload, the items to upload themselves,
 *    or the callback function, if items have been added using `prepare.add`.
 * @param {Function} [done] - Optional callback when all queued uploads have completed
 */
BasePrepare.prototype.upload = function upload (item, done)
{
    if (typeof item === 'function')
    {
        done = item;
        item = null;
    }

    // If a display object, search for items
    // that we could upload
    if (item)
    {
        this.add(item);
    }

    // Get the items for upload from the display
    if (this.queue.length)
    {
        if (done)
        {
            this.completes.push(done);
        }

        if (!this.ticking)
        {
            this.ticking = true;
            _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__.Ticker.system.addOnce(this.tick, this, _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__.UPDATE_PRIORITY.UTILITY);
        }
    }
    else if (done)
    {
        done();
    }
};

/**
 * Handle tick update
 *
 * @private
 */
BasePrepare.prototype.tick = function tick ()
{
    setTimeout(this.delayedTick, 0);
};

/**
 * Actually prepare items. This is handled outside of the tick because it will take a while
 * and we do NOT want to block the current animation frame from rendering.
 *
 * @private
 */
BasePrepare.prototype.prepareItems = function prepareItems ()
{
    this.limiter.beginFrame();
    // Upload the graphics
    while (this.queue.length && this.limiter.allowedToUpload())
    {
        var item = this.queue[0];
        var uploaded = false;

        if (item && !item._destroyed)
        {
            for (var i = 0, len = this.uploadHooks.length; i < len; i++)
            {
                if (this.uploadHooks[i](this.uploadHookHelper, item))
                {
                    this.queue.shift();
                    uploaded = true;
                    break;
                }
            }
        }

        if (!uploaded)
        {
            this.queue.shift();
        }
    }

    // We're finished
    if (!this.queue.length)
    {
        this.ticking = false;

        var completes = this.completes.slice(0);

        this.completes.length = 0;

        for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++)
        {
            completes[i$1]();
        }
    }
    else
    {
        // if we are not finished, on the next rAF do this again
        _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__.Ticker.system.addOnce(this.tick, this, _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__.UPDATE_PRIORITY.UTILITY);
    }
};

/**
 * Adds hooks for finding items.
 *
 * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
 *      function must return `true` if it was able to add item to the queue.
 * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
 */
BasePrepare.prototype.registerFindHook = function registerFindHook (addHook)
{
    if (addHook)
    {
        this.addHooks.push(addHook);
    }

    return this;
};

/**
 * Adds hooks for uploading items.
 *
 * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
 *      function must return `true` if it was able to handle upload of item.
 * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
 */
BasePrepare.prototype.registerUploadHook = function registerUploadHook (uploadHook)
{
    if (uploadHook)
    {
        this.uploadHooks.push(uploadHook);
    }

    return this;
};

/**
 * Manually add an item to the uploading queue.
 *
 * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
 *    add to the queue
 * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
 */
BasePrepare.prototype.add = function add (item)
{
    // Add additional hooks for finding elements on special
    // types of objects that
    for (var i = 0, len = this.addHooks.length; i < len; i++)
    {
        if (this.addHooks[i](item, this.queue))
        {
            break;
        }
    }

    // Get children recursively
    if (item instanceof _pixi_display__WEBPACK_IMPORTED_MODULE_4__.Container)
    {
        for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--)
        {
            this.add(item.children[i$1]);
        }
    }

    return this;
};

/**
 * Destroys the plugin, don't use after this.
 *
 */
BasePrepare.prototype.destroy = function destroy ()
{
    if (this.ticking)
    {
        _pixi_ticker__WEBPACK_IMPORTED_MODULE_3__.Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
};

/**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
function findMultipleBaseTextures(item, queue)
{
    var result = false;

    // Objects with multiple textures
    if (item && item._textures && item._textures.length)
    {
        for (var i = 0; i < item._textures.length; i++)
        {
            if (item._textures[i] instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_1__.Texture)
            {
                var baseTexture = item._textures[i].baseTexture;

                if (queue.indexOf(baseTexture) === -1)
                {
                    queue.push(baseTexture);
                    result = true;
                }
            }
        }
    }

    return result;
}

/**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
function findBaseTexture(item, queue)
{
    // Objects with textures, like Sprites/Text
    if (item instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_1__.BaseTexture)
    {
        if (queue.indexOf(item) === -1)
        {
            queue.push(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
function findTexture(item, queue)
{
    if (item._texture && item._texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_1__.Texture)
    {
        var texture = item._texture.baseTexture;

        if (queue.indexOf(texture) === -1)
        {
            queue.push(texture);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to draw PIXI.Text to its texture.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function drawText(helper, item)
{
    if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_5__.Text)
    {
        // updating text will return early if it is not dirty
        item.updateText(true);

        return true;
    }

    return false;
}

/**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function calculateTextStyle(helper, item)
{
    if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_5__.TextStyle)
    {
        var font = item.toFontString();

        _pixi_text__WEBPACK_IMPORTED_MODULE_5__.TextMetrics.measureFont(font);

        return true;
    }

    return false;
}

/**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
function findText(item, queue)
{
    if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_5__.Text)
    {
        // push the text style to prepare it - this can be really expensive
        if (queue.indexOf(item.style) === -1)
        {
            queue.push(item.style);
        }
        // also push the text object so that we can render it (to canvas/texture) if needed
        if (queue.indexOf(item) === -1)
        {
            queue.push(item);
        }
        // also push the Text's texture for upload to GPU
        var texture = item._texture.baseTexture;

        if (queue.indexOf(texture) === -1)
        {
            queue.push(texture);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
function findTextStyle(item, queue)
{
    if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_5__.TextStyle)
    {
        if (queue.indexOf(item) === -1)
        {
            queue.push(item);
        }

        return true;
    }

    return false;
}

/**
 * The prepare manager provides functionality to upload content to the GPU.
 *
 * An instance of this class is automatically created by default, and can be found at `renderer.plugins.prepare`
 *
 * @class
 * @extends PIXI.prepare.BasePrepare
 * @memberof PIXI.prepare
 */
var Prepare = /*@__PURE__*/(function (BasePrepare) {
    function Prepare(renderer)
    {
        BasePrepare.call(this, renderer);

        this.uploadHookHelper = this.renderer;

        // Add textures and graphics to upload
        this.registerFindHook(findGraphics);
        this.registerUploadHook(uploadBaseTextures);
        this.registerUploadHook(uploadGraphics);
    }

    if ( BasePrepare ) Prepare.__proto__ = BasePrepare;
    Prepare.prototype = Object.create( BasePrepare && BasePrepare.prototype );
    Prepare.prototype.constructor = Prepare;

    return Prepare;
}(BasePrepare));
/**
 * Built-in hook to upload PIXI.Texture objects to the GPU.
 *
 * @private
 * @param {PIXI.Renderer} renderer - instance of the webgl renderer
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function uploadBaseTextures(renderer, item)
{
    if (item instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_1__.BaseTexture)
    {
        // if the texture already has a GL texture, then the texture has been prepared or rendered
        // before now. If the texture changed, then the changer should be calling texture.update() which
        // reuploads the texture without need for preparing it again
        if (!item._glTextures[renderer.CONTEXT_UID])
        {
            renderer.texture.bind(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to upload PIXI.Graphics to the GPU.
 *
 * @private
 * @param {PIXI.Renderer} renderer - instance of the webgl renderer
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
function uploadGraphics(renderer, item)
{
    if (item instanceof _pixi_graphics__WEBPACK_IMPORTED_MODULE_2__.Graphics)
    {
        // if the item is not dirty and already has webgl data, then it got prepared or rendered
        // before now and we shouldn't waste time updating it again
        if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID])
        {
            renderer.plugins.graphics.updateGraphics(item);
        }

        return true;
    }

    return false;
}

/**
 * Built-in hook to find graphics.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Graphics object was found.
 */
function findGraphics(item, queue)
{
    if (item instanceof _pixi_graphics__WEBPACK_IMPORTED_MODULE_2__.Graphics)
    {
        queue.push(item);

        return true;
    }

    return false;
}

/**
 * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified
 * number of milliseconds per frame.
 *
 * @class
 * @memberof PIXI.prepare
 */
var TimeLimiter = function TimeLimiter(maxMilliseconds)
{
    /**
     * The maximum milliseconds that can be spent preparing items each frame.
     * @type {number}
     * @private
     */
    this.maxMilliseconds = maxMilliseconds;
    /**
     * The start time of the current frame.
     * @type {number}
     * @private
     */
    this.frameStart = 0;
};

/**
 * Resets any counting properties to start fresh on a new frame.
 */
TimeLimiter.prototype.beginFrame = function beginFrame ()
{
    this.frameStart = Date.now();
};

/**
 * Checks to see if another item can be uploaded. This should only be called once per item.
 * @return {boolean} If the item is allowed to be uploaded.
 */
TimeLimiter.prototype.allowedToUpload = function allowedToUpload ()
{
    return Date.now() - this.frameStart < this.maxMilliseconds;
};

/**
 * The prepare namespace provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for
 * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.
 *
 * Do not instantiate these plugins directly. It is available from the `renderer.plugins` property.
 * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.
 * @example
 * // Create a new application
 * const app = new PIXI.Application();
 * document.body.appendChild(app.view);
 *
 * // Don't start rendering right away
 * app.stop();
 *
 * // create a display object
 * const rect = new PIXI.Graphics()
 *     .beginFill(0x00ff00)
 *     .drawRect(40, 40, 200, 200);
 *
 * // Add to the stage
 * app.stage.addChild(rect);
 *
 * // Don't start rendering until the graphic is uploaded to the GPU
 * app.renderer.plugins.prepare.upload(app.stage, () => {
 *     app.start();
 * });
 * @namespace PIXI.prepare
 */


//# sourceMappingURL=prepare.es.js.map


/***/ }),

/***/ "./node_modules/@pixi/runner/lib/runner.es.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/runner.es.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Runner": () => (/* binding */ Runner)
/* harmony export */ });
/*!
 * @pixi/runner - v5.1.1
 * Compiled Fri, 02 Aug 2019 23:20:23 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/**
 * A Runner is a highly performant and simple alternative to signals. Best used in situations
 * where events are dispatched to many objects at high frequency (say every frame!)
 *
 *
 * like a signal..
 * ```
 * const myObject = {
 *     loaded: new PIXI.Runner('loaded')
 * }
 *
 * const listener = {
 *     loaded: function(){
 *         // thin
 *     }
 * }
 *
 * myObject.update.add(listener);
 *
 * myObject.loaded.emit();
 * ```
 *
 * Or for handling calling the same function on many items
 * ```
 * const myGame = {
 *     update: new PIXI.Runner('update')
 * }
 *
 * const gameObject = {
 *     update: function(time){
 *         // update my gamey state
 *     }
 * }
 *
 * myGame.update.add(gameObject1);
 *
 * myGame.update.emit(time);
 * ```
 * @class
 * @memberof PIXI
 */
var Runner = function Runner(name)
{
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
};

var prototypeAccessors = { empty: { configurable: true },name: { configurable: true } };

/**
 * Dispatch/Broadcast Runner to all listeners added to the queue.
 * @param {...any} params - optional parameters to pass to each listener
 */
Runner.prototype.emit = function emit (a0, a1, a2, a3, a4, a5, a6, a7)
{
    if (arguments.length > 8)
    {
        throw new Error('max arguments reached');
    }

    var ref = this;
        var name = ref.name;
        var items = ref.items;

    this._aliasCount++;

    for (var i = 0, len = items.length; i < len; i++)
    {
        items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }

    if (items === this.items)
    {
        this._aliasCount--;
    }

    return this;
};

Runner.prototype.ensureNonAliasedItems = function ensureNonAliasedItems ()
{
    if (this._aliasCount > 0 && this.items.length > 1)
    {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
    }
};

/**
 * Add a listener to the Runner
 *
 * Runners do not need to have scope or functions passed to them.
 * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
 * as the name provided to the Runner when it was created.
 *
 * Eg A listener passed to this Runner will require a 'complete' function.
 *
 * ```
 * const complete = new PIXI.Runner('complete');
 * ```
 *
 * The scope used will be the object itself.
 *
 * @param {any} item - The object that will be listening.
 */
Runner.prototype.add = function add (item)
{
    if (item[this._name])
    {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
    }

    return this;
};

/**
 * Remove a single listener from the dispatch queue.
 * @param {any} item - The listenr that you would like to remove.
 */
Runner.prototype.remove = function remove (item)
{
    var index = this.items.indexOf(item);

    if (index !== -1)
    {
        this.ensureNonAliasedItems();
        this.items.splice(index, 1);
    }

    return this;
};

/**
 * Check to see if the listener is already in the Runner
 * @param {any} item - The listener that you would like to check.
 */
Runner.prototype.contains = function contains (item)
{
    return this.items.indexOf(item) !== -1;
};

/**
 * Remove all listeners from the Runner
 */
Runner.prototype.removeAll = function removeAll ()
{
    this.ensureNonAliasedItems();
    this.items.length = 0;

    return this;
};

/**
 * Remove all references, don't use after this.
 */
Runner.prototype.destroy = function destroy ()
{
    this.removeAll();
    this.items = null;
    this._name = null;
};

/**
 * `true` if there are no this Runner contains no listeners
 *
 * @member {boolean}
 * @readonly
 */
prototypeAccessors.empty.get = function ()
{
    return this.items.length === 0;
};

/**
 * The name of the runner.
 *
 * @member {string}
 * @readonly
 */
prototypeAccessors.name.get = function ()
{
    return this._name;
};

Object.defineProperties( Runner.prototype, prototypeAccessors );

/**
 * Alias for `emit`
 * @memberof PIXI.Runner#
 * @method dispatch
 * @see PIXI.Runner#emit
 */
Runner.prototype.dispatch = Runner.prototype.emit;

/**
 * Alias for `emit`
 * @memberof PIXI.Runner#
 * @method run
 * @see PIXI.Runner#emit
 */
Runner.prototype.run = Runner.prototype.emit;


//# sourceMappingURL=runner.es.js.map


/***/ })

}]);
//# sourceMappingURL=commons-node_modules_pixi_mesh-extras_lib_mesh-extras_es_js-node_modules_pixi_mixin-cache-as--be79ac.74296.js.map